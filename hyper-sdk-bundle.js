(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.hyperSDK = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/* global fetch */
// TODO: Persist to local storage
const DEFAULT_DNS_PROXY = 'gateway.mauve.moe';
const NEWLINE_REGEX = /\r?\n/;
const DAT_PROTOCOL = 'dat://';

module.exports = ({
  dnsProxy = DEFAULT_DNS_PROXY
} = {}) => {
  let cache = {};
  return {
    async resolveName(url, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }

      if (!cb) cb = noop;
      let domain = url;

      if (domain.startsWith(DAT_PROTOCOL)) {
        domain = url.slice(DAT_PROTOCOL.length);
      }

      if (cache[domain]) {
        if (cb) {
          cb(null, cache[domain]);
          return;
        } else {
          return cache[domain];
        }
      }

      try {
        const toFetch = `//${dnsProxy}/${domain}/.well-known/dat`;
        const response = await fetch(toFetch);
        const text = await response.text();
        const lines = text.split(NEWLINE_REGEX);
        const resolved = lines[0];
        const key = resolved.slice(DAT_PROTOCOL.length);
        cache[domain] = key;
        if (cb) cb(null, key);
      } catch (e) {
        if (cb) cb(e);else throw e;
      }
    },

    listCache() {
      return cache;
    },

    flushCache() {
      cache = {};
    }

  };
};

function noop() {}

},{}],2:[function(require,module,exports){
module.exports = require("./native");

},{"./native":3}],3:[function(require,module,exports){
const SwarmNetworker = require('@corestore/networker');

const RAA = require('random-access-application');

const RAM = require('random-access-memory');

const HypercoreProtocol = require('hypercore-protocol');

const Corestore = require('corestore');

const SDK = require("./sdk");

const DEFAULT_SWARM_OPTS = {
  extensions: [],
  preferredPort: 42666
};
const DEFAULT_CORESTORE_OPTS = {
  sparse: true
};

module.exports = async function createSDK(opts) {
  return SDK({ ...opts,
    backend: nativeBackend
  });
};

module.exports.createBackend = nativeBackend;

async function nativeBackend(opts) {
  let {
    storage,
    corestore,
    applicationName,
    persist,
    swarmOpts,
    corestoreOpts
  } = opts; // Derive storage if it isn't provided
  // Don't derive if corestore was provided

  if (!storage && !corestore) {
    if (persist !== false) {
      storage = RAA(applicationName);
    } else {
      // Nothing should be persisted. ðŸ¤·
      storage = RAM;
    }
  }

  if (!corestore) {
    corestore = new Corestore(storage, Object.assign({}, DEFAULT_CORESTORE_OPTS, corestoreOpts));
  } // The corestore needs to be opened before creating the swarm.


  await corestore.ready(); // I think this is used to create a persisted identity?
  // Needs to be created before the swarm so that it can be passed in

  const noiseSeed = await deriveSecret(applicationName, 'replication-keypair');
  const keyPair = HypercoreProtocol.keyPair(noiseSeed);
  const swarm = new SwarmNetworker(corestore, Object.assign({
    keyPair
  }, DEFAULT_SWARM_OPTS, swarmOpts));
  return {
    storage,
    corestore,
    swarm,
    deriveSecret,
    keyPair,
    close
  };

  async function deriveSecret(namespace, name) {
    return corestore.inner._deriveSecret(namespace, name);
  }

  function close(cb) {
    corestore.close(() => {
      swarm.close().then(cb, cb);
    });
  }
}

},{"./sdk":594,"@corestore/networker":4,"corestore":120,"hypercore-protocol":239,"random-access-application":414,"random-access-memory":423}],4:[function(require,module,exports){
(function (Buffer){(function (){
const {
  NanoresourcePromise: Nanoresource
} = require('nanoresource-promise/emitter');

const HypercoreProtocol = require('hypercore-protocol');

const hyperswarm = require("hyperswarm-web");

const codecs = require('codecs');

const pump = require('pump');

const maybe = require('call-me-maybe');

const STREAM_PEER = Symbol('networker-stream-peer');

class CorestoreNetworker extends Nanoresource {
  constructor(corestore, opts = {}) {
    super();
    this.corestore = corestore;
    this.opts = opts;
    this.keyPair = opts.keyPair || HypercoreProtocol.keyPair();
    this._replicationOpts = {
      encrypt: true,
      live: true,
      keyPair: this.keyPair,
      onauthenticate: opts.onauthenticate
    };
    this.streams = new Set();
    this.peers = new Set();
    this._joined = new Set();
    this._flushed = new Set();
    this._configurations = new Map();
    this._extensions = new Set();
    this._streamsProcessing = 0;
    this._streamsProcessed = 0; // Set in listen

    this.swarm = null;
    this.setMaxListeners(0);
  }

  _replicate(protocolStream) {
    // The initiator parameter here is ignored, since we're passing in a stream.
    this.corestore.replicate(false, { ...this._replicationOpts,
      stream: protocolStream
    });
  }

  async _flush(keyString, keyBuf) {
    await new Promise((resolve, reject) => {
      this.swarm.flush(err => {
        if (err) reject(err);else resolve();
      });
    });

    if (!this._joined.has(keyString)) {
      return;
    }

    const processingAfterFlush = this._streamsProcessing;

    if (this._streamsProcessed >= processingAfterFlush) {
      this._flushed.add(keyString);

      this.emit('flushed', keyBuf);
    } else {
      // Wait until the stream processing has caught up.
      const processedListener = () => {
        if (!this._joined.has(keyString)) {
          this.removeListener('stream-processed', processedListener);
          return;
        }

        if (this._streamsProcessed >= processingAfterFlush) {
          this._flushed.add(keyString);

          this.emit('flushed', keyBuf);
          this.removeListener('stream-processed', processedListener);
        }
      };

      this.on('stream-processed', processedListener);
    }
  }

  async _join(discoveryKey, opts = {}) {
    const keyString = toString(discoveryKey);
    const keyBuf = discoveryKey instanceof Buffer ? discoveryKey : Buffer.from(discoveryKey, 'hex');

    this._joined.add(keyString);

    this.emit('joined', keyBuf);
    this.swarm.join(keyBuf, {
      announce: opts.announce,
      lookup: opts.lookup
    });

    const flushedProm = this._flush(keyString, keyBuf);

    if (opts.flush !== false) await flushedProm;else flushedProm.catch(() => {});
  }

  _leave(discoveryKey) {
    const keyString = toString(discoveryKey);
    const keyBuf = discoveryKey instanceof Buffer ? discoveryKey : Buffer.from(discoveryKey, 'hex');

    this._joined.delete(keyString);

    return new Promise((resolve, reject) => {
      this.swarm.leave(keyBuf, err => {
        if (err) return reject(err);
        return resolve();
      });
    });
  }

  _registerAllExtensions(peer) {
    for (const ext of this._extensions) {
      ext._registerExtension(peer);
    }
  }

  _unregisterAllExtensions(peer) {
    for (const ext of this._extensions) {
      ext._unregisterExtension(peer);
    }
  }

  _addStream(stream) {
    this._replicate(stream);

    this.streams.add(stream);
    const peer = intoPeer(stream);
    this.peers.add(peer);
    stream[STREAM_PEER] = peer;

    this._registerAllExtensions(peer);

    this.emit('peer-add', peer);
    this.emit('handshake', stream);
  }

  _removeStream(stream) {
    this.streams.delete(stream);

    if (stream[STREAM_PEER]) {
      const peer = stream[STREAM_PEER];

      this._unregisterAllExtensions(peer);

      this.peers.delete(peer);
      this.emit('peer-remove', peer);
    }
  }

  _open() {
    const self = this;
    if (this.swarm) return;
    this.swarm = hyperswarm({ ...this.opts,
      announceLocalNetwork: true,
      queue: {
        multiplex: true
      }
    });
    this.swarm.on('error', err => this.emit('error', err));
    this.swarm.on('connection', (socket, info) => {
      const isInitiator = !!info.client;
      if (socket.remoteAddress === '::ffff:127.0.0.1' || socket.remoteAddress === '127.0.0.1') return null;
      var finishedHandshake = false;
      var processed = false;
      const protocolStream = new HypercoreProtocol(isInitiator, { ...this._replicationOpts
      });
      protocolStream.on('handshake', () => {
        const deduped = info.deduplicate(protocolStream.publicKey, protocolStream.remotePublicKey);

        if (!deduped) {
          finishedHandshake = true;

          self._addStream(protocolStream);
        }

        if (!processed) {
          processed = true;
          this._streamsProcessed++;
          this.emit('stream-processed');
        }
      });
      protocolStream.on('close', () => {
        this.emit('stream-closed', protocolStream, info, finishedHandshake);

        if (!processed) {
          processed = true;
          this._streamsProcessed++;
          this.emit('stream-processed');
        }
      });
      pump(socket, protocolStream, socket, err => {
        if (err) this.emit('replication-error', err);

        this._removeStream(protocolStream);
      });
      this.emit('stream-opened', protocolStream, info);
      this._streamsProcessing++;
    });
  }

  async _close() {
    if (!this.swarm) return null;

    for (const ext of this._extensions) {
      ext.destroy();
    }

    this._extensions.clear();

    for (const stream of this.streams) {
      stream.destroy();
    }

    return new Promise((resolve, reject) => {
      this.swarm.destroy(err => {
        if (err) return reject(err);
        this.swarm = null;
        return resolve();
      });
    });
  }

  listen() {
    return this.open();
  }

  status(discoveryKey) {
    if (Buffer.isBuffer(discoveryKey)) discoveryKey = discoveryKey.toString('hex');
    return this._configurations.get(discoveryKey);
  }

  allStatuses() {
    return [...this._configurations].map(([k, v]) => {
      return {
        discoveryKey: Buffer.from(k, 'hex'),
        ...v
      };
    });
  }

  configure(discoveryKey, opts = {}, cb) {
    return maybeOptional(cb, this._configure(discoveryKey, opts));
  }

  async _configure(discoveryKey, opts) {
    if (!this.swarm) this.open();
    if (this.swarm && this.swarm.destroyed) return;
    const config = {
      announce: opts.announce !== false,
      lookup: opts.lookup !== false
    };
    opts = { ...opts,
      ...config
    };
    const keyString = toString(discoveryKey);

    const prev = this._configurations.get(keyString);

    const joining = config.announce || config.lookup;
    if (joining) this._configurations.set(keyString, opts);else this._configurations.delete(keyString);

    if (joining) {
      if (opts.rejoin === false && prev && prev.lookup === config.lookup && prev.announce === config.announce) return;
      return this._join(discoveryKey, opts);
    } else {
      return this._leave(discoveryKey);
    }
  }

  joined(discoveryKey) {
    if (typeof discoveryKey !== 'string') discoveryKey = discoveryKey.toString('hex');
    return this._joined.has(discoveryKey);
  }

  flushed(discoveryKey) {
    if (typeof discoveryKey !== 'string') discoveryKey = discoveryKey.toString('hex');
    return this._flushed.has(discoveryKey);
  }

  registerExtension(name, handlers) {
    if (name && typeof name === 'object') return this.registerExtension(null, name);
    const ext = new SwarmExtension(this, name || handlers.name, handlers);

    this._extensions.add(ext);

    for (const peer of this.peers) {
      ext._registerExtension(peer);
    }

    return ext;
  }

}

module.exports = CorestoreNetworker;

class SwarmExtension {
  constructor(networker, name, opts) {
    if (typeof opts === 'function') opts = opts(this);
    this.networker = networker;
    this.name = name;
    this.encoding = codecs(opts && opts.encoding || 'binary');
    this._peerExtensions = new Map();
    this.onmessage = opts.onmessage;
    this.onerror = opts.onerror;
  }

  _registerExtension(peer) {
    peer.stream.extensions.exclusive = false;
    const peerExt = peer.stream.registerExtension(this.name, {
      encoding: this.encoding,
      onmessage: this.onmessage && (message => this.onmessage(message, peer)),
      onerror: this.onerror && (err => this.onerror(err))
    });

    this._peerExtensions.set(peer, peerExt);
  }

  _unregisterExtension(peer) {
    if (!this._peerExtensions.has(peer)) return;

    const peerExt = this._peerExtensions.get(peer);

    peerExt.destroy();

    this._peerExtensions.delete(peer);
  }

  broadcast(message) {
    for (const peerExt of this._peerExtensions.values()) {
      peerExt.send(message);
    }
  }

  send(message, peer) {
    const peerExt = this._peerExtensions.get(peer);

    if (!peer) throw new Error('Peer must be specified.');
    if (!peerExt) throw new Error('Extension not registered for peer ' + peer.remotePublicKey.toString('hex'));
    peerExt.send(message);
  }

  destroy() {
    for (const peerExt of this._peerExtensions.values()) {
      peerExt.destroy();
    }

    this._peerExtensions.clear();

    this.onmessage = null;
    this.onerror = null;
  }

}

function intoPeer(stream) {
  return {
    remotePublicKey: stream.remotePublicKey,
    remoteAddress: stream.remoteAddress,
    type: stream.remoteType,
    stream
  };
}

function toString(dk) {
  return typeof dk === 'string' ? dk : dk.toString('hex');
}

function noop() {}

function maybeOptional(cb, prom) {
  if (cb) maybe(cb, prom);else prom.catch(noop);
  return prom;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"call-me-maybe":113,"codecs":118,"hypercore-protocol":239,"hyperswarm-web":264,"nanoresource-promise/emitter":342,"pump":394}],5:[function(require,module,exports){
(function (process,Buffer){(function (){
const {
  EventEmitter
} = require('events');

const crypto = require('crypto');

const assert = require('nanocustomassert');

const pump = require('pump');

const log = require('debug')('discovery-swarm-webrtc');

const MMSTSignalClient = require("./lib/mmst-signal-client");

const {
  toHex,
  callbackPromise,
  resolveCallback
} = require("./lib/utils");

const errors = require("./lib/errors");

const {
  ERR_CONNECTION_DUPLICATED
} = errors;

const assertChannel = channel => assert(Buffer.isBuffer(channel) && channel.length === 32, 'Channel must be a buffer of 32 bytes');

class DiscoverySwarmWebrtc extends EventEmitter {
  constructor(opts = {}) {
    super();
    log('opts', opts);
    const {
      id = crypto.randomBytes(32),
      bootstrap,
      stream,
      simplePeer,
      maxPeers = 5,
      timeout = 15 * 1000,
      signal,
      mmst = {}
    } = opts;
    assert(Array.isArray(bootstrap) && bootstrap.length > 0, 'The `bootstrap` options is required.');
    assert(Buffer.isBuffer(id) && id.length === 32, 'The `id` option needs to be a Buffer of 32 bytes.');
    this.id = id;
    const queueTimeout = timeout * 2;
    const signalOptions = {
      id: this.id,
      bootstrap,
      createConnection: peer => this._createConnection(peer),
      requestTimeout: timeout,
      simplePeer,
      reconnectingWebsocket: {
        connectionTimeout: timeout
      }
    };
    this.signal = signal ? signal(signalOptions, this) : new MMSTSignalClient({ ...signalOptions,
      mmstOpts: {
        maxPeers,
        queueTimeout,
        // queue mmst
        lookupTimeout: timeout,
        ...mmst
      }
    });
    this._maxPeers = maxPeers;
    this._stream = stream;
    this._destroyed = false;

    this._initialize(opts);
  }

  get connected() {
    return this.signal.peersConnected;
  }

  get connecting() {
    return this.signal.peersConnecting;
  }

  listen() {// Empty method to respect the API of discovery-swarm
  }

  getPeers(channel) {
    if (channel) {
      return this.signal.getPeersByTopic(channel).filter(p => p.connected);
    }

    return this.signal.peersConnected;
  }

  join(channel) {
    this.signal.join(channel);
  }

  leave(channel, cb = callbackPromise()) {
    assertChannel(channel);
    resolveCallback(this.signal.leave(channel), cb);
    return cb.promise;
  }

  close(cb = callbackPromise()) {
    resolveCallback(this._close(), cb);
    return cb.promise;
  }

  async connect(channel, peerId) {
    assert(channel && Buffer.isBuffer(channel), 'channel must be a buffer');
    assert(peerId && Buffer.isBuffer(peerId), 'peerId must be a buffer');
    const peer = this.signal.connect(channel, peerId);
    peer.subscribeMediaStream = true;
    await peer.ready();
    return peer.stream;
  }

  async _close() {
    if (this._destroyed) return;
    this._destroyed = true;
    await this.signal.close();
    this.emit('close');
  }

  _initialize() {
    const signal = this.signal; // It would log the errors and prevent of throw it.

    this.on('error', (...args) => log('error', ...args));
    signal.on('peer-error', err => this.emit('error', err));
    signal.on('error', err => this.emit('error', err));
    signal.open().catch(err => process.nextTick(() => this.emit('error', err)));
    signal.on('candidates-updated', (...args) => this.emit('candidates-updated', ...args));
  }

  _createConnection(peer) {
    peer.subscribeMediaStream = true;
    peer.channel = peer.topic;

    peer.getInfo = () => ({
      id: peer.id,
      channel: peer.topic,
      initiator: peer.initiator
    });

    peer.printInfo = () => ({
      id: toHex(peer.id),
      channel: toHex(peer.topic),
      initiator: peer.initiator
    });

    log('createConnection', {
      info: peer.printInfo()
    });

    try {
      const duplicate = this._checkForDuplicate(peer);

      if (duplicate) {
        if (duplicate === peer) {
          // current incoming connection
          throw new ERR_CONNECTION_DUPLICATED(toHex(this.id), toHex(peer.id));
        } else {
          // old connection
          duplicate.destroy();
        }
      }

      this._bindSocketEvents(peer);

      return peer;
    } catch (err) {
      this.emit('connect-failed', err, peer.getInfo());
      throw err;
    }
  }

  _bindSocketEvents(peer) {
    const info = peer.getInfo();
    peer.on('error', err => {
      log('error', err);
      this.emit('connection-error', err, info);
    });
    peer.on('connect', () => {
      log('connect', {
        peer
      });

      if (peer.stream.destroyed) {
        return;
      }

      if (!this._stream) {
        this._handleConnection(peer.stream, info);

        return;
      }

      const conn = this._stream(info);

      if (!conn) {
        this._handleConnection(peer.stream, info);

        return;
      }

      this.emit('handshaking', conn, info);
      conn.on('handshake', this._handshake.bind(this, conn, info));
      pump(peer.stream, conn, peer.stream);
    });
    peer.on('close', () => {
      log('close', {
        peer
      });
      this.emit('connection-closed', peer.stream, info);
    });
  }

  _handshake(conn, info) {
    this._handleConnection(conn, info);
  }

  _handleConnection(conn, info) {
    this.emit('connection', conn, info);
  }

  _checkForDuplicate(peer) {
    const oldPeer = this.signal.getPeersByTopic(peer.channel).find(p => p.id.equals(peer.id) && !p.sessionId.equals(peer.sessionId));

    if (!oldPeer) {
      return;
    }

    const connections = [peer, oldPeer];
    /**
     * The first case is to have duplicate connections from the same origin (remote or local).
     * In this case we do a sort by connectionId and destroy the first one.
     */

    if (peer.initiator && oldPeer.initiator || !peer.initiator && !oldPeer.initiator) {
      return connections.sort((a, b) => Buffer.compare(a.sessionId, b.sessionId))[0];
    }
    /**
     * The second case is to have duplicate connections where each connection is started from different origins.
     * In this case we do a sort by peer id and destroy the first one.
     */


    const toDestroy = [this.id, peer.id].sort(Buffer.compare)[0];
    return connections.find(p => p.id.equals(toDestroy));
  }

}

module.exports = (...args) => new DiscoverySwarmWebrtc(...args);

module.exports.errors = errors;

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./lib/errors":6,"./lib/mmst-signal-client":7,"./lib/utils":9,"_process":380,"buffer":97,"crypto":128,"debug":131,"events":172,"nanocustomassert":320,"pump":394}],6:[function(require,module,exports){
const nanoerror = require('nanoerror');

function createError(code, message) {
  exports[code] = nanoerror(code, message);
}

createError('ERR_MAX_PEERS_REACHED', 'max peers reached: %s');
createError('ERR_INVALID_CHANNEL', 'invalid channel: %s');
createError('ERR_CONNECTION_DUPLICATED', 'connection duplicated: %s -> %s');

},{"nanoerror":321}],7:[function(require,module,exports){
(function (Buffer){(function (){
const {
  SocketSignalWebsocketClient
} = require('socket-signal-websocket');

const MMST = require('mostly-minimal-spanning-tree');

const assert = require('nanocustomassert');

const {
  Readable
} = require('stream');

const log = require('debug')('discovery-swarm-webrtc:mmst-signal');

const {
  toHex
} = require("./utils");

const {
  ERR_INVALID_CHANNEL,
  ERR_MAX_PEERS_REACHED
} = require("./errors");

const Scheduler = require("./scheduler");

const assertChannel = channel => assert(Buffer.isBuffer(channel) && channel.length === 32, 'Channel must be a buffer of 32 bytes');

const kOnConnected = Symbol('mmstsignal.onconnected');
const kGetCandidates = Symbol('mmstsignal.getcandidates');
module.exports = class MMSTSignal extends SocketSignalWebsocketClient {
  constructor(opts = {}) {
    const {
      bootstrap,
      createConnection,
      mmst,
      mmstOpts = {},
      strict = true,
      ...clientOpts
    } = opts;
    super(bootstrap, clientOpts);
    this._createConnection = createConnection;
    this._mmstOpts = mmstOpts; // if strict is false the network will allow situations where the maxPeers can be higher if is needed.

    this._strict = strict;
    this._channels = new Map();
    this._mmsts = new Map();
    this._candidates = new Map();
    this._scheduler = new Scheduler();
    this[kOnConnected] = this[kOnConnected].bind(this);
  }

  join(channel) {
    assertChannel(channel);
    const channelStr = toHex(channel);

    if (!this._channels.has(channelStr)) {
      this._channels.set(channelStr, channel);

      const defaultOpts = {
        id: this.id,
        lookup: () => this._lookup(channel),
        connect: async to => {
          await this.open();

          try {
            const peer = this.connect(channel, to);

            this._runCreateConnection(peer);

            await peer.ready();
            return peer.stream;
          } catch (err) {
            // Remove a candidate.
            const candidates = this[kGetCandidates](channel);
            candidates.list = candidates.list.filter(candidate => !candidate.equals(to));

            if (candidates.list.length === 0) {
              candidates.lookup = true;
            }

            throw err;
          }
        }
      };
      let mmst;

      if (typeof this._mmstOpts === 'function') {
        mmst = this._mmstOpts(defaultOpts);
      } else {
        mmst = new MMST({ ...this._mmstOpts,
          ...defaultOpts
        });
      }

      this._mmsts.set(channelStr, mmst);
    }

    if (this.connected) {
      super.join(channel).catch(() => {});
    }
  }

  async leave(channel) {
    assertChannel(channel);
    const channelStr = toHex(channel);

    this._scheduler.delete(channelStr);

    this._mmsts.get(channelStr).destroy();

    this._mmsts.delete(channelStr);

    this._channels.delete(channelStr);

    this._candidates.delete(channelStr);

    await super.leave(channel);
    await super.closeConnectionsByTopic(channel);
  }

  async _open() {
    this.on('connected', this[kOnConnected]);
    this.on('join', async (channel, peers) => {
      log('discover', {
        channel
      });
      if (!this.hasChannel(channel)) return;
      await this._updateCandidates(channel, peers);
      await this._run(channel);

      this._scheduler.add(channel.toString('hex'), async () => {
        const candidates = this[kGetCandidates](channel);

        if (candidates.list.length === 0 || this.getPeersByTopic(channel).length === 0) {
          candidates.lookup = true;
          await this._updateCandidates(channel);
          await this._run(channel);
        }
      });
    });
    this.onIncomingPeer(peer => this._runCreateConnection(peer));
    await super._open();
  }

  hasChannel(channel) {
    return this._channels.has(toHex(channel));
  }

  _runCreateConnection(peer) {
    if (!this.hasChannel(peer.topic)) {
      throw new ERR_INVALID_CHANNEL(toHex(peer.topic));
    }

    const mmst = this._getMMST(peer.topic);

    if (this._strict && !peer.initiator && !mmst.shouldHandleIncoming()) {
      throw new ERR_MAX_PEERS_REACHED(this._mmstOpts.maxPeers);
    }

    this._createConnection(peer);

    if (!peer.initiator) {
      mmst.addConnection(peer.id, peer.stream);
    }

    return peer;
  }

  async _close() {
    await super._close();
    this.removeListener('connected', this[kOnConnected]);

    this._mmsts.forEach(mmst => mmst.destroy());

    this._mmsts.clear();

    this._channels.clear();

    this._candidates.clear();

    this._scheduler.clear();
  }

  async _run(channel) {
    if (!this.connected) return;
    if (this.getPeersByTopic(channel).filter(p => p.initiator).length > 0) return;

    try {
      if (this.hasChannel(channel)) {
        await this._getMMST(channel).run();
      }
    } catch (err) {
      // nothing to do
      log('run error', err.message);
    }
  }

  _getMMST(channel) {
    return this._mmsts.get(toHex(channel));
  }

  _lookup(channel) {
    const stream = new Readable({
      read() {},

      objectMode: true
    });

    this._updateCandidates(channel).finally(() => {
      stream.push(this[kGetCandidates](channel).list);
      stream.push(null);
    });

    return stream;
  }

  async [kOnConnected](reconnected) {
    this._channels.forEach(channel => {
      return super.join(channel).catch(() => {});
    });
  }

  async _updateCandidates(channel, peers) {
    // We try to minimize how many times we get candidates from the signal.
    const candidates = this[kGetCandidates](channel);
    let list = candidates.list;

    if (peers) {
      list = peers;
    } else if (candidates.lookup) {
      candidates.lookup = false;

      try {
        list = await this.lookup(channel);
      } catch (err) {}
    }

    candidates.list = list.filter(id => !id.equals(this.id));
    this.emit('candidates-updated', channel, list);
  }

  [kGetCandidates](channel) {
    assert(Buffer.isBuffer(channel));

    let candidates = this._candidates.get(toHex(channel));

    if (candidates) {
      return candidates;
    }

    candidates = {
      list: [],
      lookup: false
    };

    this._candidates.set(toHex(channel), candidates);

    return candidates;
  }

};

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})
},{"../../../is-buffer/index.js":282,"./errors":6,"./scheduler":8,"./utils":9,"debug":131,"mostly-minimal-spanning-tree":314,"nanocustomassert":320,"socket-signal-websocket":510,"stream":548}],8:[function(require,module,exports){
const delay = ms => {
  let cancel;
  let finished = false;
  const p = new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      finished = true;
      resolve();
    }, ms);

    cancel = () => {
      if (finished) return;
      clearTimeout(timer);
      reject(new Error('timeout'));
    };
  });
  p.cancel = cancel;
  return p;
};

class Task {
  constructor(fn) {
    this._fn = fn;
    this._stop = false;
    this.run();
  }

  run() {
    (async () => {
      while (!this._stop) {
        this._time = delay(Math.floor(Math.random() * 11) * 1000);
        await this._time;
        await this._fn();
      }
    })().catch(() => {});
  }

  stop() {
    this._time && this._time.cancel();
    this._stop = false;
  }

}

module.exports = class Scheduler {
  constructor() {
    this._tasks = new Map();
  }

  add(id, fn) {
    this._tasks.set(id, new Task(fn));
  }

  delete(id) {
    const task = this._tasks.get(id);

    task && task.stop();

    this._tasks.delete(id);
  }

  clear() {
    this._tasks.forEach(task => {
      task.stop();
    });

    this._tasks.clear();
  }

};

},{}],9:[function(require,module,exports){
(function (Buffer){(function (){
const toHex = buff => {
  if (typeof buff === 'string') {
    return buff;
  }

  if (Buffer.isBuffer(buff)) {
    return buff.toString('hex');
  }

  throw new Error('Cannot convert the buffer to hex: ', buff);
};

const toBuffer = str => {
  if (Buffer.isBuffer(str)) {
    return str;
  }

  if (typeof str === 'string') {
    return Buffer.from(str, 'hex');
  }

  throw new Error('Cannot convert the string to buffer: ', str);
};

const callbackPromise = () => {
  let callback;
  const promise = new Promise((resolve, reject) => {
    callback = (err, value) => {
      if (err) reject(err);else resolve(value);
    };
  });
  callback.promise = promise;
  return callback;
};

const resolveCallback = (promise, cb) => {
  if (!promise.then) {
    promise = Promise.resolve();
  }

  return promise.then(result => cb(null, result)).catch(cb);
};

module.exports = {
  toHex,
  toBuffer,
  callbackPromise,
  resolveCallback
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],10:[function(require,module,exports){
const {
  callbackMethods,
  cancelableMethods
} = require("./methods");

const kHypercore = Symbol('hypercore');
const kValue = Symbol('value');

const getValue = value => value && typeof value === 'object' ? value[kValue] : null;

class HypercorePromise {
  constructor(...args) {
    let feed;

    if (args.length === 1 && args[0].get && args[0].append) {
      feed = args[0];
    } else {
      feed = require('hypercore')(...args);
    }

    this._cache = {};
    return new Proxy(feed, this);
  }

  get(target, propKey) {
    if (propKey === kHypercore) return target;
    const value = Reflect.get(target, propKey);
    if (typeof value === 'function') return this._getMethod(target, propKey, value);
    return value;
  }

  _getMethod(target, propKey, func) {
    let method = this._cache[propKey];
    if (method) return method;

    if (callbackMethods.includes(propKey)) {
      method = (...args) => {
        // We keep suporting the callback style if we get a callback.
        if (typeof args[args.length - 1] === 'function') {
          return Reflect.apply(func, target, args);
        }

        let id;
        const p = new Promise((resolve, reject) => {
          args.push((err, ...result) => {
            if (err) return reject(err);

            if (result.length > 1) {
              resolve(result);
            } else {
              resolve(result[0]);
            }
          });
          id = Reflect.apply(func, target, args);
        });

        if (id) {
          p[kValue] = id;
        }

        return p;
      };
    } else if (cancelableMethods.includes(propKey)) {
      method = (start, end) => {
        if (end !== undefined) {
          return Reflect.apply(func, target, [start, end]);
        }

        let id = getValue(start);
        if (!id) id = start;
        return Reflect.apply(func, target, [id]);
      };
    } else {
      method = (...args) => Reflect.apply(func, target, args);
    }

    this._cache[propKey] = method;
    return method;
  }

}

module.exports = (...args) => new HypercorePromise(...args);

module.exports.HypercorePromise = HypercorePromise;

module.exports.getHypercore = hypercorePromise => hypercorePromise[kHypercore];

module.exports.getValue = getValue;

},{"./methods":11,"hypercore":241}],11:[function(require,module,exports){
module.exports = {
  callbackMethods: ['ready', 'open', 'update', 'download', 'proof', 'put', 'clear', 'signature', 'verify', 'rootHashes', 'seek', 'head', 'get', 'getBatch', 'finalize', 'append', 'flush', 'audit', 'destroyStorage', 'close'],
  cancelableMethods: ['cancel', 'undownload']
};

},{}],12:[function(require,module,exports){
module.exports = ['ready', 'readFile', 'writeFile', 'unlink', 'mkdir', 'rmdir', 'readdir', 'stat', 'stats', 'lstat', 'access', 'open', 'read', 'write', 'symlink', 'mount', 'unmount', 'getAllMounts', 'close', 'truncate', 'destroyStorage', 'clear', 'setMetadata', 'removeMetadata', 'copy', 'createTag', 'getAllTags', 'deleteTag', 'getTaggedVersion'];

},{}],13:[function(require,module,exports){
const hyperdrive = require('hyperdrive');

const callbackMethods = require("./callback-methods");

const kHyperdrive = Symbol('hyperdrive');

const getHyperdrive = drive => drive[kHyperdrive];

class HyperdrivePromise {
  constructor(...args) {
    let drive;

    if (args.length === 1 && args[0].readFile) {
      drive = args[0];
    } else {
      drive = hyperdrive(...args);
    }

    this._cache = {};

    this._createDiffStream.bind(this);

    this._checkout.bind(this);

    return new Proxy(drive, this);
  }

  get(target, propKey) {
    if (propKey === kHyperdrive) return target;
    if (propKey === 'createDiffStream') return this._createDiffStream;
    if (propKey === 'checkout') return this._checkout;
    const value = Reflect.get(target, propKey);
    if (typeof value === 'function') return this._getMethod(target, propKey, value);
    return value;
  }

  _getMethod(target, propKey, func) {
    let method = this._cache[propKey];
    if (method) return method;

    if (callbackMethods.includes(propKey)) {
      method = (...args) => {
        // We keep suporting the callback style if we get a callback.
        if (typeof args[args.length - 1] === 'function') {
          return Reflect.apply(func, target, args);
        }

        return new Promise((resolve, reject) => {
          args.push((err, ...result) => {
            if (err) return reject(err);

            if (result.length > 1) {
              resolve(result);
            } else {
              resolve(result[0]);
            }
          });
          Reflect.apply(func, target, args);
        });
      };
    } else {
      method = (...args) => Reflect.apply(func, target, args);
    }

    this._cache[propKey] = method;
    return method;
  }

  _createDiffStream(other, prefix, opts) {
    if (other instanceof HyperdrivePromise) {
      other = getHyperdrive(other);
    }

    return getHyperdrive(this).createDiffStream(other, prefix, opts);
  }

  _checkout(version, opts) {
    const h = getHyperdrive(this).checkout(version, opts);
    return new HyperdrivePromise(h);
  }

}

module.exports = (...args) => new HyperdrivePromise(...args);

module.exports.getHyperdrive = getHyperdrive;

},{"./callback-methods":12,"hyperdrive":251}],14:[function(require,module,exports){
const codecs = require('codecs');

class AbstractExtension {
  constructor(local, name, handlers = {}) {
    this.id = 0;
    this.name = name;
    this.encoding = codecs(handlers.encoding || 'binary');
    this.handlers = handlers;
    this.local = local;
  }

  encode(message) {
    return this.encoding.encode(message);
  }

  remoteSupports() {
    return !!(this.local && this.local.map && this.local.map[this.id] === this);
  }

  onmessage(buf, context) {
    if (!this.handlers.onmessage) return;
    let message;

    try {
      message = this.encoding.decode(buf);
    } catch (err) {
      if (this.handlers.onerror) this.handlers.onerror(err, context);
      return;
    }

    this.handlers.onmessage(message, context);
  }

  get destroyed() {
    return this.local === null;
  }

  destroy() {
    if (this.local === null) return;

    this.local._remove(this);

    this.local = null;
  }

  static createLocal(handlers = null) {
    return new Local(handlers, this);
  }

}

class Remote {
  constructor(local) {
    this.local = local;
    this.names = null;
    this.map = null;
    this.changes = 0;
  }

  update(names) {
    this.names = names;
    this.changes = 0;
  }

  onmessage(id, message, context = null) {
    if (this.changes !== this.local.changes) {
      this.map = this.names ? match(this.local.messages, this.names) : null;
      this.changes = this.local.changes;
    }

    const m = this.map && this.map[id];
    if (m) m.onmessage(message, context);
  }

}

class Local {
  constructor(handlers = null, M) {
    this.messages = [];
    this.handlers = handlers;
    this.Extension = M;
    this.changes = 1;
    this.exclusive = true;
  }

  get length() {
    return this.messages.length;
  }

  [Symbol.iterator]() {
    return this.messages[Symbol.iterator]();
  }

  get(name) {
    // technically we can bisect here, but yolo
    for (const m of this.messages) {
      if (m.name === name) return m;
    }

    return null;
  }

  add(name, handlers) {
    let m;

    if (typeof handlers !== 'function') {
      m = new this.Extension(this, name, handlers);
    } else {
      m = new this.Extension(this, name, {});
      m.handlers = handlers(m) || {};
      m.encoding = codecs(m.handlers.encoding || 'binary');
    }

    this.changes++;
    this.messages.push(m);
    this.messages.sort(sortMessages);

    for (let i = 0; i < this.messages.length; i++) {
      this.messages[i].id = i;
    }

    if (this.exclusive) {
      if (m.id > 0 && this.messages[m.id - 1].name === m.name || m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name) {
        this._remove(m);

        throw new Error('Cannot add multiple messages with the same name');
      }
    }

    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate();
    return m;
  }

  remote() {
    return new Remote(this);
  }

  _remove(m) {
    this.changes++;
    this.messages.splice(m.id, 1);
    m.id = -1;
    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate();
  }

  names() {
    const names = new Array(this.messages.length);

    for (let i = 0; i < names.length; i++) {
      names[i] = this.messages[i].name;
    }

    return names;
  }

}

function sortMessages(a, b) {
  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
}

function match(local, remote) {
  let i = 0;
  let j = 0;
  const map = new Array(remote.length);

  while (i < local.length && j < remote.length) {
    const l = local[i].name;
    const r = remote[j];
    if (l < r) i++;else if (l > r) j++;else map[j++] = local[i];
  }

  return map;
}

module.exports = AbstractExtension;

},{"codecs":118}],15:[function(require,module,exports){
/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */
module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError();
  if ('function' != typeof fn) throw new TypeError();
  var ret = [];

  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }

  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],16:[function(require,module,exports){
// crc16 impl, optimized for numeric inputs
var TABLE = [0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0];
module.exports = crc16;

function crc16(n) {
  var crc = 0;
  var r = 0;

  for (var i = 0; i < 8; i++) {
    r = n & 0xff;
    n = (n - r) / 256;
    crc = (crc << 8 ^ TABLE[(crc >> 8 ^ r) & 0xff]) & 0xffff;
  }

  return crc;
}

},{}],17:[function(require,module,exports){
var hash = require("./crc16");

module.exports = LRU;

function LRU(max, opts) {
  if (!(this instanceof LRU)) return new LRU(max, opts);
  if (!opts) opts = {}; // how many collisions before evicting (factor of two for fast modulo)

  this.collisions = factorOfTwo(opts.collisions || opts.bucketSize || 4); // buckets should be a factor of two for fast modulo as well

  this.buckets = factorOf(max, this.collisions) / this.collisions; // we use 16bit hashing to bucket index must be <0xffff

  while (this.buckets > 65536) {
    this.buckets >>= 1;
    this.collisions <<= 1;
  }

  this.size = this.buckets * this.collisions;
  this.wrap = !opts.indexedValues;
  this.cache = new Array(this.size);
  this.hash = this.buckets === 65536 ? hash : maskedHash(this.buckets - 1);
  this.evict = opts.evict || null;
}

LRU.prototype.set = function (index, val) {
  var pageStart = this.collisions * this.hash(index);
  var pageEnd = pageStart + this.collisions;
  var ptr = pageStart;
  var page = null;

  while (ptr < pageEnd) {
    page = this.cache[ptr];

    if (!page) {
      // no exiting version, but we have space to store it
      page = this.cache[ptr] = this.wrap ? new Node(index, val) : val;
      move(this.cache, pageStart, ptr, page);
      return;
    }

    if (page.index === index) {
      // update existing version and move to head of bucket
      if (this.wrap) page.value = val;else this.cache[ptr] = val;
      move(this.cache, pageStart, ptr, page);
      return;
    }

    ptr++;
  } // bucket is full, update oldest (last element in bucket)


  if (this.wrap) {
    if (this.evict) this.evict(page.index, page.value);
    page.index = index;
    page.value = val;
  } else {
    if (this.evict) this.evict(page.index, page);
    this.cache[ptr - 1] = val;
  }

  move(this.cache, pageStart, ptr - 1, page);
};

LRU.prototype.get = function (index) {
  var pageStart = this.collisions * this.hash(index);
  var pageEnd = pageStart + this.collisions;
  var ptr = pageStart;

  while (ptr < pageEnd) {
    var page = this.cache[ptr++];
    if (!page) return null;
    if (page.index !== index) continue; // we found it! move to head of bucket and return value

    move(this.cache, pageStart, ptr - 1, page);
    return this.wrap ? page.value : page;
  }

  return null;
};

function move(list, index, itemIndex, item) {
  while (itemIndex > index) list[itemIndex] = list[--itemIndex];

  list[index] = item;
}

function Node(index, value) {
  this.index = index;
  this.value = value;
}

function factorOf(n, factor) {
  n = factorOfTwo(n);

  while (n & factor - 1) n <<= 1;

  return n;
}

function factorOfTwo(n) {
  if (n && !(n & n - 1)) return n;
  var p = 1;

  while (p < n) p <<= 1;

  return p;
}

function maskedHash(mask) {
  return function (n) {
    return hash(n) & mask;
  };
}

},{"./crc16":16}],18:[function(require,module,exports){
'use strict';

const asn1 = exports;
asn1.bignum = require('bn.js');
asn1.define = require("./asn1/api").define;
asn1.base = require("./asn1/base");
asn1.constants = require("./asn1/constants");
asn1.decoders = require("./asn1/decoders");
asn1.encoders = require("./asn1/encoders");

},{"./asn1/api":19,"./asn1/base":21,"./asn1/constants":25,"./asn1/decoders":27,"./asn1/encoders":30,"bn.js":32}],19:[function(require,module,exports){
'use strict';

const encoders = require("./encoders");

const decoders = require("./decoders");

const inherits = require('inherits');

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }

  inherits(Generated, Base);

  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der'; // Lazily create decoder

  if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der'; // Lazily create encoder

  if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc,
/* internal */
reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./decoders":27,"./encoders":30,"inherits":279}],20:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const Reporter = require("../base/reporter").Reporter;

const Buffer = require('safer-buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);

  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}

inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  } // Or accept compatible API


  const isCompatible = typeof data === 'object' && Buffer.isBuffer(data.base) && data.constructor.name === 'DecoderBuffer' && typeof data.offset === 'number' && typeof data.length === 'number' && typeof data.save === 'function' && typeof data.restore === 'function' && typeof data.isEmpty === 'function' && typeof data.readUInt8 === 'function' && typeof data.skip === 'function' && typeof data.raw === 'function';
  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return {
    offset: this.offset,
    reporter: Reporter.prototype.save.call(this)
  };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;
  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);
  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);else return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');
  const res = new DecoderBuffer(this.base); // Share reporter state

  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function (item) {
      if (!EncoderBuffer.isEncoderBuffer(item)) item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}

exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  } // Or accept compatible API


  const isCompatible = typeof data === 'object' && data.constructor.name === 'EncoderBuffer' && typeof data.length === 'number' && typeof data.join === 'function';
  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out) out = Buffer.alloc(this.length);
  if (!offset) offset = 0;
  if (this.length === 0) return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function (item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number') out[offset] = this.value;else if (typeof this.value === 'string') out.write(this.value, offset);else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base/reporter":23,"inherits":279,"safer-buffer":447}],21:[function(require,module,exports){
'use strict';

const base = exports;
base.Reporter = require("./reporter").Reporter;
base.DecoderBuffer = require("./buffer").DecoderBuffer;
base.EncoderBuffer = require("./buffer").EncoderBuffer;
base.Node = require("./node");

},{"./buffer":20,"./node":22,"./reporter":23}],22:[function(require,module,exports){
'use strict';

const Reporter = require("../base/reporter").Reporter;

const EncoderBuffer = require("../base/buffer").EncoderBuffer;

const DecoderBuffer = require("../base/buffer").DecoderBuffer;

const assert = require('minimalistic-assert'); // Supported tags


const tags = ['seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr']; // Public methods list

const methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains'].concat(tags); // Overrided methods list

const overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;
  state.name = name;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null; // State

  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null; // Should create new instance on each method

  if (!state.parent) {
    state.children = [];

    this._wrap();
  }
}

module.exports = Node;
const stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains'];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function (prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function (method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;
  assert(state.parent === null);
  body.call(this); // Filter children

  state.children = state.children.filter(function (child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState; // Filter children and args

  const children = args.filter(function (arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function (arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children; // Replace parent to maintain backward link

    children.forEach(function (child) {
      child._baseState.parent = this;
    }, this);
  }

  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function (arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object) return arg;
      const res = {};
      Object.keys(arg).forEach(function (key) {
        if (key == (key | 0)) key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
}; //
// Overrided methods
//


overrided.forEach(function (method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
}); //
// Public methods
//

tags.forEach(function (tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;
  state.optional = true;
  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;
  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;
  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) this._useArgs(args);
  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;
  state.any = true;
  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;
  assert(state.choice === null);
  state.choice = obj;

  this._useArgs(Object.keys(obj).map(function (key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
}; //
// Decoding
//


Node.prototype._decode = function decode(input, options) {
  const state = this._baseState; // Decode root node

  if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
  let result = state['default'];
  let present = true;
  let prevKey = null;
  if (state.key !== null) prevKey = input.enterKey(state.key); // Check if tag is there

  if (state.optional) {
    let tag = null;
    if (state.explicit !== null) tag = state.explicit;else if (state.implicit !== null) tag = state.implicit;else if (state.tag !== null) tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();

      try {
        if (state.choice === null) this._decodeGeneric(state.tag, input, options);else this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }

      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);
      if (input.isError(present)) return present;
    }
  } // Push object on stack


  let prevObj;
  if (state.obj && present) prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);

      if (input.isError(explicit)) return explicit;
      input = explicit;
    }

    const start = input.offset; // Unwrap implicit and normal values

    if (state.use === null && state.choice === null) {
      let save;
      if (state.any) save = input.save();

      const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);

      if (input.isError(body)) return body;
      if (state.any) result = input.raw(save);else input = body;
    }

    if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, 'tagged');
    if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, 'content'); // Select proper method for tag

    if (state.any) {// no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result)) return result; // Decode children

    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    } // Decode contained/encoded by schema, only in bit or octet strings


    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  } // Pop object


  if (state.obj && present) result = input.leaveObject(prevObj); // Set key

  if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);else if (prevKey !== null) input.exitKey(prevKey);
  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;
  if (tag === 'seq' || tag === 'set') return null;
  if (tag === 'seqof' || tag === 'setof') return this._decodeList(input, tag, state.args[0], options);else if (/str$/.test(tag)) return this._decodeStr(input, tag, options);else if (tag === 'objid' && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options);else if (tag === 'objid') return this._decodeObjid(input, null, null, options);else if (tag === 'gentime' || tag === 'utctime') return this._decodeTime(input, tag, options);else if (tag === 'null_') return this._decodeNull(input, options);else if (tag === 'bool') return this._decodeBool(input, options);else if (tag === 'objDesc') return this._decodeStr(input, tag, options);else if (tag === 'int' || tag === 'enum') return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {
  const state = this._baseState; // Create altered use decoder if implicit is set

  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];

  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }

  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;
  Object.keys(state.choice).some(function (key) {
    const save = input.save();
    const node = state.choice[key];

    try {
      const value = node._decode(input, options);

      if (input.isError(value)) return false;
      result = {
        type: key,
        value: value
      };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }

    return true;
  }, this);
  if (!match) return input.error('Choice not matched');
  return result;
}; //
// Encoding
//


Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data) return;

  const result = this._encodeValue(data, reporter, parent);

  if (result === undefined) return;
  if (this._skipDefault(result, reporter, parent)) return;
  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState; // Decode root node

  if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
  let result = null; // Set reporter to share it with a child class

  this.reporter = reporter; // Check if data is there

  if (state.optional && data === undefined) {
    if (state['default'] !== null) data = state['default'];else return;
  } // Encode children first


  let content = null;
  let primitive = false;

  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function (child) {
      if (child._baseState.tag === 'null_') return child._encode(null, reporter, data);
      if (child._baseState.key === null) return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);
      if (typeof data !== 'object') return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);

      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function (child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1)) return reporter.error('Too many args for : ' + state.tag);
      if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array');
      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function (item) {
        const state = this._baseState;
        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  } // Encode data itself


  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null) reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
    }
  } // Wrap in explicit


  if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, 'context', result);
  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;
  const node = state.choice[data.type];

  if (!node) {
    assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
  }

  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;
  if (/str$/.test(tag)) return this._encodeStr(data, tag);else if (tag === 'objid' && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);else if (tag === 'objid') return this._encodeObjid(data, null, null);else if (tag === 'gentime' || tag === 'utctime') return this._encodeTime(data, tag);else if (tag === 'null_') return this._encodeNull();else if (tag === 'int' || tag === 'enum') return this._encodeInt(data, state.args && state.reverseArgs[0]);else if (tag === 'bool') return this._encodeBool(data);else if (tag === 'objDesc') return this._encodeStr(data, tag);else throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

},{"../base/buffer":20,"../base/reporter":23,"minimalistic-assert":312}],23:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}

exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;
  return {
    obj: state.obj,
    pathLen: state.path.length
  };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;
  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;
  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;
  const inherited = msg instanceof ReporterError;

  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function (elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial) throw err;
  if (!inherited) state.errors.push(err);
  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial) return result;
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}

inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }

  return this;
};

},{"inherits":279}],24:[function(require,module,exports){
'use strict'; // Helper

function reverse(map) {
  const res = {};
  Object.keys(map).forEach(function (key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key) key = key | 0;
    const value = map[key];
    res[value] = key;
  });
  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);
exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);

},{}],25:[function(require,module,exports){
'use strict';

const constants = exports; // Helper

constants._reverse = function reverse(map) {
  const res = {};
  Object.keys(map).forEach(function (key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key) key = key | 0;
    const value = map[key];
    res[value] = key;
  });
  return res;
};

constants.der = require("./der");

},{"./der":24}],26:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const bignum = require('bn.js');

const DecoderBuffer = require("../base/buffer").DecoderBuffer;

const Node = require("../base/node"); // Import DER constants


const der = require("../constants/der");

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity; // Construct base tree

  this.tree = new DERNode();

  this.tree._init(entity.body);
}

module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
}; // Tree methods


function DERNode(parent) {
  Node.call(this, 'der', parent);
}

inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty()) return false;
  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  buffer.restore(state);
  return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + 'of' === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"'); // Failure

  if (buffer.isError(len)) return len;

  if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"'); // Indefinite length... find END tag

  const state = buffer.save();

  const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');

  if (buffer.isError(res)) return res;
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag)) return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len)) return len;
    let res;
    if (tag.primitive || len !== null) res = buffer.skip(len);else res = this._skipUntilEnd(buffer, fail); // Failure

    if (buffer.isError(res)) return res;
    if (tag.tagStr === 'end') break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
  const result = [];

  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');

    if (buffer.isError(possibleEnd)) return possibleEnd;
    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd) break;
    result.push(res);
  }

  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused)) return unused;
    return {
      unused: unused,
      data: buffer.raw()
    };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1) return buffer.error('Decoding of string type: bmpstr length mismatch');
    let str = '';

    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }

    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');

    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' + 'numstr unsupported characters');
    }

    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');

    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' + 'printstr unsupported characters');
    }

    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;

  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;

    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }

  if (subident & 0x80) identifiers.push(ident);
  const first = identifiers[0] / 40 | 0;
  const second = identifiers[0] % 40;
  if (relative) result = identifiers;else result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined) tmp = values[result.join('.')];
    if (tmp !== undefined) result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();
  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;

  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70) year = 2000 + year;else year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res)) return res;else return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);
  if (values) res = values[res.toString(10)] || res;
  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getDecoder('der').tree;
}; // Utility methods


function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag)) return tag;
  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0; // Multi-octet tag - load

  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;

    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct)) return oct;
      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }

  const tagStr = der.tag[tag];
  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len)) return len; // Indefinite form

  if (!primitive && len === 0x80) return null; // Definite form

  if ((len & 0x80) === 0) {
    // Short form
    return len;
  } // Long form


  const num = len & 0x7f;
  if (num > 4) return buf.error('length octect is too long');
  len = 0;

  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j)) return j;
    len |= j;
  }

  return len;
}

},{"../base/buffer":20,"../base/node":22,"../constants/der":24,"bn.js":32,"inherits":279}],27:[function(require,module,exports){
'use strict';

const decoders = exports;
decoders.der = require("./der");
decoders.pem = require("./pem");

},{"./der":26,"./pem":28}],28:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const Buffer = require('safer-buffer').Buffer;

const DERDecoder = require("./der");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}

inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);
  const label = options.label.toUpperCase();
  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;

  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null) continue;
    if (match[2] !== label) continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN') break;
      start = i;
    } else {
      if (match[1] !== 'END') break;
      end = i;
      break;
    }
  }

  if (start === -1 || end === -1) throw new Error('PEM section not found for: ' + label);
  const base64 = lines.slice(start + 1, end).join(''); // Remove excessive symbols

  base64.replace(/[^a-z0-9+/=]+/gi, '');
  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":26,"inherits":279,"safer-buffer":447}],29:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const Buffer = require('safer-buffer').Buffer;

const Node = require("../base/node"); // Import DER constants


const der = require("../constants/der");

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity; // Construct base tree

  this.tree = new DERNode();

  this.tree._init(entity.body);
}

module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
}; // Tree methods


function DERNode(parent) {
  Node.call(this, 'der', parent);
}

inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter); // Short form

  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([header, content]);
  } // Long form
  // Count octets required to store length


  let lenOctets = 1;

  for (let i = content.length; i >= 0x100; i >>= 8) lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 0xff;

  return this._createEncoderBuffer([header, content]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);

    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }

    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');
    }

    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');
    }

    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values) return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);

    for (let i = 0; i < id.length; i++) id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();

    for (let i = 0; i < id.length; i++) id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  } // Count number of octets


  let size = 0;

  for (let i = 0; i < id.length; i++) {
    let ident = id[i];

    for (size++; ident >= 0x80; ident >>= 7) size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;

  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;

    while ((ident >>= 7) > 0) objid[offset--] = 0x80 | ident & 0x7f;
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10) return '0' + num;else return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else if (tag === 'utctime') {
    str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values) return this.reporter.error('String int or enum given, but no values map');

    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
    }

    num = values[num];
  } // Bignum, assume big endian


  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();

    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }

    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0) size++;
    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0) out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80) return this._createEncoderBuffer(num);
  if (num < 0x100) return this._createEncoderBuffer([0, num]);
  let size = 1;

  for (let i = num; i >= 0x100; i >>= 8) size++;

  const out = new Array(size);

  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }

  if (out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null) return false;
  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
  if (data.length !== state.defaultBuffer.length) return false;

  for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;

  return true;
}; // Utility methods


function encodeTag(tag, primitive, cls, reporter) {
  let res;
  if (tag === 'seqof') tag = 'seq';else if (tag === 'setof') tag = 'set';
  if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;else return reporter.error('Unknown tag: ' + tag);
  if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported');
  if (!primitive) res |= 0x20;
  res |= der.tagClassByName[cls || 'universal'] << 6;
  return res;
}

},{"../base/node":22,"../constants/der":24,"inherits":279,"safer-buffer":447}],30:[function(require,module,exports){
'use strict';

const encoders = exports;
encoders.der = require("./der");
encoders.pem = require("./pem");

},{"./der":29,"./pem":31}],31:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const DEREncoder = require("./der");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}

inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);
  const p = buf.toString('base64');
  const out = ['-----BEGIN ' + options.label + '-----'];

  for (let i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));

  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":29,"inherits":279}],32:[function(require,module,exports){
(function (module, exports) {
  'use strict'; // Utils

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  } // Could use `inherits` module, but don't want to move from single file
  // architecture yet.


  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function () {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  } // BN


  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0; // Reduction context

    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }

  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;

  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {}

  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }

    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;

    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);

        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }

    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }

    if (endian !== 'le') return; // Reverse the bytes

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');

    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;

    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }

    return this.strip();
  };

  function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index); // 'A' - 'F'

    if (c >= 65 && c <= 70) {
      return c - 55; // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87; // '0' - '9'
    } else {
      return c - 48 & 0xf;
    }
  }

  function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);

    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }

    return r;
  }

  BN.prototype._parseHex = function _parseHex(number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    } // 24-bits chunks


    var off = 0;
    var j = 0;
    var w;

    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;

      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase(str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul; // 'a'

      if (c >= 49) {
        r += c - 49 + 0xa; // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa; // '0' - '9'
      } else {
        r += c;
      }
    }

    return r;
  }

  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1; // Find length of limb in base

    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }

    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;

    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }

    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }

    return this;
  }; // Remove leading `0` from `this`


  BN.prototype.strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }

    return this._normSign();
  };

  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }

    return this;
  };

  BN.prototype.inspect = function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };
  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */


  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;

    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;

      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;

        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }

        off += 2;

        if (off >= 26) {
          off -= 26;
          i--;
        }
      }

      if (carry !== 0) {
        out = carry.toString(16) + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;

      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }

      if (this.isZero()) {
        out = '0' + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];

    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }

    return this.negative !== 0 ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON() {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer(endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);
    var b, i;
    var q = this.clone();

    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;

      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }

      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }

      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }

      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }

      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;

    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }

    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }

    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }

    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }

    if ((t & 0x1) === 0) {
      r++;
    }

    return r;
  }; // Return number of used bits in a BN


  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];

    var hi = this._countBits(w);

    return (this.length - 1) * 26 + hi;
  };

  function toBitArray(num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
    }

    return w;
  } // Number of trailing zero bits


  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;

    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);

      r += b;
      if (b !== 26) break;
    }

    return r;
  };

  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }

    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }

    return this.clone();
  };

  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  }; // Return negative clone of `this`


  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  }; // Or `num` with `this` in-place


  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  }; // Or `num` with `this`


  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  }; // And `num` with `this` in-place


  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;

    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;
    return this.strip();
  };

  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  }; // And `num` with `this`


  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  }; // Xor `num` with `this` in-place


  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;
    return this.strip();
  };

  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  }; // Xor `num` with `this`


  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  }; // Not ``this`` with ``width`` bitwidth


  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26; // Extend the buffer with leading zeroes

    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    } // Handle complete words


    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    } // Handle the residue


    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    } // And remove leading zeroes


    return this.strip();
  };

  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  }; // Set `bit` of `this`


  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  }; // Add `num` to `this` in-place


  BN.prototype.iadd = function iadd(num) {
    var r; // negative + positive

    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign(); // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    } // a.length > b.length


    var a, b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++; // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  }; // Add `num` to `this`


  BN.prototype.add = function add(num) {
    var res;

    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  }; // Subtract `num` from `this` in-place


  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign(); // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    } // At this point both numbers are positive


    var cmp = this.cmp(num); // Optimization - zeroify

    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    } // a > b


    var a, b;

    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    } // Copy rest of the words


    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  }; // Subtract `num` from `this`


  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };

  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }

      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }

    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  } // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).


  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */

    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */

    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */

    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */

    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */

    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */

    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */

    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */

    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */

    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */

    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */

    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */

    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */

    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */

    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */

    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */

    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */

    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */

    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */

    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;

    if (c !== 0) {
      o[19] = c;
      out.length++;
    }

    return out;
  }; // Polyfill comb


  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;

    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }

      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }

    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo(self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;

    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  }; // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion


  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;

    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  }; // Returns binary-reversed representation of `x`


  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;

    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }

    return rb;
  }; // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm


  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;
          /* jshint maxdepth : false */

          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;

    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;

    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;

    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    } // Pad with zeroes


    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);

    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  }; // Multiply `this` by `num`


  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  }; // Multiply employing FFT


  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  }; // In-place Multiplication


  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000); // Carry

    var carry = 0;

    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  }; // `this` * `this`


  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  }; // `this` * `this` in-place


  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  }; // Math.pow(`this`, `num`)


  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1); // Skip leading zeroes

    var res = this;

    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }

    return res;
  }; // Shift-left in-place


  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  }; // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits


  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;

    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h); // Extended mode, copy masked part

    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }

      maskedWords.length = s;
    }

    if (s === 0) {// No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;

      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;

    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    } // Push carried bits as a mask


    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  }; // Shift-left


  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  }; // Shift-right


  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  }; // Test if n bit is set


  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) return false; // Check bit and return

    var w = this.words[s];
    return !!(w & q);
  }; // Return only lowers bits of number (in-place)


  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }

    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  }; // Return only lowers bits of number


  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  }; // Add plain number `num` to `this`


  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num); // Possible sign change

    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    } // Add without checks


    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num; // Carry

    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;

      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }

    this.length = Math.max(this.length, i + 1);
    return this;
  }; // Subtract plain number `num` from `this`


  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };

  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;

    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip(); // Subtraction overflow

    assert(carry === -1);
    carry = 0;

    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;
    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num; // Normalize

    var bhi = b.words[b.length - 1] | 0;

    var bhiBits = this._countBits(bhi);

    shift = 26 - bhiBits;

    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    } // Initialize quotient


    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);

    if (diff.negative === 0) {
      a = diff;

      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)

      qj = Math.min(qj / bhi | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj--;
        a.negative = 0;

        a._ishlnsubmul(b, 1, j);

        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }

      if (q) {
        q.words[j] = qj;
      }
    }

    if (q) {
      q.strip();
    }

    a.strip(); // Denormalize

    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested


  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;

    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    } // Both numbers are positive at this point
    // Strip both numbers to approximate shift value


    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    } // Very short reduction


    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  }; // Find `this` / `num`


  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  }; // Find `this` % `num`


  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  }; // Find Round(`this` / `num`)


  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num); // Fast case - exact division

    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half); // Round down

    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn(num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  }; // In-place division by number


  BN.prototype.idivn = function idivn(num) {
    assert(num <= 0x3ffffff);
    var carry = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    } // A * x + B * y = x


    var A = new BN(1);
    var B = new BN(0); // C * x + D * y = y

    var C = new BN(0);
    var D = new BN(1);
    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        x.iushrn(i);

        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        y.iushrn(j);

        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  }; // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed


  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        a.iushrn(i);

        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        b.iushrn(j);

        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;

    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0; // Remove common factor of two

    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }

      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);

      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  }; // Invert number in the field F(num)


  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  }; // And first word and num


  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  }; // Increment at the bit position in-line


  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) {
      this._expand(s + 1);

      this.words[s] |= q;
      return this;
    } // Add bit and propagate, if needed


    var carry = q;

    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this.strip();
    var res;

    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }

    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`


  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Unsigned comparison


  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;

      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }

      break;
    }

    return res;
  };

  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  }; //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //


  BN.red = function red(num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');

    this.red._verify1(this);

    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');

    this.red._verify1(this);

    return this.red.isqr(this);
  }; // Square root over p


  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');

    this.red._verify1(this);

    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');

    this.red._verify1(this);

    return this.red.invm(this);
  }; // Return negative clone of `this` % `red modulo`


  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');

    this.red._verify1(this);

    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');

    this.red._verify1(this);

    return this.red.pow(this, num);
  }; // Prime numbers with efficient reduction


  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  }; // Pseudo-Mersenne prime

  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };

  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }

  inherits(K256, MPrime);

  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);

    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }

    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    } // Shift by 9 limbs


    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }

    prev >>>= 22;
    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

    var lo = 0;

    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    } // Fast length reduction


    if (num.words[num.length - 1] === 0) {
      num.length--;

      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }

    return num;
  };

  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }

  inherits(P224, MPrime);

  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }

  inherits(P192, MPrime);

  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }

  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;

    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }

    if (carry !== 0) {
      num.words[num.length++] = carry;
    }

    return num;
  }; // Exported mostly for testing purposes, use plain name instead


  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;

    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }

    primes[name] = prime;
    return prime;
  }; //
  // Base reduction engine
  //


  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);

      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };

  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);

    var res = a.add(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res;
  };

  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);

    var res = a.sub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);

    var res = a.isub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res;
  };

  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);

    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);

    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);

    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1); // Fast case

    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)


    var q = this.m.subn(1);
    var s = 0;

    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }

    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg(); // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.

    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;

    while (t.cmp(one) !== 0) {
      var tmp = t;

      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }

      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);

    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;

    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;

    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];

      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;

        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }

      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  }; //
  // Montgomery method engine
  //


  BN.mont = function mont(num) {
    return new Mont(num);
  };

  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();

    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }

  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":48}],33:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign'); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }

  return !!(b != null && b._isBuffer);
} // based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


var util = require("../util/util.js");

var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;

var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


var assert = module.exports = ok; // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}; // assert.AssertionError instanceof Error


util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}

assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
}; // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
}; // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
}; // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
}; // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
}; // Expose a strict only variant of assert


function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/util.js":579,"object-assign":357}],34:[function(require,module,exports){
module.exports = batcher;

function batcher(run) {
  var running = false;
  var pendingBatch = null;
  var pendingCallbacks = null;
  var callbacks = null;
  return append;

  function done(err) {
    if (callbacks) callAll(callbacks, err);
    running = false;
    callbacks = pendingCallbacks;
    var nextBatch = pendingBatch;
    pendingBatch = null;
    pendingCallbacks = null;

    if (!nextBatch || !nextBatch.length) {
      if (!callbacks || !callbacks.length) {
        callbacks = null;
        return;
      }

      if (!nextBatch) nextBatch = [];
    }

    running = true;
    run(nextBatch, done);
  }

  function append(val, cb) {
    if (running) {
      if (!pendingBatch) {
        pendingBatch = [];
        pendingCallbacks = [];
      }

      pushAll(pendingBatch, val);
      if (cb) pendingCallbacks.push(cb);
    } else {
      if (cb) callbacks = [cb];
      running = true;
      run(Array.isArray(val) ? val : [val], done);
    }
  }
}

function pushAll(list, val) {
  if (Array.isArray(val)) pushArray(list, val);else list.push(val);
}

function pushArray(list, val) {
  for (var i = 0; i < val.length; i++) list.push(val[i]);
}

function callAll(list, err) {
  for (var i = 0; i < list.length; i++) list[i](err);
}

},{}],35:[function(require,module,exports){
(function (global){(function (){
'use strict';

var filter = require('array-filter');

module.exports = function availableTypedArrays() {
  return filter(['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'], function (typedArray) {
    return typeof global[typedArray] === 'function';
  });
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"array-filter":15}],36:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],37:[function(require,module,exports){
var varint = require('varint');

var alloc = require('buffer-alloc-unsafe');

module.exports = align(1);

function align(n) {
  var exports = {};
  exports.align = align;
  exports.encode = encode;
  exports.encode.bytes = 0;
  exports.encodingLength = encodingLength;
  exports.decode = decode;
  exports.decode.bytes = 0;
  exports.decodingLength = decodingLength;
  return exports;

  function State(input, output, offset) {
    this.inputOffset = 0;
    this.inputLength = input.length;
    this.input = input;
    this.outputOffset = offset;
    this.output = output;
  }

  function encode(bitfield, buffer, offset) {
    if (!offset) offset = 0;
    if (!buffer) buffer = alloc(encodingLength(bitfield));
    var state = new State(bitfield, buffer, offset);
    rle(state);
    encode.bytes = state.outputOffset - offset;
    return buffer;
  }

  function encodingLength(bitfield) {
    var state = new State(bitfield, null, 0);
    rle(state);
    return state.outputOffset;
  }

  function decode(buffer, offset) {
    if (!offset) offset = 0;
    var bitfield = alloc(decodingLength(buffer, offset));
    var ptr = 0;

    while (offset < buffer.length) {
      var next = varint.decode(buffer, offset);
      var repeat = next & 1;
      var len = repeat ? (next - (next & 3)) / 4 : next / 2;
      offset += varint.decode.bytes;

      if (repeat) {
        bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len);
      } else {
        buffer.copy(bitfield, ptr, offset, offset + len);
        offset += len;
      }

      ptr += len;
    }

    bitfield.fill(0, ptr);
    decode.bytes = buffer.length - offset;
    return bitfield;
  }

  function decodingLength(buffer, offset) {
    if (!offset) offset = 0;
    var len = 0;

    while (offset < buffer.length) {
      var next = varint.decode(buffer, offset);
      offset += varint.decode.bytes;
      var repeat = next & 1;
      var slice = repeat ? (next - (next & 3)) / 4 : next / 2;
      len += slice;
      if (!repeat) offset += slice;
    }

    if (offset > buffer.length) throw new Error('Invalid RLE bitfield');
    if (len & n - 1) return len + (n - (len & n - 1));
    return len;
  }

  function rle(state) {
    var len = 0;
    var bits = 0;
    var input = state.input;

    while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--;

    for (var i = 0; i < state.inputLength; i++) {
      if (input[i] === bits) {
        len++;
        continue;
      }

      if (len) encodeUpdate(state, i, len, bits);

      if (input[i] === 0 || input[i] === 255) {
        bits = input[i];
        len = 1;
      } else {
        len = 0;
      }
    }

    if (len) encodeUpdate(state, state.inputLength, len, bits);
    encodeFinal(state);
  }

  function encodeHead(state, end) {
    var headLength = end - state.inputOffset;
    varint.encode(2 * headLength, state.output, state.outputOffset);
    state.outputOffset += varint.encode.bytes;
    state.input.copy(state.output, state.outputOffset, state.inputOffset, end);
    state.outputOffset += headLength;
  }

  function encodeFinal(state) {
    var headLength = state.inputLength - state.inputOffset;
    if (!headLength) return;

    if (!state.output) {
      state.outputOffset += headLength + varint.encodingLength(2 * headLength);
    } else {
      encodeHead(state, state.inputLength);
    }

    state.inputOffset = state.inputLength;
  }

  function encodeUpdate(state, i, len, bit) {
    var headLength = i - len - state.inputOffset;
    var headCost = headLength ? varint.encodingLength(2 * headLength) + headLength : 0;
    var enc = 4 * len + (bit ? 2 : 0) + 1; // len << 2 | bit << 1 | 1

    var encCost = headCost + varint.encodingLength(enc);
    var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset;
    if (encCost >= baseCost) return;

    if (!state.output) {
      state.outputOffset += encCost;
      state.inputOffset = i;
      return;
    }

    if (headLength) encodeHead(state, i - len);
    varint.encode(enc, state.output, state.outputOffset);
    state.outputOffset += varint.encode.bytes;
    state.inputOffset = i;
  }
}

},{"buffer-alloc-unsafe":92,"varint":40}],38:[function(require,module,exports){
module.exports = read;
var MSB = 0x80,
    REST = 0x7F;

function read(buf, offset) {
  var res = 0,
      offset = offset || 0,
      shift = 0,
      counter = offset,
      b,
      l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      read.bytesRead = 0; // DEPRECATED

      return undefined;
    }

    b = buf[counter++];
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);

  read.bytes = counter - offset;
  return res;
}

},{}],39:[function(require,module,exports){
module.exports = encode;
var MSB = 0x80,
    REST = 0x7F,
    MSBALL = ~REST,
    INT = Math.pow(2, 31);

function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;

  while (num >= INT) {
    out[offset++] = num & 0xFF | MSB;
    num /= 128;
  }

  while (num & MSBALL) {
    out[offset++] = num & 0xFF | MSB;
    num >>>= 7;
  }

  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}

},{}],40:[function(require,module,exports){
module.exports = {
  encode: require("./encode.js"),
  decode: require("./decode.js"),
  encodingLength: require("./length.js")
};

},{"./decode.js":38,"./encode.js":39,"./length.js":41}],41:[function(require,module,exports){
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);

module.exports = function (value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};

},{}],42:[function(require,module,exports){
const blake2b = require('blake2b');

module.exports = function (out, data, key) {
  blake2b(out.length, key).update(data).digest(out);
};

module.exports.batch = function (out, batch, key) {
  const b = blake2b(out.length, key);

  for (let i = 0; i < batch.length; i++) b.update(batch[i]);

  b.digest(out);
};

},{"blake2b":45}],43:[function(require,module,exports){
module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new (require('buf' + 'fer').Buffer)(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

},{}],44:[function(require,module,exports){
var assert = require('nanoassert');

var wasm = require("./blake2b")();

var head = 64;
var freeList = [];
module.exports = Blake2b;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;

function Blake2b(digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');
  if (!digestLength) digestLength = 32;

  if (noAssert !== true) {
    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);
    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }

  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();
  wasm.memory.fill(0, 0, 64);
  wasm.memory[0] = this.digestLength;
  wasm.memory[1] = key ? key.length : 0;
  wasm.memory[2] = 1; // fanout

  wasm.memory[3] = 1; // depth

  if (salt) wasm.memory.set(salt, 32);
  if (personal) wasm.memory.set(personal, 48);
  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state

  wasm.exports.blake2b_init(this.pointer, this.digestLength);

  if (key) {
    this.update(key);
    wasm.memory.fill(0, head, head + key.length); // whiteout key

    wasm.memory[this.pointer + 200] = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(this.finalized === false, 'Hash instance finalized');
  assert(input, 'input must be TypedArray or Buffer');
  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.set(input, head);
  wasm.exports.blake2b_update(this.pointer, head, head + input.length);
  return this;
};

Blake2b.prototype.digest = function (enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  wasm.exports.blake2b_final(this.pointer);

  if (!enc || enc === 'binary') {
    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  }

  if (enc === 'hex') {
    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
  }

  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer');

  for (var i = 0; i < this.digestLength; i++) {
    enc[i] = wasm.memory[this.pointer + 128 + i];
  }

  return enc;
}; // libsodium compat


Blake2b.prototype.final = Blake2b.prototype.digest;
Blake2b.WASM = wasm && wasm.buffer;
Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined';

Blake2b.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported')); // backwards compat, can be removed in a new major

  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve();else reject();
      cb(err);
    });
  });
  return p;
};

Blake2b.prototype.ready = Blake2b.ready;

function noop() {}

function hexSlice(buf, start, len) {
  var str = '';

  for (var i = 0; i < len; i++) str += toHex(buf[start + i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

},{"./blake2b":43,"nanoassert":319}],45:[function(require,module,exports){
var assert = require('nanoassert');

var b2wasm = require('blake2b-wasm'); // 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array


function ADD64AA(v, a, b) {
  var o0 = v[a] + v[b];
  var o1 = v[a + 1] + v[b + 1];

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits


function ADD64AC(v, a, b0, b1) {
  var o0 = v[a] + b0;

  if (b0 < 0) {
    o0 += 0x100000000;
  }

  var o1 = v[a + 1] + b1;

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // Little-endian byte access


function B2B_GET32(arr, i) {
  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
} // G Mixing function
// The ROTRs are inlined for speed


function B2B_G(a, b, c, d, ix, iy) {
  var x0 = m[ix];
  var x1 = m[ix + 1];
  var y0 = m[iy];
  var y1 = m[iy + 1];
  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s

  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits

  var xor0 = v[d] ^ v[a];
  var xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor0 >>> 24 ^ xor1 << 8;
  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v, a, b);
  ADD64AC(v, a, y0, y1); // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits

  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor0 >>> 16 ^ xor1 << 16;
  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor1 >>> 31 ^ xor0 << 1;
  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
} // Initialization Vector


var BLAKE2B_IV32 = new Uint32Array([0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85, 0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A, 0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C, 0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19]);
var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; // These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s

var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
  return x * 2;
})); // Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s

var v = new Uint32Array(32);
var m = new Uint32Array(32);

function blake2bCompress(ctx, last) {
  var i = 0; // init work variables

  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i];
    v[i + 16] = BLAKE2B_IV32[i];
  } // low 64 bits of offset


  v[24] = v[24] ^ ctx.t;
  v[25] = v[25] ^ ctx.t / 0x100000000; // high 64 bits not supported, offset may not be higher than 2**53-1
  // last block flag set ?

  if (last) {
    v[28] = ~v[28];
    v[29] = ~v[29];
  } // get little-endian words


  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i);
  } // twelve rounds of mixing


  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
  }
} // reusable parameter_block


var parameter_block = new Uint8Array([0, 0, 0, 0, //  0: outlen, keylen, fanout, depth
0, 0, 0, 0, //  4: leaf length, sequential mode
0, 0, 0, 0, //  8: node offset
0, 0, 0, 0, // 12: node offset
0, 0, 0, 0, // 16: node depth, inner length, rfu
0, 0, 0, 0, // 20: rfu
0, 0, 0, 0, // 24: rfu
0, 0, 0, 0, // 28: rfu
0, 0, 0, 0, // 32: salt
0, 0, 0, 0, // 36: salt
0, 0, 0, 0, // 40: salt
0, 0, 0, 0, // 44: salt
0, 0, 0, 0, // 48: personal
0, 0, 0, 0, // 52: personal
0, 0, 0, 0, // 56: personal
0, 0, 0, 0 // 60: personal
]); // Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key

function Blake2b(outlen, key, salt, personal) {
  // zero out parameter_block before usage
  parameter_block.fill(0); // state, 'param block'

  this.b = new Uint8Array(128);
  this.h = new Uint32Array(16);
  this.t = 0; // input count

  this.c = 0; // pointer within buffer

  this.outlen = outlen; // output length in bytes

  parameter_block[0] = outlen;
  if (key) parameter_block[1] = key.length;
  parameter_block[2] = 1; // fanout

  parameter_block[3] = 1; // depth

  if (salt) parameter_block.set(salt, 32);
  if (personal) parameter_block.set(personal, 48); // initialize hash state

  for (var i = 0; i < 16; i++) {
    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
  } // key the hash, if applicable


  if (key) {
    blake2bUpdate(this, key); // at the end

    this.c = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(input != null, 'input must be Uint8Array or Buffer');
  blake2bUpdate(this, input);
  return this;
};

Blake2b.prototype.digest = function (out) {
  var buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out;
  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
  blake2bFinal(this, buf);
  if (out === 'hex') return hexSlice(buf);
  return buf;
};

Blake2b.prototype.final = Blake2b.prototype.digest;

Blake2b.ready = function (cb) {
  b2wasm.ready(function () {
    cb(); // ignore the error
  });
}; // Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)


function blake2bUpdate(ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c; // add counters

      blake2bCompress(ctx, false); // compress (not last)

      ctx.c = 0; // counter to zero
    }

    ctx.b[ctx.c++] = input[i];
  }
} // Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest


function blake2bFinal(ctx, out) {
  ctx.t += ctx.c; // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0;
  }

  blake2bCompress(ctx, true); // final block flag = 1

  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
  }

  return out;
}

function hexSlice(buf) {
  var str = '';

  for (var i = 0; i < buf.length; i++) str += toHex(buf[i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

var Proto = Blake2b;

module.exports = function createHash(outlen, key, salt, personal, noAssert) {
  if (noAssert !== true) {
    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  return new Proto(outlen, key, salt, personal);
};

module.exports.ready = function (cb) {
  b2wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
b2wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    Proto = b2wasm;
  }
});

},{"blake2b-wasm":44,"nanoassert":319}],46:[function(require,module,exports){
(function (module, exports) {
  'use strict'; // Utils

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  } // Could use `inherits` module, but don't want to move from single file
  // architecture yet.


  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function () {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  } // BN


  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0; // Reduction context

    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }

  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;

  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {}

  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }

    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;

    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);

        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }

    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }

    if (endian !== 'le') return; // Reverse the bytes

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');

    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;

    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }

    return this._strip();
  };

  function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index); // '0' - '9'

    if (c >= 48 && c <= 57) {
      return c - 48; // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55; // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);

    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }

    return r;
  }

  BN.prototype._parseHex = function _parseHex(number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    } // 24-bits chunks


    var off = 0;
    var j = 0;
    var w;

    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;

      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul; // 'a'

      if (c >= 49) {
        b = c - 49 + 0xa; // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa; // '0' - '9'
      } else {
        b = c;
      }

      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }

    return r;
  }

  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1; // Find length of limb in base

    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }

    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;

    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }

    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move(dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }

    return this;
  }; // Remove leading `0` from `this`


  BN.prototype._strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }

    return this._normSign();
  };

  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }

    return this;
  }; // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility


  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }
  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */


  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;

    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;

      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;

        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }

        off += 2;

        if (off >= 26) {
          off -= 26;
          i--;
        }
      }

      if (carry !== 0) {
        out = carry.toString(16) + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;

      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }

      if (this.isZero()) {
        out = '0' + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];

    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }

    return this.negative !== 0 ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }

    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = this.words[i] << shift | carry;
      res[position++] = word & 0xff;

      if (position < res.length) {
        res[position++] = word >> 8 & 0xff;
      }

      if (position < res.length) {
        res[position++] = word >> 16 & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = word >> 24 & 0xff;
        }

        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = this.words[i] << shift | carry;
      res[position--] = word & 0xff;

      if (position >= 0) {
        res[position--] = word >> 8 & 0xff;
      }

      if (position >= 0) {
        res[position--] = word >> 16 & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = word >> 24 & 0xff;
        }

        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;

      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }

      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }

      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }

      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }

      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;

    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }

    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }

    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }

    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }

    if ((t & 0x1) === 0) {
      r++;
    }

    return r;
  }; // Return number of used bits in a BN


  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];

    var hi = this._countBits(w);

    return (this.length - 1) * 26 + hi;
  };

  function toBitArray(num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = num.words[off] >>> wbit & 0x01;
    }

    return w;
  } // Number of trailing zero bits


  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;

    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);

      r += b;
      if (b !== 26) break;
    }

    return r;
  };

  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }

    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }

    return this.clone();
  };

  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  }; // Return negative clone of `this`


  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  }; // Or `num` with `this` in-place


  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  }; // Or `num` with `this`


  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  }; // And `num` with `this` in-place


  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;

    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;
    return this._strip();
  };

  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  }; // And `num` with `this`


  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  }; // Xor `num` with `this` in-place


  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;
    return this._strip();
  };

  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  }; // Xor `num` with `this`


  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  }; // Not ``this`` with ``width`` bitwidth


  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26; // Extend the buffer with leading zeroes

    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    } // Handle complete words


    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    } // Handle the residue


    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    } // And remove leading zeroes


    return this._strip();
  };

  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  }; // Set `bit` of `this`


  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  }; // Add `num` to `this` in-place


  BN.prototype.iadd = function iadd(num) {
    var r; // negative + positive

    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign(); // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    } // a.length > b.length


    var a, b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++; // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  }; // Add `num` to `this`


  BN.prototype.add = function add(num) {
    var res;

    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  }; // Subtract `num` from `this` in-place


  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign(); // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    } // At this point both numbers are positive


    var cmp = this.cmp(num); // Optimization - zeroify

    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    } // a > b


    var a, b;

    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    } // Copy rest of the words


    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  }; // Subtract `num` from `this`


  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };

  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }

      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }

    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  } // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).


  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */

    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */

    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */

    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */

    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */

    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */

    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */

    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */

    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */

    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */

    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */

    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */

    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */

    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */

    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */

    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */

    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */

    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */

    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */

    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;

    if (c !== 0) {
      o[19] = c;
      out.length++;
    }

    return out;
  }; // Polyfill comb


  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;

    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }

      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }

    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo(self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;

    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  }; // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion


  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;

    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  }; // Returns binary-reversed representation of `x`


  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;

    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }

    return rb;
  }; // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm


  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;
          /* jshint maxdepth : false */

          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;

    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;

    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;

    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    } // Pad with zeroes


    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);

    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  }; // Multiply `this` by `num`


  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  }; // Multiply employing FFT


  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  }; // In-place Multiplication


  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(typeof num === 'number');
    assert(num < 0x4000000); // Carry

    var carry = 0;

    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  }; // `this` * `this`


  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  }; // `this` * `this` in-place


  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  }; // Math.pow(`this`, `num`)


  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1); // Skip leading zeroes

    var res = this;

    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }

    return res;
  }; // Shift-left in-place


  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  }; // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits


  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;

    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h); // Extended mode, copy masked part

    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }

      maskedWords.length = s;
    }

    if (s === 0) {// No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;

      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;

    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    } // Push carried bits as a mask


    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  }; // Shift-left


  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  }; // Shift-right


  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  }; // Test if n bit is set


  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) return false; // Check bit and return

    var w = this.words[s];
    return !!(w & q);
  }; // Return only lowers bits of number (in-place)


  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }

    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  }; // Return only lowers bits of number


  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  }; // Add plain number `num` to `this`


  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num); // Possible sign change

    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    } // Add without checks


    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num; // Carry

    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;

      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }

    this.length = Math.max(this.length, i + 1);
    return this;
  }; // Subtract plain number `num` from `this`


  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };

  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;

    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip(); // Subtraction overflow

    assert(carry === -1);
    carry = 0;

    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;
    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num; // Normalize

    var bhi = b.words[b.length - 1] | 0;

    var bhiBits = this._countBits(bhi);

    shift = 26 - bhiBits;

    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    } // Initialize quotient


    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);

    if (diff.negative === 0) {
      a = diff;

      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)

      qj = Math.min(qj / bhi | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj--;
        a.negative = 0;

        a._ishlnsubmul(b, 1, j);

        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }

      if (q) {
        q.words[j] = qj;
      }
    }

    if (q) {
      q._strip();
    }

    a._strip(); // Denormalize


    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested


  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;

    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    } // Both numbers are positive at this point
    // Strip both numbers to approximate shift value


    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    } // Very short reduction


    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  }; // Find `this` / `num`


  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  }; // Find `this` % `num`


  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  }; // Find Round(`this` / `num`)


  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num); // Fast case - exact division

    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half); // Round down

    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  }; // WARNING: DEPRECATED


  BN.prototype.modn = function modn(num) {
    return this.modrn(num);
  }; // In-place division by number


  BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(num <= 0x3ffffff);
    var carry = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }

    this._strip();

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    } // A * x + B * y = x


    var A = new BN(1);
    var B = new BN(0); // C * x + D * y = y

    var C = new BN(0);
    var D = new BN(1);
    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        x.iushrn(i);

        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        y.iushrn(j);

        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  }; // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed


  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        a.iushrn(i);

        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        b.iushrn(j);

        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;

    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0; // Remove common factor of two

    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }

      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);

      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  }; // Invert number in the field F(num)


  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  }; // And first word and num


  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  }; // Increment at the bit position in-line


  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) {
      this._expand(s + 1);

      this.words[s] |= q;
      return this;
    } // Add bit and propagate, if needed


    var carry = q;

    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;

    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }

    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`


  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Unsigned comparison


  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;

      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }

      break;
    }

    return res;
  };

  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  }; //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //


  BN.red = function red(num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');

    this.red._verify1(this);

    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');

    this.red._verify1(this);

    return this.red.isqr(this);
  }; // Square root over p


  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');

    this.red._verify1(this);

    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');

    this.red._verify1(this);

    return this.red.invm(this);
  }; // Return negative clone of `this` % `red modulo`


  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');

    this.red._verify1(this);

    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');

    this.red._verify1(this);

    return this.red.pow(this, num);
  }; // Prime numbers with efficient reduction


  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  }; // Pseudo-Mersenne prime

  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };

  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }

  inherits(K256, MPrime);

  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);

    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }

    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    } // Shift by 9 limbs


    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }

    prev >>>= 22;
    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

    var lo = 0;

    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    } // Fast length reduction


    if (num.words[num.length - 1] === 0) {
      num.length--;

      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }

    return num;
  };

  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }

  inherits(P224, MPrime);

  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }

  inherits(P192, MPrime);

  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }

  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;

    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }

    if (carry !== 0) {
      num.words[num.length++] = carry;
    }

    return num;
  }; // Exported mostly for testing purposes, use plain name instead


  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;

    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }

    primes[name] = prime;
    return prime;
  }; //
  // Base reduction engine
  //


  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);

      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };

  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);

    var res = a.add(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res;
  };

  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);

    var res = a.sub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);

    var res = a.isub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res;
  };

  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);

    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);

    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);

    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1); // Fast case

    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)


    var q = this.m.subn(1);
    var s = 0;

    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }

    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg(); // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.

    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;

    while (t.cmp(one) !== 0) {
      var tmp = t;

      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }

      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);

    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;

    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;

    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];

      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;

        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }

      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  }; //
  // Montgomery method engine
  //


  BN.mont = function mont(num) {
    return new Mont(num);
  };

  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();

    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }

  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":48}],47:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r) r = new Rand(null);
  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}

module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
}; // Emulate crypto API using randy


Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes) return this.rand.getBytes(n);
  var res = new Uint8Array(n);

  for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();

  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    }; // Safari's WebWorkers do not have `crypto`

  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function () {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');

    if (typeof crypto.randomBytes !== 'function') throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {}
}

},{"crypto":48}],48:[function(require,module,exports){

},{}],49:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/
var Buffer = require('safe-buffer').Buffer;

function asUInt32Array(buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }

  return out;
}

function scrubVec(v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0;
  }
}

function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s0 = M[0] ^ keySchedule[0];
  var s1 = M[1] ^ keySchedule[1];
  var s2 = M[2] ^ keySchedule[2];
  var s3 = M[3] ^ keySchedule[3];
  var t0, t1, t2, t3;
  var ksRow = 4;

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }

  t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
  t0 = t0 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t0, t1, t2, t3];
} // AES constants


var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

var G = function () {
  // Compute double table
  var d = new Array(256);

  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1;
    } else {
      d[j] = j << 1 ^ 0x11b;
    }
  }

  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []]; // Walk GF(2^8)

  var x = 0;
  var xi = 0;

  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
    SBOX[x] = sx;
    INV_SBOX[sx] = x; // Compute multiplication

    var x2 = d[x];
    var x4 = d[x2];
    var x8 = d[x4]; // Compute sub bytes, mix columns tables

    var t = d[sx] * 0x101 ^ sx * 0x1010100;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t; // Compute inv sub bytes, inv mix columns tables

    t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;

    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  };
}();

function AES(key) {
  this._key = asUInt32Array(key);

  this._reset();
}

AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;

AES.prototype._reset = function () {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];

  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k];
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1];

    if (k % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
      t ^= RCON[k / keySize | 0] << 24;
    } else if (keySize > 6 && k % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t;
  }

  var invKeySchedule = [];

  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
    }
  }

  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M);
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M); // swap

  var m1 = M[1];
  M[1] = M[3];
  M[3] = m1;
  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};

module.exports.AES = AES;

},{"safe-buffer":446}],50:[function(require,module,exports){
var aes = require("./aes");

var Buffer = require('safe-buffer').Buffer;

var Transform = require('cipher-base');

var inherits = require('inherits');

var GHASH = require("./ghash");

var xor = require('buffer-xor');

var incr32 = require("./incr32");

function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length) out++;
  var len = Math.min(a.length, b.length);

  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b[i];
  }

  return out;
}

function calcIv(self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
  }

  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);

  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer.alloc(toPad, 0));
  }

  ghash.update(Buffer.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer.alloc(8);
  tail.writeUIntBE(ivBits, 0, 8);
  ghash.update(tail);
  self._finID = ghash.state;
  var out = Buffer.from(self._finID);
  incr32(out);
  return out;
}

function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  var h = Buffer.alloc(4, 0);
  this._cipher = new aes.AES(key);

  var ck = this._cipher.encryptBlock(h);

  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}

inherits(StreamCipher, Transform);

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;

    if (rump < 16) {
      rump = Buffer.alloc(rump, 0);

      this._ghash.update(rump);
    }
  }

  this._called = true;

  var out = this._mode.encrypt(this, chunk);

  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }

  this._len += chunk.length;
  return out;
};

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data');
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data');
  this._authTag = tag;

  this._cipher.scrub();
};

StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state');
  return this._authTag;
};

StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');
  this._authTag = tag;
};

StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state');

  this._ghash.update(buf);

  this._alen += buf.length;
};

module.exports = StreamCipher;

},{"./aes":49,"./ghash":54,"./incr32":55,"buffer-xor":96,"cipher-base":116,"inherits":279,"safe-buffer":446}],51:[function(require,module,exports){
var ciphers = require("./encrypter");

var deciphers = require("./decrypter");

var modes = require("./modes/list.json");

function getCiphers() {
  return Object.keys(modes);
}

exports.createCipher = exports.Cipher = ciphers.createCipher;
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
exports.createDecipher = exports.Decipher = deciphers.createDecipher;
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"./decrypter":52,"./encrypter":53,"./modes/list.json":63}],52:[function(require,module,exports){
var AuthCipher = require("./authCipher");

var Buffer = require('safe-buffer').Buffer;

var MODES = require("./modes");

var StreamCipher = require("./streamCipher");

var Transform = require('cipher-base');

var aes = require("./aes");

var ebtk = require('evp_bytestokey');

var inherits = require('inherits');

function Decipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._last = void 0;
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}

inherits(Decipher, Transform);

Decipher.prototype._update = function (data) {
  this._cache.add(data);

  var chunk;
  var thing;
  var out = [];

  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }

  return Buffer.concat(out);
};

Decipher.prototype._final = function () {
  var chunk = this._cache.flush();

  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error('data not multiple of block length');
  }
};

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};

function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function (autoPadding) {
  var out;

  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }

  return null;
};

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache;
};

function unpad(last) {
  var padded = last[15];

  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data');
  }

  var i = -1;

  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error('unable to decrypt data');
    }
  }

  if (padded === 16) return;
  return last.slice(0, 16 - padded);
}

function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true);
  }

  return new Decipher(config.module, password, iv);
}

function createDecipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createDecipheriv(suite, keys.key, keys.iv);
}

exports.createDecipher = createDecipher;
exports.createDecipheriv = createDecipheriv;

},{"./aes":49,"./authCipher":50,"./modes":62,"./streamCipher":65,"cipher-base":116,"evp_bytestokey":173,"inherits":279,"safe-buffer":446}],53:[function(require,module,exports){
var MODES = require("./modes");

var AuthCipher = require("./authCipher");

var Buffer = require('safe-buffer').Buffer;

var StreamCipher = require("./streamCipher");

var Transform = require('cipher-base');

var aes = require("./aes");

var ebtk = require('evp_bytestokey');

var inherits = require('inherits');

function Cipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}

inherits(Cipher, Transform);

Cipher.prototype._update = function (data) {
  this._cache.add(data);

  var chunk;
  var thing;
  var out = [];

  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }

  return Buffer.concat(out);
};

var PADDING = Buffer.alloc(16, 0x10);

Cipher.prototype._final = function () {
  var chunk = this._cache.flush();

  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);

    this._cipher.scrub();

    return chunk;
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();

    throw new Error('data not multiple of block length');
  }
};

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};

function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }

  return null;
};

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length;
  var padBuff = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }

  return Buffer.concat([this.cache, padBuff]);
};

function createCipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv);
  }

  return new Cipher(config.module, password, iv);
}

function createCipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createCipheriv(suite, keys.key, keys.iv);
}

exports.createCipheriv = createCipheriv;
exports.createCipher = createCipher;

},{"./aes":49,"./authCipher":50,"./modes":62,"./streamCipher":65,"cipher-base":116,"evp_bytestokey":173,"inherits":279,"safe-buffer":446}],54:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

var ZEROES = Buffer.alloc(16, 0);

function toArray(buf) {
  return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
}

function fromArray(out) {
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}

function GHASH(key) {
  this.h = key;
  this.state = Buffer.alloc(16, 0);
  this.cache = Buffer.allocUnsafe(0);
} // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho VÃ¤hÃ¤-Herttua


GHASH.prototype.ghash = function (block) {
  var i = -1;

  while (++i < block.length) {
    this.state[i] ^= block[i];
  }

  this._multiply();
};

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h);
  var Zi = [0, 0, 0, 0];
  var j, xi, lsbVi;
  var i = -1;

  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;

    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0];
      Zi[1] ^= Vi[1];
      Zi[2] ^= Vi[2];
      Zi[3] ^= Vi[3];
    } // Store the value of LSB(V_i)


    lsbVi = (Vi[3] & 1) !== 0; // V_i+1 = V_i >> 1

    for (j = 3; j > 0; j--) {
      Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
    }

    Vi[0] = Vi[0] >>> 1; // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R

    if (lsbVi) {
      Vi[0] = Vi[0] ^ 0xe1 << 24;
    }
  }

  this.state = fromArray(Zi);
};

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf]);
  var chunk;

  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16));
  }

  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};

module.exports = GHASH;

},{"safe-buffer":446}],55:[function(require,module,exports){
function incr32(iv) {
  var len = iv.length;
  var item;

  while (len--) {
    item = iv.readUInt8(len);

    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}

module.exports = incr32;

},{}],56:[function(require,module,exports){
var xor = require('buffer-xor');

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev);
  self._prev = self._cipher.encryptBlock(data);
  return self._prev;
};

exports.decrypt = function (self, block) {
  var pad = self._prev;
  self._prev = block;

  var out = self._cipher.decryptBlock(block);

  return xor(out, pad);
};

},{"buffer-xor":96}],57:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

var xor = require('buffer-xor');

function encryptStart(self, data, decrypt) {
  var len = data.length;
  var out = xor(data, self._cache);
  self._cache = self._cache.slice(len);
  self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
  return out;
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0);
  var len;

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev);
      self._prev = Buffer.allocUnsafe(0);
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length;
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
      data = data.slice(len);
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
      break;
    }
  }

  return out;
};

},{"buffer-xor":96,"safe-buffer":446}],58:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

function encryptByte(self, byteParam, decrypt) {
  var pad;
  var i = -1;
  var len = 8;
  var out = 0;
  var bit, value;

  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev);
    bit = byteParam & 1 << 7 - i ? 0x80 : 0;
    value = pad[0] ^ bit;
    out += (value & 0x80) >> i % 8;
    self._prev = shiftIn(self._prev, decrypt ? bit : value);
  }

  return out;
}

function shiftIn(buffer, value) {
  var len = buffer.length;
  var i = -1;
  var out = Buffer.allocUnsafe(buffer.length);
  buffer = Buffer.concat([buffer, Buffer.from([value])]);

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }

  return out;
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }

  return out;
};

},{"safe-buffer":446}],59:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

function encryptByte(self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev);

  var out = pad[0] ^ byteParam;
  self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
  return out;
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }

  return out;
};

},{"safe-buffer":446}],60:[function(require,module,exports){
var xor = require('buffer-xor');

var Buffer = require('safe-buffer').Buffer;

var incr32 = require("../incr32");

function getBlock(self) {
  var out = self._cipher.encryptBlockRaw(self._prev);

  incr32(self._prev);
  return out;
}

var blockSize = 16;

exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize);
  var start = self._cache.length;
  self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);

  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self);
    var offset = start + i * blockSize;

    self._cache.writeUInt32BE(out[0], offset + 0);

    self._cache.writeUInt32BE(out[1], offset + 4);

    self._cache.writeUInt32BE(out[2], offset + 8);

    self._cache.writeUInt32BE(out[3], offset + 12);
  }

  var pad = self._cache.slice(0, chunk.length);

  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};

},{"../incr32":55,"buffer-xor":96,"safe-buffer":446}],61:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block);
};

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block);
};

},{}],62:[function(require,module,exports){
var modeModules = {
  ECB: require("./ecb"),
  CBC: require("./cbc"),
  CFB: require("./cfb"),
  CFB8: require("./cfb8"),
  CFB1: require("./cfb1"),
  OFB: require("./ofb"),
  CTR: require("./ctr"),
  GCM: require("./ctr")
};

var modes = require("./list.json");

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode];
}

module.exports = modes;

},{"./cbc":56,"./cfb":57,"./cfb1":58,"./cfb8":59,"./ctr":60,"./ecb":61,"./list.json":63,"./ofb":64}],63:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],64:[function(require,module,exports){
(function (Buffer){(function (){
var xor = require('buffer-xor');

function getBlock(self) {
  self._prev = self._cipher.encryptBlock(self._prev);
  return self._prev;
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)]);
  }

  var pad = self._cache.slice(0, chunk.length);

  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"buffer-xor":96}],65:[function(require,module,exports){
var aes = require("./aes");

var Buffer = require('safe-buffer').Buffer;

var Transform = require('cipher-base');

var inherits = require('inherits');

function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._mode = mode;
}

inherits(StreamCipher, Transform);

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};

StreamCipher.prototype._final = function () {
  this._cipher.scrub();
};

module.exports = StreamCipher;

},{"./aes":49,"cipher-base":116,"inherits":279,"safe-buffer":446}],66:[function(require,module,exports){
var DES = require('browserify-des');

var aes = require('browserify-aes/browser');

var aesModes = require('browserify-aes/modes');

var desModes = require('browserify-des/modes');

var ebtk = require('evp_bytestokey');

function createCipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;

  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }

  var keys = ebtk(password, false, keyLen, ivLen);
  return createCipheriv(suite, keys.key, keys.iv);
}

function createDecipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;

  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }

  var keys = ebtk(password, false, keyLen, ivLen);
  return createDecipheriv(suite, keys.key, keys.iv);
}

function createCipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite
  });
  throw new TypeError('invalid suite type');
}

function createDecipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite,
    decrypt: true
  });
  throw new TypeError('invalid suite type');
}

function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}

exports.createCipher = exports.Cipher = createCipher;
exports.createCipheriv = exports.Cipheriv = createCipheriv;
exports.createDecipher = exports.Decipher = createDecipher;
exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"browserify-aes/browser":51,"browserify-aes/modes":62,"browserify-des":67,"browserify-des/modes":68,"evp_bytestokey":173}],67:[function(require,module,exports){
var CipherBase = require('cipher-base');

var des = require('des.js');

var inherits = require('inherits');

var Buffer = require('safe-buffer').Buffer;

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
};
modes.des = modes['des-cbc'];
modes.des3 = modes['des-ede3-cbc'];
module.exports = DES;
inherits(DES, CipherBase);

function DES(opts) {
  CipherBase.call(this);
  var modeName = opts.mode.toLowerCase();
  var mode = modes[modeName];
  var type;

  if (opts.decrypt) {
    type = 'decrypt';
  } else {
    type = 'encrypt';
  }

  var key = opts.key;

  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key);
  }

  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)]);
  }

  var iv = opts.iv;

  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv);
  }

  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  });
}

DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data));
};

DES.prototype._final = function () {
  return Buffer.from(this._des.final());
};

},{"cipher-base":116,"des.js":136,"inherits":279,"safe-buffer":446}],68:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
};
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
};
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
};
exports['des-ede3'] = {
  key: 24,
  iv: 0
};
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
};
exports['des-ede'] = {
  key: 16,
  iv: 0
};

},{}],69:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js');

var randomBytes = require('randombytes');

function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder: r.invm(priv.modulus)
  };
}

function getr(priv) {
  var len = priv.modulus.byteLength();
  var r;

  do {
    r = new BN(randomBytes(len));
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));

  return r;
}

function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(BN.mont(priv.prime1));
  var c2 = blinded.toRed(BN.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1).fromRed();
  var m2 = c2.redPow(priv.exponent2).fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len);
}

crt.getr = getr;
module.exports = crt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":46,"buffer":97,"randombytes":427}],70:[function(require,module,exports){
module.exports = require("./browser/algorithms.json");

},{"./browser/algorithms.json":71}],71:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],72:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],73:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

var createHash = require('create-hash');

var stream = require('readable-stream');

var inherits = require('inherits');

var sign = require("./sign");

var verify = require("./verify");

var algorithms = require("./algorithms.json");

Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});

function Sign(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) throw new Error('Unknown message digest');
  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}

inherits(Sign, stream.Writable);

Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);

  done();
};

Sign.prototype.update = function update(data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc);

  this._hash.update(data);

  return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
  this.end();

  var hash = this._hash.digest();

  var sig = sign(hash, key, this._hashType, this._signType, this._tag);
  return enc ? sig.toString(enc) : sig;
};

function Verify(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) throw new Error('Unknown message digest');
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}

inherits(Verify, stream.Writable);

Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);

  done();
};

Verify.prototype.update = function update(data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc);

  this._hash.update(data);

  return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc);
  this.end();

  var hash = this._hash.digest();

  return verify(sig, hash, key, this._signType, this._tag);
};

function createSign(algorithm) {
  return new Sign(algorithm);
}

function createVerify(algorithm) {
  return new Verify(algorithm);
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};

},{"./algorithms.json":71,"./sign":74,"./verify":75,"create-hash":124,"inherits":279,"readable-stream":90,"safe-buffer":446}],74:[function(require,module,exports){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;

var createHmac = require('create-hmac');

var crt = require('browserify-rsa');

var EC = require('elliptic').ec;

var BN = require('bn.js');

var parseKeys = require('parse-asn1');

var curves = require("./curves.json");

function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);

  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type');
    return dsaSign(hash, priv, hashType);
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
  }

  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];

  while (hash.length + pad.length + 1 < len) pad.push(0xff);

  pad.push(0x00);
  var i = -1;

  while (++i < hash.length) pad.push(hash[i]);

  var out = crt(pad, priv);
  return out;
}

function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'));
  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);
  return Buffer.from(out.toDER());
}

function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);

  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);

    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }

  return toDER(r, s);
}

function toDER(r, s) {
  r = r.toArray();
  s = s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r);
  if (s[0] & 0x80) s = [0].concat(s);
  var total = r.length + s.length + 4;
  var res = [0x30, total, 0x02, r.length];
  res = res.concat(r, [0x02, s.length], s);
  return Buffer.from(res);
}

function getKey(x, q, hash, algo) {
  x = Buffer.from(x.toArray());

  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length);
    x = Buffer.concat([zeros, x]);
  }

  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = Buffer.alloc(hlen);
  v.fill(1);
  var k = Buffer.alloc(hlen);
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return {
    k: k,
    v: v
  };
}

function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) bits.ishrn(shift);
  return bits;
}

function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = Buffer.from(bits.toArray());

  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length);
    out = Buffer.concat([zeros, out]);
  }

  return out;
}

function makeKey(q, kv, algo) {
  var t;
  var k;

  do {
    t = Buffer.alloc(0);

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }

    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);

  return k;
}

function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}

module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;

},{"./curves.json":72,"bn.js":46,"browserify-rsa":69,"create-hmac":126,"elliptic":149,"parse-asn1":370,"safe-buffer":446}],75:[function(require,module,exports){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;

var BN = require('bn.js');

var EC = require('elliptic').ec;

var parseKeys = require('parse-asn1');

var curves = require("./curves.json");

function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);

  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type');
    return dsaVerify(sig, hash, pub);
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
  }

  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;

  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum++;
  }

  pad.push(0x00);
  var i = -1;

  while (++i < hash.length) {
    pad.push(hash[i]);
  }

  pad = Buffer.from(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);
  sig = sig.redPow(new BN(pub.publicExponent));
  sig = Buffer.from(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) out = 1;
  i = -1;

  while (++i < len) out |= sig[i] ^ pad[i];

  return out === 0;
}

function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;
  return curve.verify(hash, sig, pubkey);
}

function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
  return v.cmp(r) === 0;
}

function checkValue(b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig');
  if (b.cmp(q) >= q) throw new Error('invalid sig');
}

module.exports = verify;

},{"./curves.json":72,"bn.js":46,"elliptic":149,"parse-asn1":370,"safe-buffer":446}],76:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],77:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require("./_stream_readable");

var Writable = require("./_stream_writable");

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":79,"./_stream_writable":81,"_process":380,"inherits":279}],78:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require("./_stream_transform");

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":80,"inherits":279}],79:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require("./internal/streams/stream");
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require("../../../../util/util.js");

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require("./internal/streams/buffer_list");

var destroyImpl = require("./internal/streams/destroy");

var _require = require("./internal/streams/state"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require("../errors").codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require("./_stream_duplex");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require("./internal/streams/async_iterator");
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require("./internal/streams/from");
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../util/util.js":579,"../errors":76,"./_stream_duplex":77,"./internal/streams/async_iterator":82,"./internal/streams/buffer_list":83,"./internal/streams/destroy":84,"./internal/streams/from":86,"./internal/streams/state":88,"./internal/streams/stream":89,"_process":380,"buffer":97,"events":172,"inherits":279,"string_decoder/":566}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require("../errors").codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require("./_stream_duplex");

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

},{"../errors":76,"./_stream_duplex":77,"inherits":279}],81:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require("./internal/streams/stream");
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require("./internal/streams/destroy");

var _require = require("./internal/streams/state"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require("../errors").codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require("./_stream_duplex");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require("./_stream_duplex"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":76,"./_stream_duplex":77,"./internal/streams/destroy":84,"./internal/streams/state":88,"./internal/streams/stream":89,"_process":380,"buffer":97,"inherits":279,"util-deprecate":576}],82:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require("./end-of-stream");

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":85,"_process":380}],83:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require("../../../../../../util/util.js"),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

},{"../../../../../../util/util.js":579,"buffer":97}],84:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

}).call(this)}).call(this,require('_process'))
},{"_process":380}],85:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

},{"../../../errors":76}],86:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

},{}],87:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require("../../../errors").codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require("./end-of-stream");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

},{"../../../errors":76,"./end-of-stream":85}],88:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require("../../../errors").codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

},{"../../../errors":76}],89:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":172}],90:[function(require,module,exports){
exports = module.exports = require("./lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require("./lib/_stream_writable.js");
exports.Duplex = require("./lib/_stream_duplex.js");
exports.Transform = require("./lib/_stream_transform.js");
exports.PassThrough = require("./lib/_stream_passthrough.js");
exports.finished = require("./lib/internal/streams/end-of-stream.js");
exports.pipeline = require("./lib/internal/streams/pipeline.js");

},{"./lib/_stream_duplex.js":77,"./lib/_stream_passthrough.js":78,"./lib/_stream_readable.js":79,"./lib/_stream_transform.js":80,"./lib/_stream_writable.js":81,"./lib/internal/streams/end-of-stream.js":85,"./lib/internal/streams/pipeline.js":87}],91:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48}],92:[function(require,module,exports){
(function (Buffer){(function (){
function allocUnsafe(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }

  if (Buffer.allocUnsafe) {
    return Buffer.allocUnsafe(size);
  } else {
    return new Buffer(size);
  }
}

module.exports = allocUnsafe;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],93:[function(require,module,exports){
(function (Buffer){(function (){
var bufferFill = require('buffer-fill');

var allocUnsafe = require('buffer-alloc-unsafe');

module.exports = function alloc(size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }

  if (Buffer.alloc) {
    return Buffer.alloc(size, fill, encoding);
  }

  var buffer = allocUnsafe(size);

  if (size === 0) {
    return buffer;
  }

  if (fill === undefined) {
    return bufferFill(buffer, 0);
  }

  if (typeof encoding !== 'string') {
    encoding = undefined;
  }

  return bufferFill(buffer, fill, encoding);
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"buffer-alloc-unsafe":92,"buffer-fill":94}],94:[function(require,module,exports){
(function (Buffer){(function (){
/* Node.js 6.4.0 and up has full support */
var hasFullSupport = function () {
  try {
    if (!Buffer.isEncoding('latin1')) {
      return false;
    }

    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
    buf.fill('ab', 'ucs2');
    return buf.toString('hex') === '61006200';
  } catch (_) {
    return false;
  }
}();

function isSingleByte(val) {
  return val.length === 1 && val.charCodeAt(0) < 256;
}

function fillWithNumber(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index');
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;

  if (end > start) {
    buffer.fill(val, start, end);
  }

  return buffer;
}

function fillWithBuffer(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return buffer;
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;
  var pos = start;
  var len = val.length;

  while (pos <= end - len) {
    val.copy(buffer, pos);
    pos += len;
  }

  if (pos !== end) {
    val.copy(buffer, pos, 0, end - pos);
  }

  return buffer;
}

function fill(buffer, val, start, end, encoding) {
  if (hasFullSupport) {
    return buffer.fill(val, start, end, encoding);
  }

  if (typeof val === 'number') {
    return fillWithNumber(buffer, val, start, end);
  }

  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = buffer.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = buffer.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (encoding === 'latin1') {
      encoding = 'binary';
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val === '') {
      return fillWithNumber(buffer, 0, start, end);
    }

    if (isSingleByte(val)) {
      return fillWithNumber(buffer, val.charCodeAt(0), start, end);
    }

    val = new Buffer(val, encoding);
  }

  if (Buffer.isBuffer(val)) {
    return fillWithBuffer(buffer, val, start, end);
  } // Other values (e.g. undefined, boolean, object) results in zero-fill


  return fillWithNumber(buffer, 0, start, end);
}

module.exports = fill;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],95:[function(require,module,exports){
(function (Buffer){(function (){
var toString = Object.prototype.toString;
var isModern = typeof Buffer.alloc === 'function' && typeof Buffer.allocUnsafe === 'function' && typeof Buffer.from === 'function';

function isArrayBuffer(input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer';
}

function fromArrayBuffer(obj, byteOffset, length) {
  byteOffset >>>= 0;
  var maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds");
  }

  if (length === undefined) {
    length = maxLength;
  } else {
    length >>>= 0;

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds");
    }
  }

  return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
}

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
}

function bufferFrom(value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  return isModern ? Buffer.from(value) : new Buffer(value);
}

module.exports = bufferFrom;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],96:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function xor(a, b) {
  var length = Math.min(a.length, b.length);
  var buffer = new Buffer(length);

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i];
  }

  return buffer;
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],97:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */
'use strict';

var base64 = require('base64-js');

var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
} // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }

  if (value == null) {
    throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":36,"buffer":97,"ieee754":278}],98:[function(require,module,exports){
var stream = require('readable-stream');

var inherits = require('inherits');

var bufferFrom = require('buffer-from');

var SIGNAL_FLUSH = bufferFrom([0]);

var Bulk = function (opts, worker, flush) {
  if (!(this instanceof Bulk)) return new Bulk(opts, worker, flush);

  if (typeof opts === 'function') {
    flush = worker;
    worker = opts;
    opts = {};
  }

  stream.Writable.call(this, opts);
  this._worker = worker;
  this._flush = flush;
  this.destroyed = false;
};

inherits(Bulk, stream.Writable);

Bulk.obj = function (opts, worker, flush) {
  if (typeof opts === 'function') return Bulk.obj(null, opts, worker);
  if (!opts) opts = {};
  opts.objectMode = true;
  return new Bulk(opts, worker, flush);
};

Bulk.prototype.end = function (data, enc, cb) {
  if (!this._flush) return stream.Writable.prototype.end.apply(this, arguments);
  if (typeof data === 'function') return this.end(null, null, data);
  if (typeof enc === 'function') return this.end(data, null, enc);
  if (data) this.write(data);
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH);
  return stream.Writable.prototype.end.call(this, cb);
};

Bulk.prototype.destroy = function (err) {
  if (this.destroyed) return;
  this.destroyed = true;
  if (err) this.emit('error');
  this.emit('close');
};

Bulk.prototype._write = function (data, enc, cb) {
  if (data === SIGNAL_FLUSH) this._flush(cb);else this._worker([data], cb);
};

Bulk.prototype._writev = function (batch, cb) {
  var len = batch.length;

  if (batch[batch.length - 1].chunk === SIGNAL_FLUSH) {
    cb = this._flusher(cb);
    if (! --len) return cb();
  }

  var arr = new Array(len);

  for (var i = 0; i < len; i++) arr[i] = batch[i].chunk;

  this._worker(arr, cb);
};

Bulk.prototype._flusher = function (cb) {
  var self = this;
  return function (err) {
    if (err) return cb(err);

    self._flush(cb);
  };
};

module.exports = Bulk;

},{"buffer-from":95,"inherits":279,"readable-stream":440}],99:[function(require,module,exports){
var Transform = require('readable-stream').Transform;

var util = require("../util/util.js");

var debug = require('debug')('byte-stream');

module.exports = MargaretBatcher;
util.inherits(MargaretBatcher, Transform);

function getLength(obj) {
  return obj.length || 1;
}

function MargaretBatcher(opts) {
  if (!(this instanceof MargaretBatcher)) {
    return new MargaretBatcher(opts);
  }

  if (typeof opts !== 'object') opts = {
    limit: opts
  }; // backward compat

  Transform.call(this, {
    objectMode: true,
    highWaterMark: 2
  });
  this.limit = opts.limit || 4096; // 4KB, arbitrary

  this.time = opts.time;
  this.destroyed = false;
  this.getLength = opts.length || getLength;
  this.currentTime = Date.now();
  this.currentBatch = [];
  this.size = 0;
  this._push = this._push.bind(this);
  debug('constructor (limit: %d, time: %s)', this.limit, this.time || null);
}

MargaretBatcher.prototype.destroy = function (err) {
  if (this.destroyed) return;
  this.destroyed = true;
  debug('destroy');
  if (this.timeout) clearTimeout(this.timeout);
  if (err) this.emit('error', err);
  this.emit('close');
};

MargaretBatcher.prototype._transform = function (obj, _, cb) {
  if (this.time && !this.timeout) {
    this.timeout = setTimeout(this._push, this.time);
    if (this.timeout.unref) this.timeout.unref();
  }

  var len = this.getLength(obj); // we are overflowing - drain first

  if (this.size + len > this.limit) this._push();
  this.currentBatch.push(obj);
  this.size += len;
  debug('push (size: %d, total: %d)', len, this.size); // bigger than limit - just drain

  if (this.size >= this.limit) this._push();
  cb();
};

MargaretBatcher.prototype._push = function () {
  if (this.timeout) clearTimeout(this.timeout);
  if (!this.currentBatch.length) return;
  var batch = this.currentBatch;
  this.size = 0;
  this.timeout = null;
  this.currentBatch = [];
  this.currentTime = Date.now();
  this.push(batch);
};

MargaretBatcher.prototype._flush = function (cb) {
  this._push();

  cb();
};

},{"../util/util.js":579,"debug":100,"readable-stream":109}],100:[function(require,module,exports){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = require("./debug");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return 'WebkitAppearance' in document.documentElement.style || // is firebug? http://stackoverflow.com/a/398120/376773
  window.console && (console.firebug || console.exception && console.table) || // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
}
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */


exports.formatters.j = function (v) {
  return JSON.stringify(v);
};
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;
  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
  if (!useColors) return args;
  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1)); // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function (match) {
    if ('%%' === match) return;
    index++;

    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
  return args;
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console && 'function' == typeof console.log && Function.prototype.apply.call(console.log, console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch (e) {}
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = localStorage.debug;
  } catch (e) {}

  return r;
}
/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */


exports.enable(load());

},{"./debug":101}],101:[function(require,module,exports){
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');
/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];
/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};
/**
 * Previously assigned color.
 */

var prevColor = 0;
/**
 * Previous log timestamp.
 */

var prevTime;
/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}
/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */


function debug(namespace) {
  // define the `disabled` version
  function disabled() {}

  disabled.enabled = false; // define the `enabled` version

  function enabled() {
    var self = enabled; // set `diff` timestamp

    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr; // add the `color` if not set

    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();
    var args = Array.prototype.slice.call(arguments);
    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    } // apply any `formatters` transformations


    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];

      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

        args.splice(index, 1);
        index--;
      }

      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }

    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  enabled.enabled = true;
  var fn = exports.enabled(namespace) ? enabled : disabled;
  fn.namespace = namespace;
  return fn;
}
/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */


function enable(namespaces) {
  exports.save(namespaces);
  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings

    namespaces = split[i].replace(/\*/g, '.*?');

    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}
/**
 * Disable debug output.
 *
 * @api public
 */


function disable() {
  exports.enable('');
}
/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */


function enabled(name) {
  var i, len;

  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }

  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }

  return false;
}
/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */


function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":103}],102:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],103:[function(require,module,exports){
/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],104:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
module.exports = Duplex;
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) keys.push(key);

  return keys;
};
/*</replacement>*/

/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

var Readable = require("./_stream_readable");

var Writable = require("./_stream_writable");

util.inherits(Duplex, Readable);
forEach(objectKeys(Writable.prototype), function (method) {
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
} // the no-half-open enforcer


function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(this.end.bind(this));
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":106,"./_stream_writable":108,"_process":380,"core-util-is":119,"inherits":279}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
module.exports = PassThrough;

var Transform = require("./_stream_transform");
/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":107,"core-util-is":119,"inherits":279}],106:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Readable;
/*<replacement>*/

var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('buffer').Buffer;
/*</replacement>*/


Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
/*<replacement>*/


if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');
/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;
/*<replacement>*/

var debug = require("../../../../util/util.js");

if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require("./_stream_duplex");

  options = options || {}; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.

  this.ranOut = false; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require("./_stream_duplex");

  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;
  Stream.call(this);
} // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;

    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);

  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended) onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
      if (!addToFront) state.reading = false; // if we want the data now, just emit it.

      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
} // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 128MB


var MAX_HWM = 0x800000;

function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;

    for (var p = 1; p < 32; p <<= 1) n |= n >> p;

    n++;
  }

  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;
  if (state.objectMode) return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0; // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.

  if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n); // don't have that much.  return null, unless we've ended.

  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else return state.length;
  }

  return n;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;
  if (!util.isNumber(n) || n > 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false;
  } // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.


  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n; // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.

  if (state.length === 0 && !state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
  if (!util.isNull(ret)) this.emit('data', ret);
  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;

  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
}

function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) process.nextTick(function () {
      emitReadable_(stream);
    });else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function () {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable) {
    debug('onunpipe');

    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata); // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);

    if (false === ret) {
      debug('false write response, pause', src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.


  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error]; // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this);

    return this;
  } // try to find the right one.


  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;
  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn); // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.

  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;

    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;

      if (!state.reading) {
        var self = this;
        process.nextTick(function () {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on; // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.

Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;

    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }

    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function () {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;
  var self = this;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length) return;
    var ret = self.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  }); // when we try to consume some more bytes, simply unpause the
  // underlying stream.

  self._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
}; // exposed for testing purposes only.


Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.

function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret; // nothing in the list, definitely empty.

  if (list.length === 0) return null;
  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = new Buffer(n);
      var c = 0;

      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);
        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);
        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();
        c += cpy;
      }
    }
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function () {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this)}).call(this,require('_process'))
},{"../../../../util/util.js":579,"./_stream_duplex":104,"_process":380,"buffer":97,"core-util-is":119,"events":172,"inherits":279,"isarray":102,"stream":548,"string_decoder/":110}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
module.exports = Transform;

var Duplex = require("./_stream_duplex");
/*<replacement>*/


var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(options, stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
  ts.writechunk = null;
  ts.writecb = null;
  if (!util.isNullOrUndefined(data)) stream.push(data);
  if (cb) cb(er);
  var rs = stream._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(options, this); // when the writable side finishes, then flush out anything remaining.

  var stream = this; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;
  this.once('prefinish', function () {
    if (util.isFunction(this._flush)) this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length) throw new Error('calling transform done when ws.length != 0');
  if (ts.transforming) throw new Error('calling transform done when still transforming');
  return stream.push(null);
}

},{"./_stream_duplex":104,"core-util-is":119,"inherits":279}],108:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.
module.exports = Writable;
/*<replacement>*/

var Buffer = require('buffer').Buffer;
/*</replacement>*/


Writable.WritableState = WritableState;
/*<replacement>*/

var util = require('core-util-is');

util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require("./_stream_duplex");

  options = options || {}; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // cast to ints.

  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.buffer = []; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require("./_stream_duplex"); // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.


  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;
  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};

function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(function () {
    cb(er);
  });
} // If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.


function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function () {
      cb(er);
    });
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (!util.isFunction(cb)) cb = function () {};
  if (state.ended) writeAfterEnd(this, state, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }

  return chunk;
} // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.


function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));else doWrite(stream, state, false, len, chunk, encoding, cb);
  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync) process.nextTick(function () {
    state.pendingcb--;
    cb(er);
  });else {
    state.pendingcb--;
    cb(er);
  }
  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function () {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];

    for (var c = 0; c < state.buffer.length; c++) cbs.push(state.buffer[c].callback); // count the one we are adding, as well.
    // TODO(isaacs) clean this up


    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    }); // Clear buffer

    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb); // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(stream, state) {
  return state.ending && state.length === 0 && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);

  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else prefinish(stream, state);
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
}

}).call(this)}).call(this,require('_process'))
},{"./_stream_duplex":104,"_process":380,"buffer":97,"core-util-is":119,"inherits":279,"stream":548}],109:[function(require,module,exports){
(function (process){(function (){
exports = module.exports = require("./lib/_stream_readable.js");
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require("./lib/_stream_writable.js");
exports.Duplex = require("./lib/_stream_duplex.js");
exports.Transform = require("./lib/_stream_transform.js");
exports.PassThrough = require("./lib/_stream_passthrough.js");

if (!process.browser && process.env.READABLE_STREAM === 'disable') {
  module.exports = require('stream');
}

}).call(this)}).call(this,require('_process'))
},{"./lib/_stream_duplex.js":104,"./lib/_stream_passthrough.js":105,"./lib/_stream_readable.js":106,"./lib/_stream_transform.js":107,"./lib/_stream_writable.js":108,"_process":380,"stream":548}],110:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding || function (encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.


var StringDecoder = exports.StringDecoder = function (encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);

  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;

    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;

    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;

    default:
      this.write = passThroughWrite;
      return;
  } // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).


  this.charBuffer = new Buffer(6); // Number of bytes received for the current incomplete multi-byte character.

  this.charReceived = 0; // Number of bytes expected for the current incomplete multi-byte character.

  this.charLength = 0;
}; // write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .


StringDecoder.prototype.write = function (buffer) {
  var charStr = ''; // if our last write ended with an incomplete multibyte character

  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length; // add the new bytes to the char buffer

    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    } // remove bytes belonging to the current character from the buffer


    buffer = buffer.slice(available, buffer.length); // get the character that was split

    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

    var charCode = charStr.charCodeAt(charStr.length - 1);

    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }

    this.charReceived = this.charLength = 0; // if there are no more bytes in this buffer, just emit our char

    if (buffer.length === 0) {
      return charStr;
    }

    break;
  } // determine and set charLength / charReceived


  this.detectIncompleteChar(buffer);
  var end = buffer.length;

  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);
  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  } // or just emit the charStr


  return charStr;
}; // detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.


StringDecoder.prototype.detectIncompleteChar = function (buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = buffer.length >= 3 ? 3 : buffer.length; // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.

  for (; i > 0; i--) {
    var c = buffer[buffer.length - i]; // See http://en.wikipedia.org/wiki/UTF-8#Description
    // 110XXXXX

    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    } // 1110XXXX


    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    } // 11110XXX


    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  this.charReceived = i;
};

StringDecoder.prototype.end = function (buffer) {
  var res = '';
  if (buffer && buffer.length) res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":97}],111:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require("./");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

},{"./":112,"get-intrinsic":185}],112:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}

module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);

  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');

    if (desc.configurable) {
      // original length, plus the receiver, minus any additional arguments (after the receiver)
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }

  return func;
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

},{"function-bind":183,"get-intrinsic":185}],113:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var next = global.process && process.nextTick || global.setImmediate || function (f) {
  setTimeout(f, 0);
};

module.exports = function maybe(cb, promise) {
  if (cb) {
    promise.then(function (result) {
      next(function () {
        cb(null, result);
      });
    }, function (err) {
      next(function () {
        cb(err);
      });
    });
    return undefined;
  } else {
    return promise;
  }
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":380}],114:[function(require,module,exports){
const assert = require('nanoassert');

module.exports = Chacha20;
const constant = [1634760805, 857760878, 2036477234, 1797285236];

function Chacha20(nonce, key, counter) {
  assert(key.byteLength === 32);
  assert(nonce.byteLength === 8 || nonce.byteLength === 12);
  const n = new Uint32Array(nonce.buffer, nonce.byteOffset, nonce.byteLength / 4);
  const k = new Uint32Array(key.buffer, key.byteOffset, key.byteLength / 4);
  if (!counter) counter = 0;
  assert(counter < Number.MAX_SAFE_INTEGER);
  this.finalized = false;
  this.pos = 0;
  this.state = new Uint32Array(16);

  for (let i = 0; i < 4; i++) this.state[i] = constant[i];

  for (let i = 0; i < 8; i++) this.state[4 + i] = k[i];

  this.state[12] = counter & 0xffffffff;

  if (n.byteLength === 8) {
    this.state[13] = (counter && 0xffffffff00000000) >> 32;
    this.state[14] = n[0];
    this.state[15] = n[1];
  } else {
    this.state[13] = n[0];
    this.state[14] = n[1];
    this.state[15] = n[2];
  }

  return this;
}

Chacha20.prototype.update = function (output, input) {
  assert(!this.finalized, 'cipher finalized.');
  assert(output.byteLength >= input.byteLength, 'output cannot be shorter than input.');
  let len = input.length;
  let offset = this.pos % 64;
  this.pos += len; // input position

  let j = 0;
  let keyStream = chacha20Block(this.state); // try to finsih the current block

  while (offset > 0 && len > 0) {
    output[j] = input[j++] ^ keyStream[offset];
    offset = offset + 1 & 0x3f;
    if (!offset) this.state[12]++;
    len--;
  } // encrypt rest block at a time


  while (len > 0) {
    keyStream = chacha20Block(this.state); // less than a full block remaining

    if (len < 64) {
      for (let i = 0; i < len; i++) {
        output[j] = input[j++] ^ keyStream[offset++];
        offset &= 0x3f;
      }

      return;
    }

    for (; offset < 64;) {
      output[j] = input[j++] ^ keyStream[offset++];
    }

    this.state[12]++;
    offset = 0;
    len -= 64;
  }
};

Chacha20.prototype.final = function () {
  this.state.fill(0);
  this.pos = 0;
  this.finalized = true;
};

function chacha20Block(state) {
  // working state
  const ws = new Uint32Array(16);

  for (let i = 16; i--;) ws[i] = state[i];

  for (let i = 0; i < 20; i += 2) {
    QR(ws, 0, 4, 8, 12); // column 0

    QR(ws, 1, 5, 9, 13); // column 1

    QR(ws, 2, 6, 10, 14); // column 2

    QR(ws, 3, 7, 11, 15); // column 3

    QR(ws, 0, 5, 10, 15); // diagonal 1 (main diagonal)

    QR(ws, 1, 6, 11, 12); // diagonal 2

    QR(ws, 2, 7, 8, 13); // diagonal 3

    QR(ws, 3, 4, 9, 14); // diagonal 4
  }

  for (let i = 0; i < 16; i++) {
    ws[i] += state[i];
  }

  return new Uint8Array(ws.buffer, ws.byteOffset, ws.byteLength);
}

function rotl(a, b) {
  return a << b | a >>> 32 - b;
}

function QR(obj, a, b, c, d) {
  obj[a] += obj[b];
  obj[d] ^= obj[a];
  obj[d] = rotl(obj[d], 16);
  obj[c] += obj[d];
  obj[b] ^= obj[c];
  obj[b] = rotl(obj[b], 12);
  obj[a] += obj[b];
  obj[d] ^= obj[a];
  obj[d] = rotl(obj[d], 8);
  obj[c] += obj[d];
  obj[b] ^= obj[c];
  obj[b] = rotl(obj[b], 7);
}

},{"nanoassert":115}],115:[function(require,module,exports){
module.exports = assert;

class AssertionError extends Error {}

AssertionError.prototype.name = 'AssertionError';
/**
 * Minimal assert function
 * @param  {any} t Value to check if falsy
 * @param  {string=} m Optional assertion error message
 * @throws {AssertionError}
 */

function assert(t, m) {
  if (!t) {
    var err = new AssertionError(m);
    if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
    throw err;
  }
}

},{}],116:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

var Transform = require('stream').Transform;

var StringDecoder = require('string_decoder').StringDecoder;

var inherits = require('inherits');

function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === 'string';

  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }

  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }

  this._decoder = null;
  this._encoding = null;
}

inherits(CipherBase, Transform);

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc);
  }

  var outData = this._update(data);

  if (this.hashMode) return this;

  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }

  return outData;
};

CipherBase.prototype.setAutoPadding = function () {};

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};

CipherBase.prototype._transform = function (data, _, next) {
  var err;

  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};

CipherBase.prototype._flush = function (done) {
  var err;

  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }

  done(err);
};

CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0);

  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }

  return outData;
};

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings');

  var out = this._decoder.write(value);

  if (fin) {
    out += this._decoder.end();
  }

  return out;
};

module.exports = CipherBase;

},{"inherits":279,"safe-buffer":446,"stream":548,"string_decoder":566}],117:[function(require,module,exports){
(function (Buffer){(function (){
var clone = function () {
  'use strict';

  function _instanceof(obj, type) {
    return type != null && obj instanceof type;
  }

  var nativeMap;

  try {
    nativeMap = Map;
  } catch (_) {
    // maybe a reference error because no `Map`. Give it a dummy value that no
    // value will ever be an instanceof.
    nativeMap = function () {};
  }

  var nativeSet;

  try {
    nativeSet = Set;
  } catch (_) {
    nativeSet = function () {};
  }

  var nativePromise;

  try {
    nativePromise = Promise;
  } catch (_) {
    nativePromise = function () {};
  }
  /**
   * Clones (copies) an Object using deep copying.
   *
   * This function supports circular references by default, but if you are certain
   * there are no circular references in your object, you can save some CPU time
   * by calling clone(obj, false).
   *
   * Caution: if `circular` is false and `parent` contains circular references,
   * your program may enter an infinite loop and crash.
   *
   * @param `parent` - the object to be cloned
   * @param `circular` - set to true if the object to be cloned may contain
   *    circular references. (optional - true by default)
   * @param `depth` - set to a number if the object is only to be cloned to
   *    a particular depth. (optional - defaults to Infinity)
   * @param `prototype` - sets the prototype to be used when cloning an object.
   *    (optional - defaults to parent prototype).
   * @param `includeNonEnumerable` - set to true if the non-enumerable properties
   *    should be cloned as well. Non-enumerable properties on the prototype
   *    chain will be ignored. (optional - false by default)
  */


  function clone(parent, circular, depth, prototype, includeNonEnumerable) {
    if (typeof circular === 'object') {
      depth = circular.depth;
      prototype = circular.prototype;
      includeNonEnumerable = circular.includeNonEnumerable;
      circular = circular.circular;
    } // maintain two arrays for circular references, where corresponding parents
    // and children have the same index


    var allParents = [];
    var allChildren = [];
    var useBuffer = typeof Buffer != 'undefined';
    if (typeof circular == 'undefined') circular = true;
    if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren

    function _clone(parent, depth) {
      // cloning null always returns null
      if (parent === null) return null;
      if (depth === 0) return parent;
      var child;
      var proto;

      if (typeof parent != 'object') {
        return parent;
      }

      if (_instanceof(parent, nativeMap)) {
        child = new nativeMap();
      } else if (_instanceof(parent, nativeSet)) {
        child = new nativeSet();
      } else if (_instanceof(parent, nativePromise)) {
        child = new nativePromise(function (resolve, reject) {
          parent.then(function (value) {
            resolve(_clone(value, depth - 1));
          }, function (err) {
            reject(_clone(err, depth - 1));
          });
        });
      } else if (clone.__isArray(parent)) {
        child = [];
      } else if (clone.__isRegExp(parent)) {
        child = new RegExp(parent.source, __getRegExpFlags(parent));
        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
      } else if (clone.__isDate(parent)) {
        child = new Date(parent.getTime());
      } else if (useBuffer && Buffer.isBuffer(parent)) {
        if (Buffer.allocUnsafe) {
          // Node.js >= 4.5.0
          child = Buffer.allocUnsafe(parent.length);
        } else {
          // Older Node.js versions
          child = new Buffer(parent.length);
        }

        parent.copy(child);
        return child;
      } else if (_instanceof(parent, Error)) {
        child = Object.create(parent);
      } else {
        if (typeof prototype == 'undefined') {
          proto = Object.getPrototypeOf(parent);
          child = Object.create(proto);
        } else {
          child = Object.create(prototype);
          proto = prototype;
        }
      }

      if (circular) {
        var index = allParents.indexOf(parent);

        if (index != -1) {
          return allChildren[index];
        }

        allParents.push(parent);
        allChildren.push(child);
      }

      if (_instanceof(parent, nativeMap)) {
        parent.forEach(function (value, key) {
          var keyChild = _clone(key, depth - 1);

          var valueChild = _clone(value, depth - 1);

          child.set(keyChild, valueChild);
        });
      }

      if (_instanceof(parent, nativeSet)) {
        parent.forEach(function (value) {
          var entryChild = _clone(value, depth - 1);

          child.add(entryChild);
        });
      }

      for (var i in parent) {
        var attrs;

        if (proto) {
          attrs = Object.getOwnPropertyDescriptor(proto, i);
        }

        if (attrs && attrs.set == null) {
          continue;
        }

        child[i] = _clone(parent[i], depth - 1);
      }

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(parent);

        for (var i = 0; i < symbols.length; i++) {
          // Don't need to worry about cloning a symbol because it is a primitive,
          // like a number or string.
          var symbol = symbols[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);

          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
            continue;
          }

          child[symbol] = _clone(parent[symbol], depth - 1);

          if (!descriptor.enumerable) {
            Object.defineProperty(child, symbol, {
              enumerable: false
            });
          }
        }
      }

      if (includeNonEnumerable) {
        var allPropertyNames = Object.getOwnPropertyNames(parent);

        for (var i = 0; i < allPropertyNames.length; i++) {
          var propertyName = allPropertyNames[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);

          if (descriptor && descriptor.enumerable) {
            continue;
          }

          child[propertyName] = _clone(parent[propertyName], depth - 1);
          Object.defineProperty(child, propertyName, {
            enumerable: false
          });
        }
      }

      return child;
    }

    return _clone(parent, depth);
  }
  /**
   * Simple flat clone using prototype, accepts only objects, usefull for property
   * override on FLAT configuration object (no nested props).
   *
   * USE WITH CAUTION! This may not behave as you wish if you do not know how this
   * works.
   */


  clone.clonePrototype = function clonePrototype(parent) {
    if (parent === null) return null;

    var c = function () {};

    c.prototype = parent;
    return new c();
  }; // private utility functions


  function __objToStr(o) {
    return Object.prototype.toString.call(o);
  }

  clone.__objToStr = __objToStr;

  function __isDate(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Date]';
  }

  clone.__isDate = __isDate;

  function __isArray(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Array]';
  }

  clone.__isArray = __isArray;

  function __isRegExp(o) {
    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
  }

  clone.__isRegExp = __isRegExp;

  function __getRegExpFlags(re) {
    var flags = '';
    if (re.global) flags += 'g';
    if (re.ignoreCase) flags += 'i';
    if (re.multiline) flags += 'm';
    return flags;
  }

  clone.__getRegExpFlags = __getRegExpFlags;
  return clone;
}();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],118:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = codecs;
codecs.ascii = createString('ascii');
codecs.utf8 = createString('utf-8');
codecs.hex = createString('hex');
codecs.base64 = createString('base64');
codecs.ucs2 = createString('ucs2');
codecs.utf16le = createString('utf16le');
codecs.ndjson = createJSON(true);
codecs.json = createJSON(false);
codecs.binary = {
  name: 'binary',
  encode: function encodeBinary(obj) {
    return typeof obj === 'string' ? Buffer.from(obj, 'utf-8') : Buffer.isBuffer(obj) ? obj : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength);
  },
  decode: function decodeBinary(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
  }
};

function codecs(fmt, fallback) {
  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt;

  switch (fmt) {
    case 'ndjson':
      return codecs.ndjson;

    case 'json':
      return codecs.json;

    case 'ascii':
      return codecs.ascii;

    case 'utf-8':
    case 'utf8':
      return codecs.utf8;

    case 'hex':
      return codecs.hex;

    case 'base64':
      return codecs.base64;

    case 'ucs-2':
    case 'ucs2':
      return codecs.ucs2;

    case 'utf16-le':
    case 'utf16le':
      return codecs.utf16le;
  }

  return fallback !== undefined ? fallback : codecs.binary;
}

function createJSON(newline) {
  return {
    name: newline ? 'ndjson' : 'json',
    encode: newline ? encodeNDJSON : encodeJSON,
    decode: function decodeJSON(buf) {
      return JSON.parse(buf.toString());
    }
  };

  function encodeJSON(val) {
    return Buffer.from(JSON.stringify(val));
  }

  function encodeNDJSON(val) {
    return Buffer.from(JSON.stringify(val) + '\n');
  }
}

function createString(type) {
  return {
    name: type,
    encode: function encodeString(val) {
      if (typeof val !== 'string') val = val.toString();
      return Buffer.from(val, type);
    },
    decode: function decodeString(buf) {
      return buf.toString(type);
    }
  };
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],119:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":282}],120:[function(require,module,exports){
(function (process,Buffer){(function (){
const HypercoreProtocol = require('hypercore-protocol');

const Nanoresource = require('nanoresource/emitter');

const hypercore = require('hypercore');

const hypercoreCrypto = require('hypercore-crypto');

const datEncoding = require('dat-encoding');

const maybe = require('call-me-maybe');

const RefPool = require('refpool');

const deriveSeed = require('derive-key');

const derivedStorage = require('derived-key-storage');

const raf = require('random-access-file');

const MASTER_KEY_FILENAME = 'master_key';
const NAMESPACE = 'corestore';
const NAMESPACE_SEPERATOR = ':';

class InnerCorestore extends Nanoresource {
  constructor(storage, opts = {}) {
    super();
    if (typeof storage === 'string') storage = defaultStorage(storage);
    if (typeof storage !== 'function') throw new Error('Storage should be a function or string');
    this.storage = storage;
    this.opts = opts;
    this._replicationStreams = [];
    this.cache = new RefPool({
      maxSize: opts.cacheSize || 1000,
      close: core => {
        core.close(err => {
          if (err) this.emit('error', err);
        });
      }
    }); // Generated in _open

    this._masterKey = opts.masterKey || null;
    this._id = hypercoreCrypto.randomBytes(8); // As discussed in https://github.com/andrewosh/corestore/issues/20

    this.setMaxListeners(0);
  } // Nanoresource Methods


  _open(cb) {
    if (this._masterKey) return cb();
    const keyStorage = this.storage(MASTER_KEY_FILENAME);
    keyStorage.stat((err, st) => {
      if (err && err.code !== 'ENOENT') return cb(err);

      if (err || st.size < 32) {
        this._masterKey = hypercoreCrypto.randomBytes(32);
        return keyStorage.write(0, this._masterKey, err => {
          if (err) return cb(err);
          keyStorage.close(cb);
        });
      }

      keyStorage.read(0, 32, (err, key) => {
        if (err) return cb(err);
        this._masterKey = key;
        keyStorage.close(cb);
      });
    });
  }

  _close(cb) {
    let error = null;

    for (const {
      stream
    } of this._replicationStreams) {
      stream.destroy();
    }

    if (!this.cache.size) return process.nextTick(cb, null);
    let remaining = this.cache.size;

    for (const {
      value: core
    } of this.cache.entries.values()) {
      core.close(err => {
        if (err) error = err;

        if (! --remaining) {
          if (error) return cb(error);
          return cb(null);
        }
      });
    }
  } // Private Methods


  _checkIfExists(dkey, cb) {
    dkey = encodeKey(dkey);
    if (this.cache.has(dkey)) return process.nextTick(cb, null, true);
    const coreStorage = this.storage([dkey.slice(0, 2), dkey.slice(2, 4), dkey, 'key'].join('/'));
    coreStorage.read(0, 32, (err, key) => {
      if (err) return cb(err);
      coreStorage.close(err => {
        if (err) return cb(err);
        if (!key) return cb(null, false);
        return cb(null, true);
      });
    });
  }

  _injectIntoReplicationStreams(core) {
    for (const {
      stream,
      opts
    } of this._replicationStreams) {
      this._replicateCore(false, core, stream, { ...opts
      });
    }
  }

  _replicateCore(isInitiator, core, mainStream, opts) {
    if (!core) return;
    core.ready(function (err) {
      if (err) return;
      core.replicate(isInitiator, { ...opts,
        stream: mainStream
      });
    });
  }

  _deriveSecret(namespace, name) {
    return deriveSeed(namespace, this._masterKey, name);
  }

  _generateKeyPair(name) {
    if (typeof name === 'string') name = Buffer.from(name);else if (!name) name = hypercoreCrypto.randomBytes(32);

    const seed = this._deriveSecret(NAMESPACE, name);

    const keyPair = hypercoreCrypto.keyPair(seed);
    const discoveryKey = hypercoreCrypto.discoveryKey(keyPair.publicKey);
    return {
      name,
      publicKey: keyPair.publicKey,
      secretKey: keyPair.secretKey,
      discoveryKey
    };
  }

  _generateKeys(coreOpts) {
    if (!coreOpts) coreOpts = {};
    if (typeof coreOpts === 'string') coreOpts = Buffer.from(coreOpts, 'hex');
    if (Buffer.isBuffer(coreOpts)) coreOpts = {
      key: coreOpts
    };

    if (coreOpts.keyPair) {
      const publicKey = coreOpts.keyPair.publicKey;
      const secretKey = coreOpts.keyPair.secretKey;
      return {
        publicKey,
        secretKey,
        discoveryKey: hypercoreCrypto.discoveryKey(publicKey),
        name: null
      };
    }

    if (coreOpts.key) {
      const publicKey = decodeKey(coreOpts.key);
      return {
        publicKey,
        secretKey: null,
        discoveryKey: hypercoreCrypto.discoveryKey(publicKey),
        name: null
      };
    }

    if (coreOpts.default || coreOpts.name) {
      if (!coreOpts.name) throw new Error('If the default option is set, a name must be specified.');
      return this._generateKeyPair(coreOpts.name);
    }

    if (coreOpts.discoveryKey) {
      const discoveryKey = decodeKey(coreOpts.discoveryKey);
      return {
        publicKey: null,
        secretKey: null,
        discoveryKey,
        name: null
      };
    }

    return this._generateKeyPair(null);
  } // Public Methods


  isLoaded(coreOpts) {
    const generatedKeys = this._generateKeys(coreOpts);

    return this.cache.has(encodeKey(generatedKeys.discoveryKey));
  }

  isExternal(coreOpts) {
    const generatedKeys = this._generateKeys(coreOpts);

    const entry = this._cache.entry(encodeKey(generatedKeys.discoveryKey));

    if (!entry) return false;
    return entry.refs !== 0;
  }

  get(coreOpts = {}) {
    if (!this.opened) throw new Error('Corestore.ready must be called before get.');
    const self = this;

    const generatedKeys = this._generateKeys(coreOpts);

    const {
      publicKey,
      discoveryKey,
      secretKey
    } = generatedKeys;
    const id = encodeKey(discoveryKey);
    const cached = this.cache.get(id);
    if (cached) return cached;
    const storageRoot = [id.slice(0, 2), id.slice(2, 4), id].join('/');
    const keyStorage = derivedStorage(createStorage, (name, cb) => {
      if (name) {
        const res = this._generateKeyPair(name);

        if (discoveryKey && !discoveryKey.equals(res.discoveryKey)) {
          return cb(new Error('Stored an incorrect name.'));
        }

        return cb(null, res);
      }

      if (secretKey) return cb(null, generatedKeys);
      if (publicKey) return cb(null, {
        name: null,
        publicKey,
        secretKey: null
      });
      const err = new Error('Unknown key pair.');
      err.unknownKeyPair = true;
      return cb(err);
    });
    const cacheOpts = { ...this.opts.cache
    };

    if (coreOpts.cache) {
      if (coreOpts.cache.data === false) delete cacheOpts.data;
      if (coreOpts.cache.tree === false) delete cacheOpts.tree;
    }

    if (cacheOpts.data) cacheOpts.data = cacheOpts.data.namespace();
    if (cacheOpts.tree) cacheOpts.tree = cacheOpts.tree.namespace();
    const core = hypercore(name => {
      if (name === 'key') return keyStorage.key;
      if (name === 'secret_key') return keyStorage.secretKey;
      return createStorage(name);
    }, publicKey, { ...this.opts,
      ...coreOpts,
      cache: cacheOpts,
      createIfMissing: !!publicKey
    });
    this.cache.set(id, core);
    core.ifAvailable.wait();
    var errored = false;
    core.once('error', onerror);
    core.once('ready', onready);
    core.once('close', onclose);
    return core;

    function onready() {
      if (errored) return;
      self.emit('feed', core, coreOpts);
      core.removeListener('error', onerror);

      self._injectIntoReplicationStreams(core); // TODO: nexttick here needed? prob not, just legacy


      process.nextTick(() => core.ifAvailable.continue());
    }

    function onerror(err) {
      errored = true;
      core.ifAvailable.continue();
      self.cache.delete(id);

      if (err.unknownKeyPair) {// If an error occurs during creation by discovery key, then that core does not exist on disk.
        // TODO: This should not throw, but should propagate somehow.
      }
    }

    function onclose() {
      self.cache.delete(id);
    }

    function createStorage(name) {
      return self.storage(storageRoot + '/' + name);
    }
  }

  replicate(isInitiator, cores, replicationOpts = {}) {
    const self = this;
    const finalOpts = { ...this.opts,
      ...replicationOpts
    };
    const mainStream = replicationOpts.stream || new HypercoreProtocol(isInitiator, { ...finalOpts
    });
    var closed = false;

    for (const core of cores) {
      this._replicateCore(isInitiator, core, mainStream, { ...finalOpts
      });
    }

    mainStream.on('discovery-key', ondiscoverykey);
    mainStream.on('finish', onclose);
    mainStream.on('end', onclose);
    mainStream.on('close', onclose);
    const streamState = {
      stream: mainStream,
      opts: finalOpts
    };

    this._replicationStreams.push(streamState);

    return mainStream;

    function ondiscoverykey(dkey) {
      // Get will automatically add the core to all replication streams.
      self._checkIfExists(dkey, (err, exists) => {
        if (closed) return;
        if (err || !exists) return mainStream.close(dkey);
        const passiveCore = self.get({
          discoveryKey: dkey
        });

        self._replicateCore(false, passiveCore, mainStream, { ...finalOpts
        });
      });
    }

    function onclose() {
      if (!closed) {
        self._replicationStreams.splice(self._replicationStreams.indexOf(streamState), 1);

        closed = true;
      }
    }
  }

}

class Corestore extends Nanoresource {
  constructor(storage, opts = {}) {
    super();
    this.storage = storage;
    this.name = opts.name || 'default';
    this.inner = opts.inner || new InnerCorestore(storage, opts);
    this.cache = this.inner.cache;
    this.store = this; // Backwards-compat for NamespacedCorestore

    this._parent = opts.parent;
    this._isNamespaced = !!opts.name;
    this._openedCores = new Map();

    const onfeed = feed => this.emit('feed', feed);

    const onerror = err => this.emit('error', err);

    this.inner.on('feed', onfeed);
    this.inner.on('error', onerror);

    this._unlisten = () => {
      this.inner.removeListener('feed', onfeed);
      this.inner.removeListener('error', onerror);
    };
  }

  ready(cb) {
    return maybe(cb, new Promise((resolve, reject) => {
      this.open(err => {
        if (err) return reject(err);
        return resolve();
      });
    }));
  } // Nanoresource Methods


  _open(cb) {
    return this.inner.open(cb);
  }

  _close(cb) {
    this._unlisten();

    if (!this._parent) return this.inner.close(cb);

    for (const dkey of this._openedCores) {
      this.cache.decrement(dkey);
    }

    return process.nextTick(cb, null);
  } // Private Methods


  _maybeIncrement(core) {
    const id = encodeKey(core.discoveryKey);
    if (this._openedCores.has(id)) return;

    this._openedCores.set(id, core);

    this.cache.increment(id);
  } // Public Methods


  get(coreOpts = {}) {
    if (Buffer.isBuffer(coreOpts)) coreOpts = {
      key: coreOpts
    };
    const core = this.inner.get(coreOpts);

    this._maybeIncrement(core);

    return core;
  }

  default(coreOpts = {}) {
    if (Buffer.isBuffer(coreOpts)) coreOpts = {
      key: coreOpts
    };
    return this.get({ ...coreOpts,
      name: this.name
    });
  }

  namespace(name) {
    if (!name) name = hypercoreCrypto.randomBytes(32);
    if (Buffer.isBuffer(name)) name = name.toString('hex');
    name = this._isNamespaced ? this.name + NAMESPACE_SEPERATOR + name : name;
    return new Corestore(this.storage, {
      inner: this.inner,
      parent: this,
      name
    });
  }

  replicate(isInitiator, opts) {
    const cores = !this._parent ? allReferenced(this.cache) : this._openedCores.values();
    return this.inner.replicate(isInitiator, cores, opts);
  }

  isLoaded(coreOpts) {
    return this.inner.isLoaded(coreOpts);
  }

  isExternal(coreOpts) {
    return this.inner.isExternal(coreOpts);
  }

  list() {
    return new Map([...this._openedCores]);
  }

}

function* allReferenced(cache) {
  for (const entry of cache.entries.values()) {
    if (entry.refs > 0) yield entry.value;
    continue;
  }
}

function encodeKey(key) {
  return Buffer.isBuffer(key) ? datEncoding.encode(key) : key;
}

function decodeKey(key) {
  return typeof key === 'string' ? datEncoding.decode(key) : key;
}

function defaultStorage(dir) {
  return function (name) {
    try {
      var lock = name.endsWith('/bitfield') ? require('fd-lock') : null;
    } catch (err) {}

    return raf(name, {
      directory: dir,
      lock: lock
    });
  };
}

module.exports = Corestore;

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":380,"buffer":97,"call-me-maybe":113,"dat-encoding":130,"derive-key":134,"derived-key-storage":135,"fd-lock":178,"hypercore":241,"hypercore-crypto":236,"hypercore-protocol":239,"nanoresource/emitter":344,"random-access-file":416,"refpool":442}],121:[function(require,module,exports){
module.exports = function (v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
};

},{}],122:[function(require,module,exports){
(function (Buffer){(function (){
var elliptic = require('elliptic');

var BN = require('bn.js');

module.exports = function createECDH(curve) {
  return new ECDH(curve);
};

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
};
aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
  this.curveType = aliases[curve];

  if (!this.curveType) {
    this.curveType = {
      name: curve
    };
  }

  this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap

  this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair();
  return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8';

  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc);
  }

  var otherPub = this.curve.keyFromPublic(other).getPublic();
  var out = otherPub.mul(this.keys.getPrivate()).getX();
  return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true);

  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7;
    } else {
      key[0] = 6;
    }
  }

  return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }

  this.keys._importPublic(pub);

  return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }

  var _priv = new BN(priv);

  _priv = _priv.toString(16);
  this.keys = this.curve.genKeyPair();

  this.keys._importPrivate(_priv);

  return this;
};

function formatReturnValue(bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray();
  }

  var buf = new Buffer(bn);

  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length);
    zeros.fill(0);
    buf = Buffer.concat([zeros, buf]);
  }

  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":123,"buffer":97,"elliptic":149}],123:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"buffer":48,"dup":32}],124:[function(require,module,exports){
'use strict';

var inherits = require('inherits');

var MD5 = require('md5.js');

var RIPEMD160 = require('ripemd160');

var sha = require('sha.js');

var Base = require('cipher-base');

function Hash(hash) {
  Base.call(this, 'digest');
  this._hash = hash;
}

inherits(Hash, Base);

Hash.prototype._update = function (data) {
  this._hash.update(data);
};

Hash.prototype._final = function () {
  return this._hash.digest();
};

module.exports = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === 'md5') return new MD5();
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();
  return new Hash(sha(alg));
};

},{"cipher-base":116,"inherits":279,"md5.js":307,"ripemd160":445,"sha.js":449}],125:[function(require,module,exports){
var MD5 = require('md5.js');

module.exports = function (buffer) {
  return new MD5().update(buffer).digest();
};

},{"md5.js":307}],126:[function(require,module,exports){
'use strict';

var inherits = require('inherits');

var Legacy = require("./legacy");

var Base = require('cipher-base');

var Buffer = require('safe-buffer').Buffer;

var md5 = require('create-hash/md5');

var RIPEMD160 = require('ripemd160');

var sha = require('sha.js');

var ZEROS = Buffer.alloc(128);

function Hmac(alg, key) {
  Base.call(this, 'digest');

  if (typeof key === 'string') {
    key = Buffer.from(key);
  }

  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
  this._alg = alg;
  this._key = key;

  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
    key = hash.update(key).digest();
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);

  this._hash.update(ipad);
}

inherits(Hmac, Base);

Hmac.prototype._update = function (data) {
  this._hash.update(data);
};

Hmac.prototype._final = function () {
  var h = this._hash.digest();

  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
  return hash.update(this._opad).update(h).digest();
};

module.exports = function createHmac(alg, key) {
  alg = alg.toLowerCase();

  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key);
  }

  if (alg === 'md5') {
    return new Legacy(md5, key);
  }

  return new Hmac(alg, key);
};

},{"./legacy":127,"cipher-base":116,"create-hash/md5":125,"inherits":279,"ripemd160":445,"safe-buffer":446,"sha.js":449}],127:[function(require,module,exports){
'use strict';

var inherits = require('inherits');

var Buffer = require('safe-buffer').Buffer;

var Base = require('cipher-base');

var ZEROS = Buffer.alloc(128);
var blocksize = 64;

function Hmac(alg, key) {
  Base.call(this, 'digest');

  if (typeof key === 'string') {
    key = Buffer.from(key);
  }

  this._alg = alg;
  this._key = key;

  if (key.length > blocksize) {
    key = alg(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  this._hash = [ipad];
}

inherits(Hmac, Base);

Hmac.prototype._update = function (data) {
  this._hash.push(data);
};

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash));

  return this._alg(Buffer.concat([this._opad, h]));
};

module.exports = Hmac;

},{"cipher-base":116,"inherits":279,"safe-buffer":446}],128:[function(require,module,exports){
'use strict';

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');
exports.createHash = exports.Hash = require('create-hash');
exports.createHmac = exports.Hmac = require('create-hmac');

var algos = require('browserify-sign/algos');

var algoKeys = Object.keys(algos);
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);

exports.getHashes = function () {
  return hashes;
};

var p = require('pbkdf2');

exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;

var aes = require('browserify-cipher');

exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;

var dh = require('diffie-hellman');

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;

var sign = require('browserify-sign');

exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;
exports.createECDH = require('create-ecdh');

var publicEncrypt = require('public-encrypt');

exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt; // the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill');

exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;

exports.createCredentials = function () {
  throw new Error(['sorry, createCredentials is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
};

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
};

},{"browserify-cipher":66,"browserify-sign":73,"browserify-sign/algos":70,"create-ecdh":122,"create-hash":124,"create-hmac":126,"diffie-hellman":142,"pbkdf2":372,"public-encrypt":387,"randombytes":427,"randomfill":428}],129:[function(require,module,exports){
class ExtendableError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }

}

module.exports = ExtendableError;

},{}],130:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

function encode(buf) {
  if (typeof buf === 'string') return encode(decode(buf));
  if (!Buffer.isBuffer(buf)) throw new Error('Not a buffer');
  if (buf.length !== 32) throw new Error('Invalid buffer');
  return buf.toString('hex');
}

function decode(str) {
  if (Buffer.isBuffer(str)) return decode(encode(str));
  if (typeof str !== 'string') throw new Error('Not a string'); // looking for an hexa string of 64 or 65 consecutive chars

  var match = /([a-f0-9]{64,65})/i.exec(str); // we need exactly 64, so an hexa string with 65 chars (or more) is not allowed

  if (!match || match[1].length !== 64) throw new Error('Invalid key');
  return Buffer.from(match[1], 'hex');
}

exports.encode = exports.toStr = encode;
exports.decode = exports.toBuf = decode;

},{"safe-buffer":446}],131:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = (() => {
  let warned = false;
  return () => {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
})();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || (() => {});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  let r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require("./common")(exports);
const {
  formatters
} = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this)}).call(this,require('_process'))
},{"./common":132,"_process":380}],132:[function(require,module,exports){
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set `diff` timestamp

      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
      set: v => {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

},{"ms":317}],133:[function(require,module,exports){
'use strict'; // From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15

const randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);

const createAbortError = () => {
  const error = new Error('Delay aborted');
  error.name = 'AbortError';
  return error;
};

const createDelay = ({
  clearTimeout: defaultClear,
  setTimeout: set,
  willResolve
}) => (ms, {
  value,
  signal
} = {}) => {
  if (signal && signal.aborted) {
    return Promise.reject(createAbortError());
  }

  let timeoutId;
  let settle;
  let rejectFn;
  const clear = defaultClear || clearTimeout;

  const signalListener = () => {
    clear(timeoutId);
    rejectFn(createAbortError());
  };

  const cleanup = () => {
    if (signal) {
      signal.removeEventListener('abort', signalListener);
    }
  };

  const delayPromise = new Promise((resolve, reject) => {
    settle = () => {
      cleanup();

      if (willResolve) {
        resolve(value);
      } else {
        reject(value);
      }
    };

    rejectFn = reject;
    timeoutId = (set || setTimeout)(settle, ms);
  });

  if (signal) {
    signal.addEventListener('abort', signalListener, {
      once: true
    });
  }

  delayPromise.clear = () => {
    clear(timeoutId);
    timeoutId = null;
    settle();
  };

  return delayPromise;
};

const delay = createDelay({
  willResolve: true
});
delay.reject = createDelay({
  willResolve: false
});

delay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);

delay.createWithTimers = ({
  clearTimeout,
  setTimeout
}) => {
  const delay = createDelay({
    clearTimeout,
    setTimeout,
    willResolve: true
  });
  delay.reject = createDelay({
    clearTimeout,
    setTimeout,
    willResolve: false
  });
  return delay;
};

module.exports = delay; // TODO: Remove this for the next major release

module.exports.default = delay;

},{}],134:[function(require,module,exports){
(function (Buffer){(function (){
const blake2b = require('blake2b-universal');

module.exports = derive;

function derive(ns, masterKey, input, output) {
  if (!output) output = Buffer.alloc(32);
  blake2b.batch(output, [Buffer.from(Buffer.byteLength(ns, 'ascii') + '\n' + ns, 'ascii'), Buffer.isBuffer(input) ? input : Buffer.from(input)], masterKey);
  return output;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"blake2b-universal":42,"buffer":97}],135:[function(require,module,exports){
(function (Buffer){(function (){
const RAS = require('random-access-storage');

const thunky = require('thunky');

const varint = require('varint');

module.exports = keyPair;

function keyPair(storage, derive) {
  const keyStorage = storage('key');
  const nameStorage = storage('name');
  const secretKeyStorage = storage('secret_key');
  const load = thunky(function (cb) {
    keyStorage.read(0, 32, (err, key) => {
      if (err) return createNew();
      readName((err, name) => {
        if (err) return cb(err);
        if (name) return derive(name, cb);
        secretKeyStorage.read(0, 64, (err, secretKey) => {
          if (err) return cb(null, {
            publicKey: key,
            secretKey: null,
            name: null
          });
          return cb(null, {
            publicKey: key,
            secretKey,
            name: null
          });
        });
      });
    });

    function readName(cb) {
      nameStorage.stat((err, st) => {
        if (err) return cb(null, null);
        if (st.size < 2) return cb(null, null);
        nameStorage.read(0, st.size, (err, buf) => {
          if (err) return cb(err, null);
          let len = 0;

          try {
            len = varint.decode(buf, 0);
          } catch (err) {
            return cb(null, null);
          }

          const offset = varint.decode.bytes;
          if (offset + len !== buf.length) return cb(null, null);
          const name = buf.slice(offset);
          return cb(null, name);
        });
      });
    }

    function writeName(name, cb) {
      if (!name) return cb(null);
      const buf = Buffer.allocUnsafe(varint.encodingLength(name.length) + name.length);
      varint.encode(name.length, buf, 0);
      name.copy(buf, varint.encode.bytes);
      nameStorage.write(0, buf, cb);
    }

    function createNew() {
      derive(null, (err, res) => {
        if (err) return cb(err);
        keyStorage.write(0, res.publicKey, err => {
          if (err) return cb(err);
          if (res.name) return writeName(res.name, done);else if (res.secretKey) return secretKeyStorage.write(0, res.secretKey, done);else return done(new Error('The derivation function did not provide a name or a secret key.'));
        });

        function done(err) {
          if (err) return cb(err);
          return cb(null, res);
        }
      });
    }
  });
  const key = new RAS({
    stat(req) {
      load((err, res) => {
        if (err) return req.callback(err);
        req.callback(null, {
          size: 32
        });
      });
    },

    read(req) {
      load((err, res) => {
        if (err) return req.callback(err);
        req.callback(null, res.publicKey);
      });
    },

    close(req) {
      keyStorage.close(err => req.callback(err));
    }

  });
  const secretKey = new RAS({
    stat(req) {
      load((err, res) => {
        if (err) return req.callback(err);
        if (!res.secretKey) return req.callback(new Error('No secret key.'));
        req.callback(null, {
          size: 64
        });
      });
    },

    read(req) {
      load((err, res) => {
        if (err) return req.callback(err);
        if (!res.secretKey) return req.callback(new Error('No secret key.'));
        req.callback(null, res.secretKey);
      });
    },

    close(req) {
      nameStorage.close(err => req.callback(err));
    }

  });
  return {
    key,
    secretKey
  };
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"random-access-storage":424,"thunky":568,"varint":582}],136:[function(require,module,exports){
'use strict';

exports.utils = require("./des/utils");
exports.Cipher = require("./des/cipher");
exports.DES = require("./des/des");
exports.CBC = require("./des/cbc");
exports.EDE = require("./des/ede");

},{"./des/cbc":137,"./des/cipher":138,"./des/des":139,"./des/ede":140,"./des/utils":141}],137:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');
  this.iv = new Array(8);

  for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);

    this._cbcInit();
  }

  inherits(CBC, Base);
  var keys = Object.keys(proto);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;
  var iv = state.iv;

  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
  }
};

},{"inherits":279,"minimalistic-assert":312}],138:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;
  this.type = this.options.type;
  this.blockSize = 8;

  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}

module.exports = Cipher;

Cipher.prototype._init = function _init() {// Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0) return [];
  if (this.type === 'decrypt') return this._updateDecrypt(data);else return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);

  for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];

  this.bufferOff += min; // Shift next

  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);

  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = (this.bufferOff + data.length) / this.blockSize | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);
    if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
  } // Write blocks


  var max = data.length - (data.length - inputOff) % this.blockSize;

  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);

    outputOff += this.blockSize;
  } // Queue rest


  for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize); // TODO(indutny): optimize it, this is far from optimal

  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  } // Buffer rest of the input


  inputOff += this._buffer(data, inputOff);
  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer) first = this.update(buffer);
  var last;
  if (this.type === 'encrypt') last = this._finalEncrypt();else last = this._finalDecrypt();
  if (first) return first.concat(last);else return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0) return false;

  while (off < buffer.length) buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff)) return [];
  var out = new Array(this.blockSize);

  this._update(this.buffer, 0, out, 0);

  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);

  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":312}],139:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

var inherits = require('inherits');

var utils = require("./utils");

var Cipher = require("./cipher");

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);
  var state = new DESState();
  this._desState = state;
  this.deriveKeys(state, options.key);
}

inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);
  assert.equal(key.length, this.blockSize, 'Invalid key length');
  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);
  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];

  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;
  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4); // Initial Permutation

  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;

  for (var i = off; i < buffer.length; i++) buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];

  for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart; // Apply f() x16 times

  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1]; // f(r, k)

    utils.expand(r, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  } // Reverse Initial Permutation


  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart; // Apply f() x16 times

  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1]; // f(r, k)

    utils.expand(l, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  } // Reverse Initial Permutation


  utils.rip(l, r, out, off);
};

},{"./cipher":138,"./utils":141,"inherits":279,"minimalistic-assert":312}],140:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

var inherits = require('inherits');

var Cipher = require("./cipher");

var DES = require("./des");

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');
  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [DES.create({
      type: 'encrypt',
      key: k1
    }), DES.create({
      type: 'decrypt',
      key: k2
    }), DES.create({
      type: 'encrypt',
      key: k3
    })];
  } else {
    this.ciphers = [DES.create({
      type: 'decrypt',
      key: k3
    }), DES.create({
      type: 'encrypt',
      key: k2
    }), DES.create({
      type: 'decrypt',
      key: k1
    })];
  }
}

function EDE(options) {
  Cipher.call(this, options);
  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}

inherits(EDE, Cipher);
module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);

  state.ciphers[1]._update(out, outOff, out, outOff);

  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":138,"./des":139,"inherits":279,"minimalistic-assert":312}],141:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = value >>> 16 & 0xff;
  bytes[2 + off] = value >>> 8 & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
    }

    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }

  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28

  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >> j + i & 1;
    }
  }

  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= inR >> j + i & 1;
  } // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60


  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inR >> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }
  }

  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= inL >> j + i & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return num << shift & 0xfffffff | num >>> 28 - shift;
};

var pc2table = [// inL => outL
14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, // inR => outR
15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  var len = pc2table.length >>> 1;

  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= inL >>> pc2table[i] & 0x1;
  }

  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= inR >>> pc2table[i] & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;
  outL = (r & 1) << 5 | r >>> 27;

  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= r >>> i & 0x3f;
  }

  for (var i = 11; i >= 3; i -= 4) {
    outR |= r >>> i & 0x3f;
    outR <<= 6;
  }

  outR |= (r & 0x1f) << 1 | r >>> 31;
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];

exports.substitute = function substitute(inL, inR) {
  var out = 0;

  for (var i = 0; i < 4; i++) {
    var b = inL >>> 18 - i * 6 & 0x3f;
    var sb = sTable[i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }

  for (var i = 0; i < 4; i++) {
    var b = inR >>> 18 - i * 6 & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }

  return out >>> 0;
};

var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];

exports.permute = function permute(num) {
  var out = 0;

  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= num >>> permuteTable[i] & 0x1;
  }

  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);

  while (str.length < size) str = '0' + str;

  var out = [];

  for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));

  return out.join(' ');
};

},{}],142:[function(require,module,exports){
(function (Buffer){(function (){
var generatePrime = require("./lib/generatePrime");

var primes = require("./lib/primes.json");

var DH = require("./lib/dh");

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');
  return new DH(prime, gen);
}

var ENCODINGS = {
  'binary': true,
  'hex': true,
  'base64': true
};

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator);
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/dh":143,"./lib/generatePrime":144,"./lib/primes.json":145,"buffer":97}],143:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js');

var MillerRabin = require('miller-rabin');

var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);

var primes = require("./generatePrime");

var randomBytes = require('randombytes');

module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }

  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }

  this._priv = new BN(priv);
  return this;
}

var primeCache = {};

function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');

  if (hex in primeCache) {
    return primeCache[hex];
  }

  var error = 0;

  if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }

    primeCache[hex] = error;
    return error;
  }

  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }

  var rem;

  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }

      break;

    case '05':
      rem = prime.mod(TEN);

      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }

      break;

    default:
      error += 4;
  }

  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;

  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}

Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }

    return this._primeCode;
  }
});

DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }

  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();

  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }

  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }

  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());

  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./generatePrime":144,"bn.js":146,"buffer":97,"miller-rabin":310,"randombytes":427}],144:[function(require,module,exports){
var randomBytes = require('randombytes');

module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;

var BN = require('bn.js');

var TWENTYFOUR = new BN(24);

var MillerRabin = require('miller-rabin');

var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null) return primes;
  var limit = 0x100000;
  var res = [];
  res[0] = 2;

  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));

    for (var j = 0; j < i && res[j] <= sqrt; j++) if (k % res[j] === 0) break;

    if (i !== j && res[j] <= sqrt) continue;
    res[i++] = k;
  }

  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++) if (p.modn(primes[i]) === 0) {
    if (p.cmpn(primes[i]) === 0) {
      return true;
    } else {
      return false;
    }
  }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }

  gen = new BN(gen);
  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));

    while (num.bitLength() > bits) {
      num.ishrn(1);
    }

    if (num.isEven()) {
      num.iadd(ONE);
    }

    if (!num.testn(1)) {
      num.iadd(TWO);
    }

    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }

    n2 = num.shrn(1);

    if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }
}

},{"bn.js":146,"miller-rabin":310,"randombytes":427}],145:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],146:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"buffer":48,"dup":32}],147:[function(require,module,exports){
(function (process,Buffer){(function (){
var stream = require('readable-stream');

var eos = require('end-of-stream');

var inherits = require('inherits');

var shift = require('stream-shift');

var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);

var onuncork = function (self, fn) {
  if (self._corked) self.once('uncork', fn);else fn();
};

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err);
};

var destroyer = function (self, end) {
  return function (err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();
  };
};

var end = function (ws, fn) {
  if (!ws) return fn();
  if (ws._writableState && ws._writableState.finished) return fn();
  if (ws._writableState) return ws.end(fn);
  ws.end();
  fn();
};

var toStreams2 = function (rs) {
  return new stream.Readable({
    objectMode: true,
    highWaterMark: 16
  }).wrap(rs);
};

var Duplexify = function (writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);
  stream.Duplex.call(this, opts);
  this._writable = null;
  this._readable = null;
  this._readable2 = null;
  this._autoDestroy = !opts || opts.autoDestroy !== false;
  this._forwardDestroy = !opts || opts.destroy !== false;
  this._forwardEnd = !opts || opts.end !== false;
  this._corked = 1; // start corked

  this._ondrain = null;
  this._drained = false;
  this._forwarding = false;
  this._unwrite = null;
  this._unread = null;
  this._ended = false;
  this.destroyed = false;
  if (writable) this.setWritable(writable);
  if (readable) this.setReadable(readable);
};

inherits(Duplexify, stream.Duplex);

Duplexify.obj = function (writable, readable, opts) {
  if (!opts) opts = {};
  opts.objectMode = true;
  opts.highWaterMark = 16;
  return new Duplexify(writable, readable, opts);
};

Duplexify.prototype.cork = function () {
  if (++this._corked === 1) this.emit('cork');
};

Duplexify.prototype.uncork = function () {
  if (this._corked && --this._corked === 0) this.emit('uncork');
};

Duplexify.prototype.setWritable = function (writable) {
  if (this._unwrite) this._unwrite();

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy();
    return;
  }

  if (writable === null || writable === false) {
    this.end();
    return;
  }

  var self = this;
  var unend = eos(writable, {
    writable: true,
    readable: false
  }, destroyer(this, this._forwardEnd));

  var ondrain = function () {
    var ondrain = self._ondrain;
    self._ondrain = null;
    if (ondrain) ondrain();
  };

  var clear = function () {
    self._writable.removeListener('drain', ondrain);

    unend();
  };

  if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks

  this._writable = writable;

  this._writable.on('drain', ondrain);

  this._unwrite = clear;
  this.uncork(); // always uncork setWritable
};

Duplexify.prototype.setReadable = function (readable) {
  if (this._unread) this._unread();

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy();
    return;
  }

  if (readable === null || readable === false) {
    this.push(null);
    this.resume();
    return;
  }

  var self = this;
  var unend = eos(readable, {
    writable: false,
    readable: true
  }, destroyer(this));

  var onreadable = function () {
    self._forward();
  };

  var onend = function () {
    self.push(null);
  };

  var clear = function () {
    self._readable2.removeListener('readable', onreadable);

    self._readable2.removeListener('end', onend);

    unend();
  };

  this._drained = true;
  this._readable = readable;
  this._readable2 = readable._readableState ? readable : toStreams2(readable);

  this._readable2.on('readable', onreadable);

  this._readable2.on('end', onend);

  this._unread = clear;

  this._forward();
};

Duplexify.prototype._read = function () {
  this._drained = true;

  this._forward();
};

Duplexify.prototype._forward = function () {
  if (this._forwarding || !this._readable2 || !this._drained) return;
  this._forwarding = true;
  var data;

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue;
    this._drained = this.push(data);
  }

  this._forwarding = false;
};

Duplexify.prototype.destroy = function (err) {
  if (this.destroyed) return;
  this.destroyed = true;
  var self = this;
  process.nextTick(function () {
    self._destroy(err);
  });
};

Duplexify.prototype._destroy = function (err) {
  if (err) {
    var ondrain = this._ondrain;
    this._ondrain = null;
    if (ondrain) ondrain(err);else this.emit('error', err);
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy();
    if (this._writable && this._writable.destroy) this._writable.destroy();
  }

  this.emit('close');
};

Duplexify.prototype._write = function (data, enc, cb) {
  if (this.destroyed) return cb();
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));
  if (data === SIGNAL_FLUSH) return this._finish(cb);
  if (!this._writable) return cb();
  if (this._writable.write(data) === false) this._ondrain = cb;else cb();
};

Duplexify.prototype._finish = function (cb) {
  var self = this;
  this.emit('preend');
  onuncork(this, function () {
    end(self._forwardEnd && self._writable, function () {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true;
      self.emit('prefinish');
      onuncork(self, cb);
    });
  });
};

Duplexify.prototype.end = function (data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data);
  if (typeof enc === 'function') return this.end(data, null, enc);
  this._ended = true;
  if (data) this.write(data);
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH);
  return stream.Writable.prototype.end.call(this, cb);
};

module.exports = Duplexify;

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":380,"buffer":97,"end-of-stream":168,"inherits":279,"readable-stream":440,"stream-shift":564}],148:[function(require,module,exports){
'use strict';

const Duplex = require('readable-stream').Duplex;

const kCallback = Symbol('Callback');
const kOtherSide = Symbol('Other');

class DuplexSocket extends Duplex {
  constructor(options) {
    super(options);
    this[kCallback] = null;
    this[kOtherSide] = null;
  }

  _read() {
    const callback = this[kCallback];

    if (callback) {
      this[kCallback] = null;
      callback();
    }
  }

  _write(chunk, encoding, callback) {
    this[kOtherSide][kCallback] = callback;
    this[kOtherSide].push(chunk);
  }

  _final(callback) {
    this[kOtherSide].on('end', callback);
    this[kOtherSide].push(null);
  }

}

class DuplexPair {
  constructor(options) {
    this.socket1 = new DuplexSocket(options);
    this.socket2 = new DuplexSocket(options);
    this.socket1[kOtherSide] = this.socket2;
    this.socket2[kOtherSide] = this.socket1;
  }

}

module.exports = DuplexPair;

},{"readable-stream":440}],149:[function(require,module,exports){
'use strict';

var elliptic = exports;
elliptic.version = require("../package.json").version;
elliptic.utils = require("./elliptic/utils");
elliptic.rand = require('brorand');
elliptic.curve = require("./elliptic/curve");
elliptic.curves = require("./elliptic/curves"); // Protocols

elliptic.ec = require("./elliptic/ec");
elliptic.eddsa = require("./elliptic/eddsa");

},{"../package.json":165,"./elliptic/curve":152,"./elliptic/curves":155,"./elliptic/ec":156,"./elliptic/eddsa":159,"./elliptic/utils":163,"brorand":47}],150:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require("../utils");

var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16); // Use Montgomery, when there is no fast reduction for the prime

  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p); // Useful for many curves

  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red); // Curve configuration, optional

  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed); // Temporary arrays

  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0; // Generalized Greg Maxwell's trick

  var adjustCount = this.n && this.p.div(this.n);

  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}

module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);

  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3; // Translate into more windowed form

  var repr = [];
  var j;
  var nafW;

  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;

    for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];

    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);

  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }

    a = a.add(b);
  }

  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4; // Precompute window

  var nafPoints = p._getNAFPoints(w);

  w = nafPoints.wnd;
  var wnd = nafPoints.points; // Get NAF form

  var naf = getNAF(k, w, this._bitLength); // Add `this`*(N+1) for every w-NAF index

  var acc = this.jpoint(null, null, null);

  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;

    if (i >= 0) l++;
    acc = acc.dblp(l);
    if (i < 0) break;
    var z = naf[i];
    assert(z !== 0);

    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }

  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3; // Fill all arrays

  var max = 0;
  var i;
  var j;
  var p;

  for (i = 0; i < len; i++) {
    p = points[i];

    var nafPoints = p._getNAFPoints(defW);

    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  } // Comb small window NAFs


  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;

    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [points[a],
    /* 1 */
    null,
    /* 3 */
    null,
    /* 5 */
    points[b]
    /* 7 */
    ]; // Try to avoid Projective points, if possible

    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [-3,
    /* -1 -1 */
    -1,
    /* -1 0 */
    -5,
    /* -1 1 */
    -7,
    /* 0 -1 */
    0,
    /* 0 0 */
    7,
    /* 0 1 */
    5,
    /* 1 -1 */
    1,
    /* 1 0 */
    3
    /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);

    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;

  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;

      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }

      if (!zero) break;
      k++;
      i--;
    }

    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  } // Zeroify references


  for (i = 0; i < len; i++) wnd[i] = null;

  if (jacobianResult) return acc;else return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}

BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq()
/*other*/
{
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);
  var len = this.p.byteLength(); // uncompressed, hybrid-odd, hybrid-even

  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }

  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;

  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) acc = acc.dbl();

    doubles.push(acc);
  }

  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();

  for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);

  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;

  for (var i = 0; i < k; i++) r = r.dbl();

  return r;
};

},{"../utils":163,"bn.js":164}],151:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var BN = require('bn.js');

var inherits = require('inherits');

var Base = require("./base");

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, 'edwards', conf);
  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}

inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC) return num;else return this.c.redMul(num);
}; // Just for compatibility with Short curve


EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red) y = y.toRed(this.red); // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)

  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
  if (x.fromRed().isOdd() !== odd) x = x.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity()) return true; // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)

  point.normalize();
  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one; // Use extended coordinates

    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
    }
  }
}

inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S
  // A = X1^2
  var a = this.x.redSqr(); // B = Y1^2

  var b = this.y.redSqr(); // C = 2 * Z1^2

  var c = this.z.redSqr();
  c = c.redIAdd(c); // D = a * A

  var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B


  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B

  var g = d.redAdd(b); // F = G - C

  var f = g.redSub(c); // H = D - B

  var h = d.redSub(b); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S
  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr(); // C = X1^2

  var c = this.x.redSqr(); // D = Y1^2

  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;

  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c); // F = E + D

    var f = e.redAdd(d);

    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F^2 - 2 * F

      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr(); // J = F - 2 * H

      j = f.redSub(h).redISub(h); // X3 = (B-C-D)*J

      nx = b.redSub(c).redISub(d).redMul(j); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F * J

      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d); // H = (c * Z1)^2

    h = this.curve._mulC(this.z).redSqr(); // J = E - 2 * H

    j = e.redSub(h).redSub(h); // X3 = c * (B - E) * J

    nx = this.curve._mulC(b.redISub(e)).redMul(j); // Y3 = c * E * (C - D)

    ny = this.curve._mulC(e).redMul(c.redISub(d)); // Z3 = E * J

    nz = e.redMul(j);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this; // Double in extended coordinates

  if (this.curve.extended) return this._extDbl();else return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M
  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)

  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2

  var c = this.t.redMul(this.curve.dd).redMul(p.t); // D = Z1 * 2 * Z2

  var d = this.z.redMul(p.z.redAdd(p.z)); // E = B - A

  var e = b.redSub(a); // F = D - C

  var f = d.redSub(c); // G = D + C

  var g = d.redAdd(c); // H = B + A

  var h = b.redAdd(a); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S
  // A = Z1 * Z2
  var a = this.z.redMul(p.z); // B = A^2

  var b = a.redSqr(); // C = X1 * X2

  var c = this.x.redMul(p.x); // D = Y1 * Y2

  var d = this.y.redMul(p.y); // E = d * C * D

  var e = this.curve.d.redMul(c).redMul(d); // F = B - E

  var f = b.redSub(e); // G = B + E

  var g = b.redAdd(e); // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)

  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;

  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))); // Z3 = F * G

    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c)); // Z3 = c * F * G

    nz = this.curve._mulC(f).redMul(g);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity()) return p;
  if (p.isInfinity()) return this;
  if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne) return this; // Normalize coordinates

  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t) this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
}; // Compatibility with BaseCurve


Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":163,"./base":150,"bn.js":164,"inherits":279}],152:[function(require,module,exports){
'use strict';

var curve = exports;
curve.base = require("./base");
curve.short = require("./short");
curve.mont = require("./mont");
curve.edwards = require("./edwards");

},{"./base":150,"./edwards":151,"./mont":153,"./short":154}],153:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var inherits = require('inherits');

var Base = require("./base");

var utils = require("../utils");

function MontCurve(conf) {
  Base.call(this, 'mont', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}

inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  }
}

inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {// No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A
  // A = X1 + Z1
  var a = this.x.redAdd(this.z); // AA = A^2

  var aa = a.redSqr(); // B = X1 - Z1

  var b = this.x.redSub(this.z); // BB = B^2

  var bb = b.redSqr(); // C = AA - BB

  var c = aa.redSub(bb); // X3 = AA * BB

  var nx = aa.redMul(bb); // Z3 = C * (BB + A24 * C)

  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A
  // A = X2 + Z2
  var a = this.x.redAdd(this.z); // B = X2 - Z2

  var b = this.x.redSub(this.z); // C = X3 + Z3

  var c = p.x.redAdd(p.z); // D = X3 - Z3

  var d = p.x.redSub(p.z); // DA = D * A

  var da = d.redMul(a); // CB = C * B

  var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

  var nx = diff.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q

  var b = this.curve.point(null, null); // (N / 2) * Q

  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c); // N * Q = 2 * ((N / 2) * Q + Q))

      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c); // N * Q + Q = 2 * ((N / 2) * Q + Q)

      a = a.dbl();
    }
  }

  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();
  return this.x.fromRed();
};

},{"../utils":163,"./base":150,"bn.js":164,"inherits":279}],154:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var BN = require('bn.js');

var inherits = require('inherits');

var Base = require("./base");

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0; // If the curve is endomorphic, precalculate beta and lambda

  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}

inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return; // Compute beta and lambda, that lambda * P = (beta * Px; Py)

  var beta;
  var lambda;

  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p); // Choose the smallest beta


    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }

  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);

    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  } // Get basis vectors, used for balanced length-two representation


  var basis;

  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)); // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt

  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1); // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)

  var a0;
  var b0; // First vector

  var a1;
  var b1; // Second vector

  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;

  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }

    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }

  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());

  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  } // Normalize signs


  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }

  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b); // Calculate answer

  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point'); // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;

  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);

    var p = points[i];

    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }

    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }

  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult); // Clean-up references to points and coefficients


  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }

  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');

  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16); // Force redgomery representation when loading from JSON

    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }

    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}

inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

  if (pre) {
    var curve = this.curve;

    var endoMul = function (p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };

    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }

  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p; // P + O = P

  if (p.inf) return this; // P + P = 2P

  if (this.eq(p)) return this.dbl(); // P + (-P) = O

  if (this.neg().eq(p)) return this.curve.point(null, null); // P + Q = O

  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf) return this; // 2P = O

  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());

  if (_precompute && this.precomputed) {
    var pre = this.precomputed;

    var negate = function (p) {
      return p.neg();
    };

    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }

  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');

  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }

  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}

inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p; // P + O = P

  if (p.isInfinity()) return this; // 12M + 4S + 7A

  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ(); // P + O = P

  if (p.isInfinity()) return this; // 8M + 3S + 7A

  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();
  var i;

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;

    for (i = 0; i < pow; i++) r = r.dbl();

    return r;
  } // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A


  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr(); // Reuse results

  var jyd = jy.redAdd(jy);

  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a; a = 0

    var m = xx.redAdd(xx).redIAdd(xx); // T = M ^ 2 - 2*S

    var t = m.redSqr().redISub(s).redISub(s); // 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2*Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A
    // A = X1^2
    var a = this.x.redSqr(); // B = Y1^2

    var b = this.y.redSqr(); // C = B^2

    var c = b.redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d); // E = 3 * A

    var e = a.redAdd(a).redIAdd(a); // F = E^2

    var f = e.redSqr(); // 8 * C

    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8); // X3 = F - 2 * D

    nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

    ny = e.redMul(d.redISub(nx)).redISub(c8); // Z3 = 2 * Y1 * Z1

    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a

    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a); // T = M^2 - 2 * S

    var t = m.redSqr().redISub(s).redISub(s); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2 * Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S
    // delta = Z1^2
    var delta = this.z.redSqr(); // gamma = Y1^2

    var gamma = this.y.redSqr(); // beta = X1 * gamma

    var beta = this.x.redMul(gamma); // alpha = 3 * (X1 - delta) * (X1 + delta)

    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha); // X3 = alpha^2 - 8 * beta

    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a; // 4M + 6S + 10A

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this); // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...
  // XX = X1^2

  var xx = this.x.redSqr(); // YY = Y1^2

  var yy = this.y.redSqr(); // ZZ = Z1^2

  var zz = this.z.redSqr(); // YYYY = YY^2

  var yyyy = yy.redSqr(); // M = 3 * XX + a * ZZ2; a = 0

  var m = xx.redAdd(xx).redIAdd(xx); // MM = M^2

  var mm = m.redSqr(); // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM

  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm); // EE = E^2

  var ee = e.redSqr(); // T = 16*YYYY

  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t); // U = (M + E)^2 - MM - EE - T

  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t); // X3 = 4 * (X1 * EE - 4 * YY * U)

  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx); // Y3 = 8 * Y1 * (U * (T - U) - E * EE)

  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny); // Z3 = (Z1 + E)^2 - ZZ - EE

  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);
  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true; // x1 * z2^2 == x2 * z1^2

  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false; // y1 * z2^3 == y2 * z1^3

  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":163,"./base":150,"bn.js":164,"inherits":279}],155:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');

var curve = require("./curve");

var utils = require("./utils");

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short') this.curve = new curve.short(options);else if (options.type === 'edwards') this.curve = new curve.edwards(options);else this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;
  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}

curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function () {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
});
defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
});
defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
});
defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
});
defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
});
defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['9']
});
defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', // 4/5
  '6666666666666666666666666666666666666666666666666666666666666658']
});
var pre;

try {
  pre = require("./precomputed/secp256k1");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,
  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [{
    a: '3086d221a7d46bcde86c90e49284eb15',
    b: '-e4437ed6010e88286f547fa90abfe4c3'
  }, {
    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
    b: '3086d221a7d46bcde86c90e49284eb15'
  }],
  gRed: false,
  g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
});

},{"./curve":152,"./precomputed/secp256k1":162,"./utils":163,"hash.js":205}],156:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var HmacDRBG = require('hmac-drbg');

var utils = require("../utils");

var curves = require("../curves");

var rand = require('brorand');

var assert = utils.assert;

var KeyPair = require("./key");

var Signature = require("./signature");

function EC(options) {
  if (!(this instanceof EC)) return new EC(options); // Shortcut `elliptic.ec(curve-name)`

  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options), 'Unknown curve ' + options);
    options = curves[options];
  } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`


  if (options instanceof curves.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g; // Point on curve

  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG

  this.hash = options.hash || options.curve.hash;
}

module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {}; // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));

  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }

  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16)); // Zero-extend key to provide enough entropy

  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N

  var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  }); // Number of bytes to generate

  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0;; iter++) {
    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`

    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex'); // Perform primitive values validation

  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature

  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  } // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K


  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`

  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);
  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s; // A set LSB signifies that the y-coordinate is odd

  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.

  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)

  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null) return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;

    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q)) return i;
  }

  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":155,"../utils":163,"./key":157,"./signature":158,"bn.js":164,"brorand":47,"hmac-drbg":218}],157:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require("../utils");

var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })

  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}

module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method

  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }

    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }

  this.pub = this.ec.curve.decodePoint(key, enc);
}; // ECDH


KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }

  return pub.mul(this.priv).getX();
}; // ECDSA


KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":163,"bn.js":164}],158:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require("../utils");

var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}

module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];

  if (!(initial & 0x80)) {
    return initial;
  }

  var octetLen = initial & 0xf; // Indefinite length or overflow

  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;

  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  } // Leading zeroes


  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;

  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }

  if (i === 0) {
    return buf;
  }

  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();

  if (data[p.place++] !== 0x30) {
    return false;
  }

  var len = getLength(data, p);

  if (len === false) {
    return false;
  }

  if (len + p.place !== data.length) {
    return false;
  }

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var rlen = getLength(data, p);

  if (rlen === false) {
    return false;
  }

  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var slen = getLength(data, p);

  if (slen === false) {
    return false;
  }

  if (data.length !== slen + p.place) {
    return false;
  }

  var s = data.slice(p.place, slen + p.place);

  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;
  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }

  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);

  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }

  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r); // Pad values

  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }

  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":163,"bn.js":164}],159:[function(require,module,exports){
'use strict';

var hash = require('hash.js');

var curves = require("../curves");

var utils = require("../utils");

var assert = utils.assert;
var parseBytes = utils.parseBytes;

var KeyPair = require("./key");

var Signature = require("./signature");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');
  if (!(this instanceof EDDSA)) return new EDDSA(curve);
  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);
  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/

EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({
    R: R,
    S: S,
    Rencoded: Rencoded
  });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/


EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();

  for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);

  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature) return sig;
  return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/


EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":155,"../utils":163,"./key":160,"./signature":161,"hash.js":205}],160:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/

function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(eddsa, {
    pub: pub
  });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair) return secret;
  return new KeyPair(eddsa, {
    secret: secret
  });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;
  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":163}],161:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require("../utils");

var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/

function Signature(eddsa, sig) {
  this.eddsa = eddsa;
  if (typeof sig !== 'object') sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');
  if (eddsa.isPoint(sig.R)) this._R = sig.R;
  if (sig.S instanceof BN) this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":163,"bn.js":164}],162:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
  },
  naf: {
    wnd: 7,
    points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
  }
};

},{}],163:[function(require,module,exports){
'use strict';

var utils = exports;

var BN = require('bn.js');

var minAssert = require('minimalistic-assert');

var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode; // Represent num in a w-NAF form

function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);
  var ws = 1 << w + 1;
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);

    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}

utils.getNAF = getNAF; // Represent k1, k2 in a Joint Sparse Form

function getJSF(k1, k2) {
  var jsf = [[], []];
  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;

  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = k1.andln(3) + d1 & 3;
    var m24 = k2.andln(3) + d2 & 3;
    if (m14 === 3) m14 = -1;
    if (m24 === 3) m24 = -1;
    var u1;

    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = k1.andln(7) + d1 & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
    }

    jsf[0].push(u1);
    var u2;

    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = k2.andln(7) + d2 & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
    }

    jsf[1].push(u2); // Second phase

    if (2 * d1 === u1 + 1) d1 = 1 - d1;
    if (2 * d2 === u2 + 1) d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}

utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;

  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
  };
}

utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
}

utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}

utils.intFromLE = intFromLE;

},{"bn.js":164,"minimalistic-assert":312,"minimalistic-crypto-utils":313}],164:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"buffer":48,"dup":32}],165:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],166:[function(require,module,exports){
'use strict';

const anyMap = new WeakMap();
const eventsMap = new WeakMap();
const producersMap = new WeakMap();
const anyProducer = Symbol('anyProducer');
const resolvedPromise = Promise.resolve();
const listenerAdded = Symbol('listenerAdded');
const listenerRemoved = Symbol('listenerRemoved');

function assertEventName(eventName) {
  if (typeof eventName !== 'string' && typeof eventName !== 'symbol') {
    throw new TypeError('eventName must be a string or a symbol');
  }
}

function assertListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('listener must be a function');
  }
}

function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);

  if (!events.has(eventName)) {
    events.set(eventName, new Set());
  }

  return events.get(eventName);
}

function getEventProducers(instance, eventName) {
  const key = typeof eventName === 'string' ? eventName : anyProducer;
  const producers = producersMap.get(instance);

  if (!producers.has(key)) {
    producers.set(key, new Set());
  }

  return producers.get(key);
}

function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);

  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }

  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);

    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}

function iterator(instance, eventName) {
  let isFinished = false;

  let flush = () => {};

  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },

    finish() {
      isFinished = true;
      flush();
    }

  };
  getEventProducers(instance, eventName).add(producer);
  return {
    async next() {
      if (!queue) {
        return {
          done: true
        };
      }

      if (queue.length === 0) {
        if (isFinished) {
          queue = undefined;
          return this.next();
        }

        await new Promise(resolve => {
          flush = resolve;
        });
        return this.next();
      }

      return {
        done: false,
        value: await queue.shift()
      };
    },

    async return(value) {
      queue = undefined;
      getEventProducers(instance, eventName).delete(producer);
      flush();
      return arguments.length > 0 ? {
        done: true,
        value: await value
      } : {
        done: true
      };
    },

    [Symbol.asyncIterator]() {
      return this;
    }

  };
}

function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === undefined) {
    return allEmitteryMethods;
  }

  if (!Array.isArray(methodNames)) {
    throw new TypeError('`methodNames` must be an array of strings');
  }

  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== 'string') {
        throw new TypeError('`methodNames` element must be a string');
      }

      throw new Error(`${methodName} is not Emittery method`);
    }
  }

  return methodNames;
}

const isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;

class Emittery {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return target => {
      if (typeof target !== 'function') {
        throw new TypeError('`target` must be function');
      }

      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== undefined) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }

      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new Emittery()
        });
        return this[emitteryPropertyName];
      }

      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });

      const emitteryMethodCaller = methodName => function (...args) {
        return this[emitteryPropertyName][methodName](...args);
      };

      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }

      return target;
    };
  }

  constructor() {
    anyMap.set(this, new Set());
    eventsMap.set(this, new Map());
    producersMap.set(this, new Map());
  }

  on(eventName, listener) {
    assertEventName(eventName);
    assertListener(listener);
    getListeners(this, eventName).add(listener);

    if (!isListenerSymbol(eventName)) {
      this.emit(listenerAdded, {
        eventName,
        listener
      });
    }

    return this.off.bind(this, eventName, listener);
  }

  off(eventName, listener) {
    assertEventName(eventName);
    assertListener(listener);

    if (!isListenerSymbol(eventName)) {
      this.emit(listenerRemoved, {
        eventName,
        listener
      });
    }

    getListeners(this, eventName).delete(listener);
  }

  once(eventName) {
    return new Promise(resolve => {
      assertEventName(eventName);
      const off = this.on(eventName, data => {
        off();
        resolve(data);
      });
    });
  }

  events(eventName) {
    assertEventName(eventName);
    return iterator(this, eventName);
  }

  async emit(eventName, eventData) {
    assertEventName(eventName);
    enqueueProducers(this, eventName, eventData);
    const listeners = getListeners(this, eventName);
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    return Promise.all([...staticListeners.map(async listener => {
      if (listeners.has(listener)) {
        return listener(eventData);
      }
    }), ...staticAnyListeners.map(async listener => {
      if (anyListeners.has(listener)) {
        return listener(eventName, eventData);
      }
    })]);
  }

  async emitSerial(eventName, eventData) {
    assertEventName(eventName);
    const listeners = getListeners(this, eventName);
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    /* eslint-disable no-await-in-loop */

    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }

    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
    /* eslint-enable no-await-in-loop */

  }

  onAny(listener) {
    assertListener(listener);
    anyMap.get(this).add(listener);
    this.emit(listenerAdded, {
      listener
    });
    return this.offAny.bind(this, listener);
  }

  anyEvent() {
    return iterator(this);
  }

  offAny(listener) {
    assertListener(listener);
    this.emit(listenerRemoved, {
      listener
    });
    anyMap.get(this).delete(listener);
  }

  clearListeners(eventName) {
    if (typeof eventName === 'string') {
      getListeners(this, eventName).clear();
      const producers = getEventProducers(this, eventName);

      for (const producer of producers) {
        producer.finish();
      }

      producers.clear();
    } else {
      anyMap.get(this).clear();

      for (const listeners of eventsMap.get(this).values()) {
        listeners.clear();
      }

      for (const producers of producersMap.get(this).values()) {
        for (const producer of producers) {
          producer.finish();
        }

        producers.clear();
      }
    }
  }

  listenerCount(eventName) {
    if (typeof eventName === 'string') {
      return anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
    }

    if (typeof eventName !== 'undefined') {
      assertEventName(eventName);
    }

    let count = anyMap.get(this).size;

    for (const value of eventsMap.get(this).values()) {
      count += value.size;
    }

    for (const value of producersMap.get(this).values()) {
      count += value.size;
    }

    return count;
  }

  bindMethods(target, methodNames) {
    if (typeof target !== 'object' || target === null) {
      throw new TypeError('`target` must be an object');
    }

    methodNames = defaultMethodNamesOrAssert(methodNames);

    for (const methodName of methodNames) {
      if (target[methodName] !== undefined) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }

      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }

}

const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor'); // Subclass used to encourage TS users to type their events.

Emittery.Typed = class extends Emittery {};
Object.defineProperty(Emittery.Typed, 'Typed', {
  enumerable: false,
  value: undefined
});
Object.defineProperty(Emittery, 'listenerAdded', {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, 'listenerRemoved', {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});
module.exports = Emittery;

},{}],167:[function(require,module,exports){
var eos = require('end-of-stream');

module.exports = function eosp(stream, opts = {}) {
  return new Promise((resolve, reject) => {
    function cb(err) {
      if (err) reject(err);else resolve();
    }

    eos(stream, opts, cb);
  });
};

},{"end-of-stream":168}],168:[function(require,module,exports){
(function (process){(function (){
var once = require('once');

var noop = function () {};

var isRequest = function (stream) {
  return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function (stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};

var eos = function (stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;

  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };

  var onfinish = function () {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function () {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function (exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function (err) {
    callback.call(stream, err);
  };

  var onclose = function () {
    process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function () {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
    if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
  };

  var onrequest = function () {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

module.exports = eos;

}).call(this)}).call(this,require('_process'))
},{"_process":380,"once":358}],169:[function(require,module,exports){
'use strict';
/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */

function assign(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }

  return obj;
}
/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */


function createError(err, code, props) {
  if (!err || typeof err === 'string') {
    throw new TypeError('Please pass an Error to err-code');
  }

  if (!props) {
    props = {};
  }

  if (typeof code === 'object') {
    props = code;
    code = '';
  }

  if (code) {
    props.code = code;
  }

  try {
    return assign(err, props);
  } catch (_) {
    props.message = err.message;
    props.stack = err.stack;

    const ErrClass = function () {};

    ErrClass.prototype = Object.create(Object.getPrototypeOf(err)); // @ts-ignore

    const output = assign(new ErrClass(), props);
    return output;
  }
}

module.exports = createError;

},{}],170:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');

if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}

module.exports = $gOPD;

},{"get-intrinsic":185}],171:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty,
    prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */

function Events() {} //
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//


if (Object.create) {
  Events.prototype = Object.create(null); //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //

  if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */


function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */


function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
  return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */


function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */


function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */


EventEmitter.prototype.eventNames = function eventNames() {
  var names = [],
      events,
      name;
  if (this._eventsCount === 0) return names;

  for (name in events = this._events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */


EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */


EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */


EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return false;
  var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1:
        return listeners.fn.call(listeners.context), true;

      case 2:
        return listeners.fn.call(listeners.context, a1), true;

      case 3:
        return listeners.fn.call(listeners.context, a1, a2), true;

      case 4:
        return listeners.fn.call(listeners.context, a1, a2, a3), true;

      case 5:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

      case 6:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length,
        j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1:
          listeners[i].fn.call(listeners[i].context);
          break;

        case 2:
          listeners[i].fn.call(listeners[i].context, a1);
          break;

        case 3:
          listeners[i].fn.call(listeners[i].context, a1, a2);
          break;

        case 4:
          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
          break;

        default:
          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
            args[j - 1] = arguments[j];
          }
          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return this;

  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
        events.push(listeners[i]);
      }
    } //
    // Reset the array, or remove it completely if we have no more listeners.
    //


    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
  }

  return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
}; //
// Alias methods names because people roll like that.
//


EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
// Expose the prefix.
//

EventEmitter.prefixed = prefix; //
// Allow `EventEmitter` to be imported as module namespace.
//

EventEmitter.EventEmitter = EventEmitter; //
// Expose the module.
//

if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],172:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],173:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

var MD5 = require('md5.js');
/* eslint-disable camelcase */


function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary');

  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length');
  }

  var keyLen = keyBits / 8;
  var key = Buffer.alloc(keyLen);
  var iv = Buffer.alloc(ivLen || 0);
  var tmp = Buffer.alloc(0);

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5();
    hash.update(tmp);
    hash.update(password);
    if (salt) hash.update(salt);
    tmp = hash.digest();
    var used = 0;

    if (keyLen > 0) {
      var keyStart = key.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key, keyStart, 0, used);
      keyLen -= used;
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen;
      var length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }

  tmp.fill(0);
  return {
    key: key,
    iv: iv
  };
}

module.exports = EVP_BytesToKey;

},{"md5.js":307,"safe-buffer":446}],174:[function(require,module,exports){
'use strict';

const ctz = require('count-trailing-zeros');

module.exports = () => new Bitfield();

class Page {
  constructor(level) {
    const buf = new Uint8Array(level ? 8456 : 4360);
    const b = buf.byteOffset;
    this.buffer = buf;
    this.bits = level ? null : new Uint32Array(buf.buffer, b, 1024);
    this.children = level ? new Array(32768) : null;
    this.level = level;
    this.allOne = level ? [new Uint32Array(buf.buffer, b, 1024), new Uint32Array(buf.buffer, b + 4096, 32), new Uint32Array(buf.buffer, b + 4224, 1)] : [this.bits, new Uint32Array(buf.buffer, b + 4096, 32), new Uint32Array(buf.buffer, b + 4224, 1)];
    this.oneOne = level ? [new Uint32Array(buf.buffer, b + 4228, 1024), new Uint32Array(buf.buffer, b + 8324, 32), new Uint32Array(buf.buffer, b + 8452, 1)] : [this.bits, new Uint32Array(buf.buffer, b + 4228, 32), new Uint32Array(buf.buffer, b + 4356, 1)];
  }

}

const ZEROS = [new Page(0), new Page(1), new Page(2), new Page(3)];
const MASK = new Uint32Array(32);
const MASK_INCL = new Uint32Array(32);

for (var i = 0; i < 32; i++) {
  MASK[i] = Math.pow(2, 31 - i) - 1;
  MASK_INCL[i] = Math.pow(2, 32 - i) - 1;
}

const LITTLE_ENDIAN = new Uint8Array(MASK.buffer, MASK.byteOffset, 1)[0] === 0xff;

class Bitfield {
  constructor() {
    this.length = 32768;
    this.littleEndian = LITTLE_ENDIAN;
    this._path = new Uint16Array(5);
    this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
    this._parents = new Array(4).fill(null);
    this._page = new Page(0);
    this._allocs = 1;
  }

  last() {
    var page = this._page;
    var b = 0;

    while (true) {
      for (var i = 2; i >= 0; i--) {
        const c = ctz(page.oneOne[i][b]);
        if (c === 32) return -1;
        b = (b << 5) + (31 - c);
      }

      this._path[page.level] = b;
      if (!page.level) return defactor(this._path);
      page = page.children[b];
      b = 0;
    }
  }

  set(index, bit) {
    const page = this._getPage(index, bit);

    if (!page) return false;
    const i = this._path[0];
    const r = i & 31;
    const b = i >>> 5;
    const prev = page.bits[b];
    page.bits[b] = bit ? prev | 0x80000000 >>> r : prev & ~(0x80000000 >>> r);
    const upd = page.bits[b];
    if (upd === prev) return false;

    this._updateAllOne(page, b, upd);

    this._updateOneOne(page, b, upd);

    return true;
  }

  get(index) {
    const page = this._getPage(index, false);

    if (!page) return false;
    const i = this._path[0];
    const r = i & 31;
    return (page.bits[i >>> 5] & 0x80000000 >>> r) !== 0;
  }

  iterator() {
    return new Iterator(this);
  }

  fill(val, start, end) {
    if (!start) start = 0;
    if (val === true) return this._fillBit(true, start, end === 0 ? end : end || this.length);
    if (val === false) return this._fillBit(false, start, end === 0 ? end : end || this.length);

    this._fillBuffer(val, start, end === 0 ? end : end || start + 8 * val.length);
  }

  grow() {
    if (this._page.level === 3) throw new Error('Cannot grow beyond ' + this.length);
    const page = this._page;
    this._page = new Page(page.level + 1);
    this._page.children[0] = page;
    if (this._page.level === 3) this.length = Number.MAX_SAFE_INTEGER;else this.length *= 32768;
  }

  _fillBuffer(buf, start, end) {
    if (start & 7 || end & 7) throw new Error('Offsets must be a multiple of 8');
    start /= 8;

    while (end > this.length) this.grow();

    end /= 8;
    const offset = start;

    var page = this._getPage(8 * start, true);

    while (start < end) {
      const delta = end - start < 4096 ? end - start : 4096;
      const s = start - offset;
      start += this._setPageBuffer(page, buf.subarray(s, s + delta), start & 1023);
      if (start !== end) page = this._nextPage(page, 8 * start);
    }
  }

  _fillBit(bit, start, end) {
    var page = this._getPage(start, bit); // TODO: this can be optimised a lot in the case of end - start > 32768
    // in that case clear levels of 32768 ** 2 instead etc


    while (start < end) {
      const delta = end - start < 32768 ? end - start : 32768;
      start += this._setPageBits(page, bit, start & 32767, delta);
      if (start !== end) page = this._nextPage(page, start);
    }
  }

  _nextPage(page, start) {
    const i = ++this._offsets[page.level];
    return i === 32768 ? this._getPage(start, true) : this._parents[page.level].children[i] || this._addPage(this._parents[page.level], i);
  }

  _setPageBuffer(page, buf, start) {
    new Uint8Array(page.bits.buffer, page.bits.byteOffset, page.bits.length * 4).set(buf, start);
    start >>>= 2;

    this._update(page, start, start + (buf.length >>> 2) + (buf.length & 3 ? 1 : 0));

    return buf.length;
  }

  _setPageBits(page, bit, start, end) {
    const s = start >>> 5;
    const e = end >>> 5;
    const sm = 0xffffffff >>> (start & 31);
    const em = ~(0xffffffff >>> (end & 31));

    if (s === e) {
      page.bits[s] = bit ? page.bits[s] | sm & em : page.bits[s] & ~(sm & em);

      this._update(page, s, s + 1);

      return end - start;
    }

    page.bits[s] = bit ? page.bits[s] | sm : page.bits[s] & ~sm;
    if (e - s > 2) page.bits.fill(bit ? 0xffffffff : 0, s + 1, e - 1);

    if (e === 1024) {
      page.bits[e - 1] = bit ? 0xffffffff : 0;

      this._update(page, s, e);

      return end - start;
    }

    page.bits[e] = bit ? page.bits[e] | em : page.bits[e] & ~em;

    this._update(page, s, e + 1);

    return end - start;
  }

  _update(page, start, end) {
    for (; start < end; start++) {
      const upd = page.bits[start];

      this._updateAllOne(page, start, upd);

      this._updateOneOne(page, start, upd);
    }
  }

  _updateAllOne(page, b, upd) {
    var i = 1;

    do {
      for (; i < 3; i++) {
        const buf = page.allOne[i];
        const r = b & 31;
        const prev = buf[b >>>= 5];
        buf[b] = upd === 0xffffffff ? prev | 0x80000000 >>> r : prev & ~(0x80000000 >>> r);
        upd = buf[b];
        if (upd === prev) return;
      }

      b += this._offsets[page.level];
      page = this._parents[page.level];
      i = 0;
    } while (page);
  }

  _updateOneOne(page, b, upd) {
    var i = 1;

    do {
      for (; i < 3; i++) {
        const buf = page.oneOne[i];
        const r = b & 31;
        const prev = buf[b >>>= 5];
        buf[b] = upd !== 0 ? prev | 0x80000000 >>> r : prev & ~(0x80000000 >>> r);
        upd = buf[b];
        if (upd === prev) return;
      }

      b += this._offsets[page.level];
      page = this._parents[page.level];
      i = 0;

      if (upd === 0 && page) {
        // all zeros, non root -> free page
        page.children[this._offsets[page.level - 1]] = undefined;
      }
    } while (page);
  }

  _getPage(index, createIfMissing) {
    factor(index, this._path);

    while (index >= this.length) {
      if (!createIfMissing) return null;
      this.grow();
    }

    var page = this._page;

    for (var i = page.level; i > 0 && page; i--) {
      const p = this._path[i];
      this._parents[i - 1] = page;
      page = page.children[p] || (createIfMissing ? this._addPage(page, p) : null);
    }

    return page;
  }

  _addPage(page, i) {
    this._allocs++;
    page = page.children[i] = new Page(page.level - 1);
    return page;
  }

}

class Iterator {
  constructor(bitfield) {
    this._bitfield = bitfield;
    this._path = new Uint16Array(5);
    this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
    this._parents = new Array(4).fill(null);
    this._page = null;
    this._allocs = bitfield._allocs;
    this.seek(0);
  }

  seek(index) {
    this._allocs = this._bitfield._allocs;

    if (index >= this._bitfield.length) {
      this._page = null;
      return this;
    }

    factor(index, this._path);
    this._page = this._bitfield._page;

    for (var i = this._page.level; i > 0; i--) {
      this._parents[i - 1] = this._page;
      this._page = this._page.children[this._path[i]] || ZEROS[i - 1];
    }

    return this;
  }

  next(bit) {
    return bit ? this.nextTrue() : this.nextFalse();
  }

  nextFalse() {
    if (this._allocs !== this._bitfield._allocs) {
      // If a page has been alloced while we are iterating
      // and we have a zero page in our path we need to reseek
      // in case that page has been overwritten
      this.seek(defactor(this._path));
    }

    var page = this._page;
    var b = this._path[0];
    var mask = MASK_INCL;

    while (page) {
      for (var i = 0; i < 3; i++) {
        const r = b & 31;
        const clz = Math.clz32(~page.allOne[i][b >>>= 5] & mask[r]);
        if (clz !== 32) return this._downLeftFalse(page, i, b, clz);
        mask = MASK;
      }

      b = this._offsets[page.level];
      page = this._parents[page.level];
    }

    return -1;
  }

  _downLeftFalse(page, i, b, clz) {
    while (true) {
      while (i) {
        b = (b << 5) + clz;
        clz = Math.clz32(~page.allOne[--i][b]);
      }

      b = (b << 5) + clz;
      if (!page.level) break;
      this._parents[page.level - 1] = page;
      this._path[page.level] = b;
      page = page.children[b];
      i = 3;
      clz = b = 0;
    }

    this._page = page;
    this._path[0] = b;
    return this._inc();
  }

  nextTrue() {
    var page = this._page;
    var b = this._path[0];
    var mask = MASK_INCL;

    while (page) {
      for (var i = 0; i < 3; i++) {
        const r = b & 31;
        const clz = Math.clz32(page.oneOne[i][b >>>= 5] & mask[r]);
        if (clz !== 32) return this._downLeftTrue(page, i, b, clz);
        mask = MASK;
      }

      b = this._offsets[page.level];
      page = this._parents[page.level];
    }

    return -1;
  }

  _downLeftTrue(page, i, b, clz) {
    while (true) {
      while (i) {
        b = (b << 5) + clz;
        clz = Math.clz32(page.oneOne[--i][b]);
      }

      b = (b << 5) + clz;
      if (!page.level) break;
      this._parents[page.level - 1] = page;
      this._path[page.level] = b;
      page = page.children[b];
      i = 3;
      clz = b = 0;
    }

    this._page = page;
    this._path[0] = b;
    return this._inc();
  }

  _inc() {
    const n = defactor(this._path);
    if (this._path[0] < 32767) this._path[0]++;else this.seek(n + 1);
    return n;
  }

}

function defactor(out) {
  return ((out[3] * 32768 + out[2]) * 32768 + out[1]) * 32768 + out[0];
}

function factor(n, out) {
  n = (n - (out[0] = n & 32767)) / 32768;
  n = (n - (out[1] = n & 32767)) / 32768;
  out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
}

},{"count-trailing-zeros":121}],175:[function(require,module,exports){
module.exports = class FixedFIFO {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two');
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }

  push(data) {
    if (this.buffer[this.top] !== undefined) return false;
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }

  shift() {
    const last = this.buffer[this.btm];
    if (last === undefined) return undefined;
    this.buffer[this.btm] = undefined;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }

  isEmpty() {
    return this.buffer[this.btm] === undefined;
  }

};

},{}],176:[function(require,module,exports){
const FixedFIFO = require("./fixed-size");

module.exports = class FastFIFO {
  constructor(hwm) {
    this.hwm = hwm || 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
  }

  push(val) {
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }

  shift() {
    const val = this.tail.shift();

    if (val === undefined && this.tail.next) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      return this.tail.shift();
    }

    return val;
  }

  isEmpty() {
    return this.head.isEmpty();
  }

};

},{"./fixed-size":175}],177:[function(require,module,exports){
'use strict';

var reusify = require('reusify');

function fastqueue(context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1');
  }

  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  };
  return self;

  function running() {
    return _running;
  }

  function pause() {
    self.paused = true;
  }

  function length() {
    var current = queueHead;
    var counter = 0;

    while (current) {
      current = current.next;
      counter++;
    }

    return counter;
  }

  function getQueue() {
    var current = queueHead;
    var tasks = [];

    while (current) {
      tasks.push(current.value);
      current = current.next;
    }

    return tasks;
  }

  function resume() {
    if (!self.paused) return;
    self.paused = false;

    for (var i = 0; i < self.concurrency; i++) {
      _running++;
      release();
    }
  }

  function idle() {
    return _running === 0 && self.length() === 0;
  }

  function push(value, done) {
    var current = cache.get();
    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop;
    current.errorHandler = errorHandler;

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function unshift(value, done) {
    var current = cache.get();
    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop;

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function release(holder) {
    if (holder) {
      cache.release(holder);
    }

    var next = queueHead;

    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }

        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);

        if (queueTail === null) {
          self.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self.drain();
    }
  }

  function kill() {
    queueHead = null;
    queueTail = null;
    self.drain = noop;
  }

  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self.drain();
    self.drain = noop;
  }

  function error(handler) {
    errorHandler = handler;
  }
}

function noop() {}

function Task() {
  this.value = null;
  this.callback = noop;
  this.next = null;
  this.release = noop;
  this.context = null;
  this.errorHandler = null;
  var self = this;

  this.worked = function worked(err, result) {
    var callback = self.callback;
    var errorHandler = self.errorHandler;
    var val = self.value;
    self.value = null;
    self.callback = noop;

    if (self.errorHandler) {
      errorHandler(err, val);
    }

    callback.call(self.context, err, result);
    self.release(self);
  };
}

function queueAsPromised(context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function (res) {
      cb(null, res);
    }, cb);
  }

  var queue = fastqueue(context, asyncWrapper, concurrency);
  var pushCb = queue.push;
  var unshiftCb = queue.unshift;
  queue.push = push;
  queue.unshift = unshift;
  return queue;

  function push(value) {
    return new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err);
          return;
        }

        resolve(result);
      });
    });
  }

  function unshift(value) {
    return new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err);
          return;
        }

        resolve(result);
      });
    });
  }
}

module.exports = fastqueue;
module.exports.promise = queueAsPromised;

},{"reusify":444}],178:[function(require,module,exports){
(function (__dirname){(function (){
const binding = require('node-gyp-build')(__dirname);

lock.unlock = unlock;
module.exports = lock;

function lock(fd) {
  return !!binding.fd_lock(fd);
}

function unlock(fd) {
  return !!binding.fd_unlock(fd);
}

}).call(this)}).call(this,"/node_modules/fd-lock")
},{"node-gyp-build":347}],179:[function(require,module,exports){
const linux = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  O_ACCMODE: 3,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_DSYNC: 4096,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};
const darwin = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  O_ACCMODE: 3,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
}; // Lightly-modified from the Node FS internal utils.

function parse(constants, flags) {
  if (typeof flags === 'number') {
    return flags;
  }

  switch (flags) {
    case 'r':
      return constants.O_RDONLY;

    case 'rs': // Fall through.

    case 'sr':
      return constants.O_RDONLY | constants.O_SYNC;

    case 'r+':
      return constants.O_RDWR;

    case 'rs+': // Fall through.

    case 'sr+':
      return constants.O_RDWR | constants.O_SYNC;

    case 'w':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY;

    case 'wx': // Fall through.

    case 'xw':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL;

    case 'w+':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR;

    case 'wx+': // Fall through.

    case 'xw+':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR | constants.O_EXCL;

    case 'a':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY;

    case 'ax': // Fall through.

    case 'xa':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL;

    case 'as': // Fall through.

    case 'sa':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY | constants.O_SYNC;

    case 'a+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR;

    case 'ax+': // Fall through.

    case 'xa+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR | constants.O_EXCL;

    case 'as+': // Fall through.

    case 'sa+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR | constants.O_SYNC;
  }

  throw new Error(`Invalid value in flags: ${flags}`);
}

function translate(from, to, flags) {
  let translated = 0;
  translated |= from.O_RDONLY & flags && to.O_RDONLY;
  translated |= from.O_WRONLY & flags && to.O_WRONLY;
  translated |= from.O_RDWR & flags && to.O_RDWR;
  translated |= from.O_CREAT & flags && to.O_CREAT;
  translated |= from.O_APPEND & flags && to.O_APPEND;
  translated |= from.O_EXCL & flags && to.O_EXCL;
  translated |= from.O_TRUNC & flags && to.O_TRUNC;
  translated |= from.O_DIRECT & flags && to.O_DIRECT;
  translated |= from.O_DSYNC & flags && to.O_DSYNC;
  translated |= from.O_DIRECTORY & flags && to.O_DIRECTORY;
  translated |= from.O_NOATIME & flags && to.O_NOATIME;
  translated |= from.O_NOCTTY & flags && to.O_NOCTTY;
  translated |= from.O_NOFOLLOW & flags && to.O_NOFOLLOW;
  translated |= from.O_NONBLOCK & flags && to.O_NONBLOCK;
  return translated;
}

module.exports = {
  linux,
  darwin,
  parse,
  translate
};

},{}],180:[function(require,module,exports){
exports.fullRoots = function (index, result) {
  if (index & 1) throw new Error('You can only look up roots for depth(0) blocks');
  if (!result) result = [];
  index /= 2;
  var offset = 0;
  var factor = 1;

  while (true) {
    if (!index) return result;

    while (factor * 2 <= index) factor *= 2;

    result.push(offset + factor - 1);
    offset = offset + 2 * factor;
    index -= factor;
    factor = 1;
  }
};

exports.depth = function (index) {
  var depth = 0;
  index += 1;

  while (!(index & 1)) {
    depth++;
    index = rightShift(index);
  }

  return depth;
};

exports.sibling = function (index, depth) {
  if (!depth) depth = exports.depth(index);
  var offset = exports.offset(index, depth);
  return exports.index(depth, offset & 1 ? offset - 1 : offset + 1);
};

exports.parent = function (index, depth) {
  if (!depth) depth = exports.depth(index);
  var offset = exports.offset(index, depth);
  return exports.index(depth + 1, rightShift(offset));
};

exports.leftChild = function (index, depth) {
  if (!(index & 1)) return -1;
  if (!depth) depth = exports.depth(index);
  return exports.index(depth - 1, exports.offset(index, depth) * 2);
};

exports.rightChild = function (index, depth) {
  if (!(index & 1)) return -1;
  if (!depth) depth = exports.depth(index);
  return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2);
};

exports.children = function (index, depth) {
  if (!(index & 1)) return null;
  if (!depth) depth = exports.depth(index);
  var offset = exports.offset(index, depth) * 2;
  return [exports.index(depth - 1, offset), exports.index(depth - 1, offset + 1)];
};

exports.leftSpan = function (index, depth) {
  if (!(index & 1)) return index;
  if (!depth) depth = exports.depth(index);
  return exports.offset(index, depth) * twoPow(depth + 1);
};

exports.rightSpan = function (index, depth) {
  if (!(index & 1)) return index;
  if (!depth) depth = exports.depth(index);
  return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2;
};

exports.count = function (index, depth) {
  if (!(index & 1)) return 1;
  if (!depth) depth = exports.depth(index);
  return twoPow(depth + 1) - 1;
};

exports.spans = function (index, depth) {
  if (!(index & 1)) return [index, index];
  if (!depth) depth = exports.depth(index);
  var offset = exports.offset(index, depth);
  var width = twoPow(depth + 1);
  return [offset * width, (offset + 1) * width - 2];
};

exports.index = function (depth, offset) {
  return (1 + 2 * offset) * twoPow(depth) - 1;
};

exports.offset = function (index, depth) {
  if (!(index & 1)) return index / 2;
  if (!depth) depth = exports.depth(index);
  return ((index + 1) / twoPow(depth) - 1) / 2;
};

exports.iterator = function (index) {
  var ite = new Iterator();
  ite.seek(index || 0);
  return ite;
};

function twoPow(n) {
  return n < 31 ? 1 << n : (1 << 30) * (1 << n - 30);
}

function rightShift(n) {
  return (n - (n & 1)) / 2;
}

function Iterator() {
  this.index = 0;
  this.offset = 0;
  this.factor = 0;
}

Iterator.prototype.seek = function (index) {
  this.index = index;

  if (this.index & 1) {
    this.offset = exports.offset(index);
    this.factor = twoPow(exports.depth(index) + 1);
  } else {
    this.offset = index / 2;
    this.factor = 2;
  }
};

Iterator.prototype.isLeft = function () {
  return (this.offset & 1) === 0;
};

Iterator.prototype.isRight = function () {
  return (this.offset & 1) === 1;
};

Iterator.prototype.contains = function (index) {
  return index > this.index ? index < this.index + this.factor / 2 : index < this.index ? index > this.index - this.factor / 2 : true;
};

Iterator.prototype.prev = function () {
  if (!this.offset) return this.index;
  this.offset--;
  this.index -= this.factor;
  return this.index;
};

Iterator.prototype.next = function () {
  this.offset++;
  this.index += this.factor;
  return this.index;
};

Iterator.prototype.sibling = function () {
  return this.isLeft() ? this.next() : this.prev();
};

Iterator.prototype.parent = function () {
  if (this.offset & 1) {
    this.index -= this.factor / 2;
    this.offset = (this.offset - 1) / 2;
  } else {
    this.index += this.factor / 2;
    this.offset /= 2;
  }

  this.factor *= 2;
  return this.index;
};

Iterator.prototype.leftSpan = function () {
  this.index = this.index - this.factor / 2 + 1;
  this.offset = this.index / 2;
  this.factor = 2;
  return this.index;
};

Iterator.prototype.rightSpan = function () {
  this.index = this.index + this.factor / 2 - 1;
  this.offset = this.index / 2;
  this.factor = 2;
  return this.index;
};

Iterator.prototype.leftChild = function () {
  if (this.factor === 2) return this.index;
  this.factor /= 2;
  this.index -= this.factor / 2;
  this.offset *= 2;
  return this.index;
};

Iterator.prototype.rightChild = function () {
  if (this.factor === 2) return this.index;
  this.factor /= 2;
  this.index += this.factor / 2;
  this.offset = 2 * this.offset + 1;
  return this.index;
};

Iterator.prototype.nextTree = function () {
  this.index = this.index + this.factor / 2 + 1;
  this.offset = this.index / 2;
  this.factor = 2;
  return this.index;
};

Iterator.prototype.prevTree = function () {
  if (!this.offset) {
    this.index = 0;
    this.factor = 2;
  } else {
    this.index = this.index - this.factor / 2 - 1;
    this.offset = this.index / 2;
    this.factor = 2;
  }

  return this.index;
};

Iterator.prototype.fullRoot = function (index) {
  if (index <= this.index || (this.index & 1) > 0) return false;

  while (index > this.index + this.factor + this.factor / 2) {
    this.index += this.factor / 2;
    this.factor *= 2;
    this.offset /= 2;
  }

  return true;
};

},{}],181:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach(obj, fn, ctx) {
  if (toString.call(fn) !== '[object Function]') {
    throw new TypeError('iterator must be a function');
  }

  var l = obj.length;

  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};

},{}],182:[function(require,module,exports){
'use strict';
/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

},{}],183:[function(require,module,exports){
'use strict';

var implementation = require("./implementation");

module.exports = Function.prototype.bind || implementation;

},{"./implementation":182}],184:[function(require,module,exports){
// originally pulled out of simple-peer
module.exports = function getBrowserRTC() {
  if (typeof globalThis === 'undefined') return null;
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
  };
  if (!wrtc.RTCPeerConnection) return null;
  return wrtc;
};

},{}],185:[function(require,module,exports){
'use strict';

var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function (expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function () {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');

var hasOwn = require('has');

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

},{"function-bind":183,"has":188,"has-symbols":186}],186:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;

var hasSymbolSham = require("./shams");

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }

  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};

},{"./shams":187}],187:[function(require,module,exports){
'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

},{}],188:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":183}],189:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var Transform = require('readable-stream').Transform;

var inherits = require('inherits');

function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}

function HashBase(blockSize) {
  Transform.call(this);
  this._block = Buffer.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}

inherits(HashBase, Transform);

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null;

  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype._flush = function (callback) {
  var error = null;

  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data

  var block = this._block;
  var offset = 0;

  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];

    this._update();

    this._blockOffset = 0;
  }

  while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length


  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }

  return this;
};

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented');
};

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;

  var digest = this._digest();

  if (encoding !== undefined) digest = digest.toString(encoding); // reset state

  this._block.fill(0);

  this._blockOffset = 0;

  for (var i = 0; i < 4; ++i) this._length[i] = 0;

  return digest;
};

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};

module.exports = HashBase;

},{"inherits":279,"readable-stream":204,"safe-buffer":446}],190:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],191:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":193,"./_stream_writable":195,"_process":380,"dup":77,"inherits":279}],192:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":194,"dup":78,"inherits":279}],193:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":190,"./_stream_duplex":191,"./internal/streams/async_iterator":196,"./internal/streams/buffer_list":197,"./internal/streams/destroy":198,"./internal/streams/from":200,"./internal/streams/state":202,"./internal/streams/stream":203,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],194:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":190,"./_stream_duplex":191,"dup":80,"inherits":279}],195:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":190,"./_stream_duplex":191,"./internal/streams/destroy":198,"./internal/streams/state":202,"./internal/streams/stream":203,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],196:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":199,"_process":380,"dup":82}],197:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],198:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],199:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":190,"dup":85}],200:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],201:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":190,"./end-of-stream":199,"dup":87}],202:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":190,"dup":88}],203:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],204:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":191,"./lib/_stream_passthrough.js":192,"./lib/_stream_readable.js":193,"./lib/_stream_transform.js":194,"./lib/_stream_writable.js":195,"./lib/internal/streams/end-of-stream.js":199,"./lib/internal/streams/pipeline.js":201,"dup":90}],205:[function(require,module,exports){
var hash = exports;
hash.utils = require("./hash/utils");
hash.common = require("./hash/common");
hash.sha = require("./hash/sha");
hash.ripemd = require("./hash/ripemd");
hash.hmac = require("./hash/hmac"); // Proxy hash functions to the main object

hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":206,"./hash/hmac":207,"./hash/ripemd":208,"./hash/sha":209,"./hash/utils":216}],206:[function(require,module,exports){
'use strict';

var utils = require("./utils");

var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}

exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length; // Enough data, try updating

  if (this.pending.length >= this._delta8) {
    msg = this.pending; // Process pending data in blocks

    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = utils.join32(msg, 0, msg.length - r, this.endian);

    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);
  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;

  for (var i = 1; i < k; i++) res[i] = 0; // Append length


  len <<= 3;

  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++) res[i++] = 0;
  }

  return res;
};

},{"./utils":216,"minimalistic-assert":312}],207:[function(require,module,exports){
'use strict';

var utils = require("./utils");

var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}

module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize); // Add padding to key

  for (var i = key.length; i < this.blockSize; i++) key.push(0);

  for (i = 0; i < key.length; i++) key[i] ^= 0x36;

  this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a

  for (i = 0; i < key.length; i++) key[i] ^= 0x6a;

  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":216,"minimalistic-assert":312}],208:[function(require,module,exports){
'use strict';

var utils = require("./utils");

var common = require("./common");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160)) return new RIPEMD160();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.endian = 'little';
}

utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;

  for (var j = 0; j < 80; j++) {
    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }

  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
}

function K(j) {
  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
}

var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

},{"./common":206,"./utils":216}],209:[function(require,module,exports){
'use strict';

exports.sha1 = require("./sha/1");
exports.sha224 = require("./sha/224");
exports.sha256 = require("./sha/256");
exports.sha384 = require("./sha/384");
exports.sha512 = require("./sha/512");

},{"./sha/1":210,"./sha/224":211,"./sha/256":212,"./sha/384":213,"./sha/512":214}],210:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var common = require("../common");

var shaCommon = require("./common");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];

function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) W[i] = msg[start + i];

  for (; i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

},{"../common":206,"../utils":216,"./common":215}],211:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var SHA256 = require("./256");

function SHA224() {
  if (!(this instanceof SHA224)) return new SHA224();
  SHA256.call(this);
  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
}

utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');
};

},{"../utils":216,"./256":212}],212:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var common = require("../common");

var shaCommon = require("./common");

var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

function SHA256() {
  if (!(this instanceof SHA256)) return new SHA256();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}

utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) W[i] = msg[start + i];

  for (; i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert(this.k.length === W.length);

  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

},{"../common":206,"../utils":216,"./common":215,"minimalistic-assert":312}],213:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var SHA512 = require("./512");

function SHA384() {
  if (!(this instanceof SHA384)) return new SHA384();
  SHA512.call(this);
  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
}

utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":216,"./512":214}],214:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var common = require("../common");

var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

function SHA512() {
  if (!(this instanceof SHA512)) return new SHA512();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
  this.k = sha512_K;
  this.W = new Array(160);
}

utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W; // 32 x 32bit words

  for (var i = 0; i < 32; i++) W[i] = msg[start + i];

  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2

    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14]; // i - 7

    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15

    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32]; // i - 16

    var c3_lo = W[i - 31];
    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert(this.k.length === W.length);

  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ ~xh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ ~xl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ xh & zh ^ yh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ xl & zl ^ yl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2); // 34

  var c2_hi = rotr64_hi(xl, xh, 7); // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2); // 34

  var c2_lo = rotr64_lo(xl, xh, 7); // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9); // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9); // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29); // 61

  var c2_hi = shr64_hi(xh, xl, 6);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29); // 61

  var c2_lo = shr64_lo(xh, xl, 6);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

},{"../common":206,"../utils":216,"minimalistic-assert":312}],215:[function(require,module,exports){
'use strict';

var utils = require("../utils");

var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0) return ch32(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32(x, y, z);
}

exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return x & y ^ ~x & z;
}

exports.ch32 = ch32;

function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}

exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}

exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}

exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}

exports.g1_256 = g1_256;

},{"../utils":216}],216:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }

  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }

  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;

      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);

        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;

      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
  }

  return res;
}

exports.toArray = toArray;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

  return res;
}

exports.toHex = toHex;

function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}

exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';

  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }

  return res;
}

exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}

exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);

  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }

  return res;
}

exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);

  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];

    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }

  return res;
}

exports.split32 = split32;

function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}

exports.rotr32 = rotr32;

function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}

exports.rotl32 = rotl32;

function sum32(a, b) {
  return a + b >>> 0;
}

exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return a + b + c >>> 0;
}

exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}

exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}

exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}

exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}

exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}

exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}

exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}

exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}

exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}

exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}

exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}

exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.shr64_lo = shr64_lo;

},{"inherits":279,"minimalistic-assert":312}],217:[function(require,module,exports){
/* eslint-disable camelcase */
var {
  sodium_malloc,
  sodium_memzero
} = require('sodium-universal/memory');

var {
  crypto_generichash,
  crypto_generichash_batch
} = require('sodium-universal/crypto_generichash');

var assert = require('nanoassert');

var HASHLEN = 64;
var BLOCKLEN = 128;
var scratch = sodium_malloc(BLOCKLEN * 3);
var HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1);
var OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2);
var InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3); // Post-fill is done in the cases where someone caught an exception that
// happened before we were able to clear data at the end

module.exports = function hmac(out, data, key) {
  assert(out.byteLength === HASHLEN);
  assert(key.byteLength != null);
  assert(Array.isArray(data) ? data.every(d => d.byteLength != null) : data.byteLength != null);

  if (key.byteLength > BLOCKLEN) {
    crypto_generichash(HMACKey.subarray(0, HASHLEN), key);
    sodium_memzero(HMACKey.subarray(HASHLEN));
  } else {
    // Covers key <= BLOCKLEN
    HMACKey.set(key);
    sodium_memzero(HMACKey.subarray(key.byteLength));
  }

  for (var i = 0; i < HMACKey.byteLength; i++) {
    OuterKeyPad[i] = 0x5c ^ HMACKey[i];
    InnerKeyPad[i] = 0x36 ^ HMACKey[i];
  }

  sodium_memzero(HMACKey);
  crypto_generichash_batch(out, [InnerKeyPad].concat(data));
  sodium_memzero(InnerKeyPad);
  crypto_generichash_batch(out, [OuterKeyPad].concat(out));
  sodium_memzero(OuterKeyPad);
};

module.exports.BYTES = HASHLEN;
module.exports.KEYBYTES = BLOCKLEN;

},{"nanoassert":319,"sodium-universal/crypto_generichash":527,"sodium-universal/memory":544}],218:[function(require,module,exports){
'use strict';

var hash = require('hash.js');

var utils = require('minimalistic-crypto-utils');

var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._init(entropy, nonce, pers);
}

module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);

  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);

  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);

  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));

  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding

  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  } // Optional additional data


  if (add) {
    add = utils.toArray(add, addEnc || 'hex');

    this._update(add);
  }

  var temp = [];

  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);

  this._update(add);

  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":205,"minimalistic-assert":312,"minimalistic-crypto-utils":313}],219:[function(require,module,exports){
const assert = require('assert');

const {
  Readable
} = require('readable-stream');

module.exports = (feed, opts) => new HypercoreByteStream(feed, opts);

class HypercoreByteStream extends Readable {
  constructor(opts) {
    super({ ...opts,
      encoding: null
    });
    opts = opts || {};
    this.feed = null;
    this.bytesRead = 0;
    this.pending = true;
    this._range = null;
    this._downloadRange = null;
    this._offset = 0;
    this._opened = false;
    this._resume = false;
    this._ended = false;
    this._downloaded = false;
    this._ifAvailable = false;

    if (opts.feed) {
      this.start(opts);
    }
  }

  start({
    feed,
    blockOffset,
    blockLength,
    byteOffset,
    byteLength,
    ifAvailable
  } = {}) {
    assert(!this.feed, 'Can only provide options once (in the constructor, or asynchronously).');
    assert(feed, 'Must provide a feed');
    assert(!this._opened, 'Cannot call start multiple after streaming has started.');
    assert(!blockOffset || blockOffset >= 0, 'start must be >= 0');
    assert(!blockLength || blockLength >= 0, 'end must be >= 0');
    assert(!byteLength || byteLength >= -1, 'length must be a >= 0 or -1');
    assert(byteLength !== -1 && byteOffset !== -1 || byteLength === -1, 'byteLength requires byteOffset');
    this.feed = feed;
    this._ifAvailable = ifAvailable;
    this._range = {
      start: blockOffset || 0,
      end: blockOffset !== undefined && blockLength !== undefined ? blockOffset + blockLength : -1,
      byteOffset: byteOffset || 0,
      length: blockLength === 0 ? 0 : byteLength !== undefined ? byteLength : -1
    };

    if (this._resume) {
      return this._read(0);
    }
  }

  _seek(offset, cb) {
    // end + 1 so we can support seeks to the end of the file
    this.feed.seek(offset, {
      start: this._range.start,
      end: this._range.end + 1,
      ifAvailable: this._ifAvailable
    }, cb);
  }

  _open(size) {
    const self = this;
    let missing = 1;
    this._opened = true;
    this.feed.ready(err => {
      if (err || this.destroyed) return this.destroy(err);
      this.open = true;
      if (this._range.byteOffset === -1) return onstart(null, this._range.start, 0);

      this._seek(this._range.byteOffset, onstart);
    });

    function onend(err, index, offset) {
      if (err || !self._range) return;
      if (self._ended || self.destroyed) return;
      missing++;
      self.feed.undownload(self._downloadRange);
      self._downloadRange = self.feed.download({
        start: self._range.start,
        end: offset ? index + 1 : index,
        // if offset === 0 we should stop just before reading index
        linear: true
      }, ondownload);
      self._range = { ...self._range,
        ...self._downloadRange
      };
      self.pending = false;

      self._read(size);
    }

    function onstart(err, index, off) {
      if (err) return self.destroy(err);
      if (self._ended || self.destroyed) return;
      self._range.start = index;
      self._offset = off;
      self._downloadRange = self.feed.download({ ...self._range,
        linear: true
      }, ondownload);
      self._range = { ...self._range,
        ...self._downloadRange
      };

      if (self._range.length > -1) {
        self._seek(self._range.byteOffset + self._range.length, onend);
      } else {
        self.pending = false;

        self._read(size);
      }
    }

    function ondownload(err) {
      if (--missing) return;
      if (err && !self._ended && !self._downloaded && err.code !== 'ECANCELED') self.destroy(err);else self._downloaded = true;
    }
  }

  _cleanup() {
    if (this._range && this._opened) {
      if (this._downloadRange) {
        this.feed.undownload(this._downloadRange);
        this._downloadRange = null;
      }

      this._range = null;
      this._ended = true;
    }
  }

  _destroy(err, cb) {
    this._cleanup();

    return cb(err);
  }

  _read(size) {
    if (!this._range) {
      this._resume = true;
      return;
    } else if (this._resume) {
      this._resume = false;
    }

    if (this._ended) return this.push(null);

    if (this._range.length === 0) {
      this._cleanup();

      return this.push(null);
    }

    if (!this._opened) {
      return this._open(size);
    }

    if (this._range.end !== -1 && this._range.start >= this._range.end || this._range.length === 0) {
      this._cleanup();

      return this.push(null);
    }

    this.feed.get(this._range.start++, {
      ifAvailable: this._ifAvailable,
      wait: !this._downloaded
    }, (err, data) => {
      if (err || this.destroyed) return this.destroy(err);
      if (this._offset) data = data.slice(this._offset);
      this._offset = 0;

      if (this._range.length > -1) {
        if (this._range.length < data.length) data = data.slice(0, this._range.length);
        this._range.length -= data.length;
      }

      if (!data) {
        this._cleanup();
      }

      this.bytesRead += data.length;
      this.push(data);
    });
  }

}

},{"assert":33,"readable-stream":234}],220:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],221:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":223,"./_stream_writable":225,"_process":380,"dup":77,"inherits":279}],222:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":224,"dup":78,"inherits":279}],223:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":220,"./_stream_duplex":221,"./internal/streams/async_iterator":226,"./internal/streams/buffer_list":227,"./internal/streams/destroy":228,"./internal/streams/from":230,"./internal/streams/state":232,"./internal/streams/stream":233,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],224:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":220,"./_stream_duplex":221,"dup":80,"inherits":279}],225:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":220,"./_stream_duplex":221,"./internal/streams/destroy":228,"./internal/streams/state":232,"./internal/streams/stream":233,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],226:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":229,"_process":380,"dup":82}],227:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],228:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],229:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":220,"dup":85}],230:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],231:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":220,"./end-of-stream":229,"dup":87}],232:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":220,"dup":88}],233:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],234:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":221,"./lib/_stream_passthrough.js":222,"./lib/_stream_readable.js":223,"./lib/_stream_transform.js":224,"./lib/_stream_writable.js":225,"./lib/internal/streams/end-of-stream.js":229,"./lib/internal/streams/pipeline.js":231,"dup":90}],235:[function(require,module,exports){
const DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16;

class NamespacedCache {
  constructor(parent, name) {
    this.name = name;
    this.parent = parent;
  }

  get _info() {
    return this.parent._info;
  }

  set(key, value) {
    return this.parent._set(this.name, key, value);
  }

  del(key) {
    return this.parent._del(this.name, key);
  }

  get(key) {
    return this.parent._get(this.name, key);
  }

}

module.exports = class HypercoreCache {
  constructor(opts = {}) {
    this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE;
    this.onEvict = opts.onEvict;
    this.estimateSize = opts.estimateSize || defaultSize;
    this._nextNamespace = 0;
    this.defaultCache = new NamespacedCache(this, this._nextNamespace++);
    this._stale = null;
    this._fresh = new Map();
    this._freshByteSize = 0;
    this._staleByteSize = 0;
  }

  get _info() {
    return {
      freshByteSize: this._freshByteSize,
      staleByteSize: this._staleByteSize,
      staleEntries: this._stale ? this._stale.size : 0,
      freshEntries: this._fresh.size,
      byteSize: this.byteSize
    };
  }

  _prefix(namespace, key) {
    return namespace + ':' + key;
  }

  _gc() {
    if (this.onEvict && this._staleByteSize > 0) this.onEvict(this._stale);
    this._stale = this._fresh;
    this._fresh = new Map();
    this._staleByteSize = this._freshByteSize;
    this._freshByteSize = 0;
  }

  _get(namespace, key, prefixedKey) {
    if (!prefixedKey) prefixedKey = this._prefix(namespace, key);
    return this._fresh.get(prefixedKey) || this._stale && this._stale.get(prefixedKey);
  }

  _set(namespace, key, value) {
    const valueSize = this.estimateSize(value);

    const prefixedKey = this._prefix(namespace, key);

    if (this._freshByteSize + valueSize > this.maxByteSize) {
      this._gc();
    }

    this._fresh.set(prefixedKey, value);

    this._freshByteSize += valueSize;
  }

  _del(namespace, key) {
    const prefixedKey = this._prefix(namespace, key);

    let val = this._stale && this._stale.get(prefixedKey);

    if (val) {
      this._stale.delete(prefixedKey);

      this._staleByteSize -= this.estimateSize(val);
    }

    val = this._fresh.get(prefixedKey);

    if (val) {
      this._fresh.delete(prefixedKey);

      this._freshByteSize -= this.estimateSize(val);
    }
  }

  get byteSize() {
    return this._freshByteSize + this._staleByteSize;
  }

  namespace() {
    const cache = new NamespacedCache(this, this._nextNamespace++);
    return cache;
  }

  set(key, value) {
    return this.defaultCache.set(key, value);
  }

  del(key) {
    return this.defaultCache.del(key);
  }

  get(key) {
    return this.defaultCache.get(key);
  }

};

function defaultSize() {
  // Return an estimate of the object overhead, without being clever here.
  // (You should pass in a size estimator)
  return 1024;
}

},{}],236:[function(require,module,exports){
(function (Buffer){(function (){
const sodium = require('sodium-universal');

const uint64be = require('uint64be'); // https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack


const LEAF_TYPE = Buffer.from([0]);
const PARENT_TYPE = Buffer.from([1]);
const ROOT_TYPE = Buffer.from([2]);
const CAP_TYPE = Buffer.from([3]);
const HYPERCORE = Buffer.from('hypercore');
const HYPERCORE_CAP = Buffer.from('hypercore capability');

exports.writerCapability = function (key, secretKey, split) {
  if (!split) return null;
  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [CAP_TYPE, HYPERCORE_CAP, split.tx.slice(0, 32), key], split.rx.slice(0, 32));
  return exports.sign(out, secretKey);
};

exports.verifyRemoteWriterCapability = function (key, cap, split) {
  if (!split) return null;
  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [CAP_TYPE, HYPERCORE_CAP, split.rx.slice(0, 32), key], split.tx.slice(0, 32));
  return exports.verify(out, cap, key);
}; // TODO: add in the CAP_TYPE in a future version


exports.capability = function (key, split) {
  if (!split) return null;
  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [HYPERCORE_CAP, split.tx.slice(0, 32), key], split.rx.slice(0, 32));
  return out;
}; // TODO: add in the CAP_TYPE in a future version


exports.remoteCapability = function (key, split) {
  if (!split) return null;
  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [HYPERCORE_CAP, split.rx.slice(0, 32), key], split.tx.slice(0, 32));
  return out;
};

exports.keyPair = function (seed) {
  const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
  const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES);
  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);else sodium.crypto_sign_keypair(publicKey, secretKey);
  return {
    publicKey,
    secretKey
  };
};

exports.validateKeyPair = function (keyPair) {
  const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey);
  return pk.equals(keyPair.publicKey);
};

exports.sign = function (message, secretKey) {
  const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES);
  sodium.crypto_sign_detached(signature, message, secretKey);
  return signature;
};

exports.verify = function (message, signature, publicKey) {
  return sodium.crypto_sign_verify_detached(signature, message, publicKey);
};

exports.data = function (data) {
  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [LEAF_TYPE, encodeUInt64(data.length), data]);
  return out;
};

exports.leaf = function (leaf) {
  return exports.data(leaf.data);
};

exports.parent = function (a, b) {
  if (a.index > b.index) {
    const tmp = a;
    a = b;
    b = tmp;
  }

  const out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, [PARENT_TYPE, encodeUInt64(a.size + b.size), a.hash, b.hash]);
  return out;
};

exports.tree = function (roots, out) {
  const buffers = new Array(3 * roots.length + 1);
  var j = 0;
  buffers[j++] = ROOT_TYPE;

  for (var i = 0; i < roots.length; i++) {
    const r = roots[i];
    buffers[j++] = r.hash;
    buffers[j++] = encodeUInt64(r.index);
    buffers[j++] = encodeUInt64(r.size);
  }

  if (!out) out = Buffer.allocUnsafe(32);
  sodium.crypto_generichash_batch(out, buffers);
  return out;
};

exports.signable = function (roots, length) {
  const out = Buffer.allocUnsafe(40);
  if (Buffer.isBuffer(roots)) roots.copy(out);else exports.tree(roots, out.slice(0, 32));
  uint64be.encode(length, out.slice(32));
  return out;
};

exports.randomBytes = function (n) {
  const buf = Buffer.allocUnsafe(n);
  sodium.randombytes_buf(buf);
  return buf;
};

exports.discoveryKey = function (publicKey) {
  const digest = Buffer.allocUnsafe(32);
  sodium.crypto_generichash(digest, HYPERCORE, publicKey);
  return digest;
};

if (sodium.sodium_free) {
  exports.free = function (secureBuf) {
    if (secureBuf.secure) sodium.sodium_free(secureBuf);
  };
} else {
  exports.free = function () {};
}

function encodeUInt64(n) {
  return uint64be.encode(n, Buffer.allocUnsafe(8));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"sodium-universal":541,"uint64be":237}],237:[function(require,module,exports){
(function (Buffer){(function (){
const UINT_32_MAX = Math.pow(2, 32);

exports.encodingLength = function () {
  return 8;
};

exports.encode = function (num, buf, offset) {
  if (!buf) buf = Buffer.allocUnsafe(8);
  if (!offset) offset = 0;
  const top = Math.floor(num / UINT_32_MAX);
  const rem = num - top * UINT_32_MAX;
  buf.writeUInt32BE(top, offset);
  buf.writeUInt32BE(rem, offset + 4);
  return buf;
};

exports.decode = function (buf, offset) {
  if (!offset) offset = 0;
  const top = buf.readUInt32BE(offset);
  const rem = buf.readUInt32BE(offset + 4);
  return top * UINT_32_MAX + rem;
};

exports.encode.bytes = 8;
exports.decode.bytes = 8;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],238:[function(require,module,exports){
(function (Buffer){(function (){
const RAF = require('random-access-file');

let lock = null;
let sparse = null;

try {
  const fsctl = require('fsctl');

  lock = fsctl.lock;
  sparse = null; // fsctl.sparse, disable until we investigate the regression on windows
} catch (_) {}

module.exports = defaultStorage;

function defaultStorage(name, opts) {
  // make it easier to cache tree nodes without the big unsafe arraybuffer attached
  if (isTree(name)) return new RAF(name, {
    sparse,
    alloc: Buffer.alloc,
    ...opts
  });
  if (!isBitfield(name)) return new RAF(name, {
    sparse,
    ...opts
  });
  return new RAF(name, {
    lock,
    sparse,
    ...opts
  });
}

function isTree(name) {
  return name === 'tree' || name.endsWith('/tree');
}

function isBitfield(name) {
  return name === 'bitfield' || name.endsWith('/bitfield');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"fsctl":48,"random-access-file":416}],239:[function(require,module,exports){
const SHP = require('simple-hypercore-protocol');

const crypto = require('hypercore-crypto');

const timeout = require('timeout-refresh');

const inspect = require('inspect-custom-symbol');

const Nanoguard = require('nanoguard');

const pretty = require('pretty-hash');

const Message = require('abstract-extension');

const {
  Duplex
} = require('streamx');

const debug = require('debug')('hypercore-protocol');

class StreamExtension extends Message {
  send(message) {
    const stream = this.local.handlers;

    if (stream._changes !== this.local.changes) {
      stream._changes = this.local.changes;
      stream.state.options(0, {
        extensions: this.local.names()
      });
    }

    return stream.state.extension(0, this.id, this.encode(message));
  }

}

class Channelizer {
  constructor(stream, {
    encrypted,
    noise,
    keyPair
  }) {
    this.stream = stream;
    this.created = new Map();
    this.local = [null];
    this.remote = [null];
    this.noise = !(noise === false && encrypted === false);
    this.encrypted = encrypted !== false;
    this.keyPair = keyPair;
  }

  allocLocal() {
    const id = this.local.indexOf(null);
    if (id > 0) return id;
    this.local.push(null);
    return this.local.length - 1;
  }

  attachLocal(ch) {
    const id = this.allocLocal();
    this.local[id] = ch;
    ch.localId = id;
  }

  attachRemote(ch, id) {
    if (this.remote.length === id) this.remote.push(null);
    this.remote[id] = ch;
    ch.remoteId = id;
  }

  detachChannel(ch) {
    if (ch.localId > -1 && this.local[ch.localId] === ch) {
      this.local[ch.localId] = null;
      ch.localId = -1;
      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose();
    }

    if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {
      this.remote[ch.remoteId] = null;
    }

    const hex = ch.discoveryKey.toString('hex');
    if (this.created.get(hex) === ch) this.created.delete(hex);
  }

  getChannel(dk) {
    return this.created.get(dk.toString('hex'));
  }

  createChannel(dk) {
    const hex = dk.toString('hex');
    const old = this.created.get(hex);
    if (old) return old;
    const fresh = new Channel(this.stream.state, this.stream, dk);
    this.created.set(hex, fresh);
    return fresh;
  }

  onauthenticate(key, done) {
    if (this.stream.handlers && this.stream.handlers.onauthenticate) this.stream.handlers.onauthenticate(key, done);else done(null);
  }

  onhandshake() {
    debug('recv handshake');
    if (this.stream.handlers && this.stream.handlers.onhandshake) this.stream.handlers.onhandshake();
    this.stream.emit('handshake');
  }

  onopen(channelId, message) {
    debug('recv open', channelId, message);
    const ch = this.createChannel(message.discoveryKey);
    ch.remoteCapability = message.capability;
    this.attachRemote(ch, channelId);

    if (ch.localId === -1) {
      if (this.stream.handlers.ondiscoverykey) this.stream.handlers.ondiscoverykey(ch.discoveryKey);
      this.stream.emit('discovery-key', ch.discoveryKey);
    } else {
      if (this.noise && !ch.remoteVerified) {
        // We are leaking metadata here that the remote cap was bad which means the remote prob can figure
        // out that we indeed had the key. Since we were the one to initialise the channel that's ok, as
        // that already kinda leaks that.
        this.stream.destroy(new Error('Invalid remote channel capability'));
        return;
      }

      this.stream.emit('duplex-channel', ch);
    }

    if (ch.handlers && ch.handlers.onopen) ch.handlers.onopen();
    if (this.stream.handlers.onremoteopen) this.stream.handlers.onremoteopen(ch.discoveryKey);
    this.stream.emit('remote-open', ch.discoveryKey);
  }

  onoptions(channelId, message) {
    debug('recv options', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onoptions) ch.handlers.onoptions(message);else if (channelId === 0 && !ch) this.stream._updateExtensions(message.extensions);
  }

  onstatus(channelId, message) {
    debug('recv status', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onstatus) ch.handlers.onstatus(message);
  }

  onhave(channelId, message) {
    debug('recv have', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onhave) ch.handlers.onhave(message);
  }

  onunhave(channelId, message) {
    debug('recv unhave', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onunhave) ch.handlers.onunhave(message);
  }

  onwant(channelId, message) {
    debug('recv want', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onwant) ch.handlers.onwant(message);
  }

  onunwant(channelId, message) {
    debug('recv unwant', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onunwant) ch.handlers.onunwant(message);
  }

  onrequest(channelId, message) {
    debug('recv request', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onrequest) ch.handlers.onrequest(message);
  }

  oncancel(channelId, message) {
    debug('recv cancel', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.oncancel) ch.handlers.oncancel(message);
  }

  ondata(channelId, message) {
    debug('recv data', channelId, message);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.ondata) ch.handlers.ondata(message);
  }

  onextension(channelId, id, buf) {
    debug('recv extension', channelId, id);
    const ch = this.remote[channelId];
    if (ch && ch.handlers && ch.handlers.onextension) ch.handlers.onextension(id, buf);else if (channelId === 0 && !ch) this.stream.remoteExtensions.onmessage(id, buf);
  }

  onclose(channelId, message) {
    debug('recv close', channelId, message);
    let ch = channelId < this.remote.length ? this.remote[channelId] : null;

    if (ch) {
      this.remote[channelId] = null;
    } else if (message.discoveryKey) {
      ch = this.getChannel(message.discoveryKey);
    }

    if (!ch) return;

    if (ch.localId > -1 && this.local[ch.localId] === ch) {
      this.local[ch.localId] = null;
      ch.state.close(ch.localId, {});
      ch.localId = -1;
      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose();
    }

    if (this.stream.handlers && this.stream.handlers.onchannelclose) {
      this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
    }

    const hex = ch.discoveryKey.toString('hex');
    if (this.created.get(hex) === ch) this.created.delete(hex);

    this.stream._prefinalize();
  }

  onmissing(bytes) {
    if (this.stream._utp === null) return;

    this.stream._utp.setContentSize(bytes);
  } // called by the state machine


  send(data) {
    if (this.stream.keepAlive !== null) this.stream.keepAlive.refresh();
    this.stream.bytesSent += data.length;
    return this.stream.push(data);
  } // called by the state machine


  destroy(err) {
    this.stream.destroy(err);
    this.local = [];
    this.remote = [];

    for (const ch of this.created.values()) {
      const closed = ch.localId === -1;
      ch.localId = ch.remoteId = -1;
      if (!closed && ch.handlers && ch.handlers.onclose) ch.handlers.onclose();

      if (this.stream.handlers && this.stream.handlers.onchannelclose) {
        this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
      }
    }

    this.created.clear();
  }

}

class Channel {
  constructor(state, stream, dk) {
    this.key = null;
    this.discoveryKey = dk;
    this.localId = -1;
    this.remoteId = -1;
    this.remoteCapability = null;
    this.handlers = null;
    this.state = state;
    this.stream = stream;
  }

  get opened() {
    return this.localId > -1;
  }

  get closed() {
    return this.localId === -1;
  }

  get remoteOpened() {
    return this.remoteId > -1;
  }

  get remoteVerified() {
    return this.localId > -1 && this.remoteId > -1 && !!this.remoteCapability && this.remoteCapability.equals(this.state.remoteCapability(this.key));
  }

  options(message) {
    debug('send options', message);
    return this.state.options(this.localId, message);
  }

  status(message) {
    debug('send status', message);
    return this.state.status(this.localId, message);
  }

  have(message) {
    debug('send have', message);
    return this.state.have(this.localId, message);
  }

  unhave(message) {
    debug('send unhave', message);
    return this.state.unhave(this.localId, message);
  }

  want(message) {
    debug('send want', message);
    return this.state.want(this.localId, message);
  }

  unwant(message) {
    debug('send unwant', message);
    return this.state.unwant(this.localId, message);
  }

  request(message) {
    debug('send request', message);
    return this.state.request(this.localId, message);
  }

  cancel(message) {
    debug('send cancel', message);
    return this.state.cancel(this.localId, message);
  }

  data(message) {
    debug('send data', message);
    return this.state.data(this.localId, message);
  }

  extension(id, buf) {
    debug('send extension', id);
    return this.state.extension(this.localId, id, buf);
  }

  close() {
    debug('send close');
    if (this.closed) return;
    const localId = this.localId;
    this.stream.channelizer.detachChannel(this);
    this.state.close(localId, {});

    this.stream._prefinalize();
  }

  destroy(err) {
    this.stream.destroy(err);
  }

}

module.exports = class ProtocolStream extends Duplex {
  constructor(initiator, handlers = {}) {
    super();
    if (typeof initiator !== 'boolean') throw new Error('Must specify initiator boolean in replication stream');
    this.initiator = initiator;
    this.handlers = handlers;
    this.channelizer = new Channelizer(this, {
      encrypted: handlers.encrypted,
      noise: handlers.noise,
      keyPair: handlers.keyPair
    });
    this.state = new SHP(initiator, this.channelizer);
    this.live = !!handlers.live;
    this.timeout = null;
    this.keepAlive = null;
    this.prefinalize = new Nanoguard();
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.extensions = StreamExtension.createLocal(this);
    this.remoteExtensions = this.extensions.remote();
    this._utp = null;
    this._changes = 0;
    this.once('finish', this.push.bind(this, null));
    this.on('pipe', this._onpipe);

    if (handlers.timeout !== false && handlers.timeout !== 0) {
      const timeout = handlers.timeout || 20000;
      this.setTimeout(timeout, () => this.destroy(new Error('ETIMEDOUT')));
      this.setKeepAlive(Math.ceil(timeout / 2));
    }
  }

  registerExtension(name, handlers) {
    return this.extensions.add(name, handlers);
  }

  [inspect](depth, opts) {
    let indent = '';

    if (typeof opts.indentationLvl === 'number') {
      while (indent.length < opts.indentationLvl) indent += ' ';
    }

    return 'HypercoreProtocolStream(\n' + indent + '  publicKey: ' + opts.stylize(this.publicKey && pretty(this.publicKey), 'string') + '\n' + indent + '  remotePublicKey: ' + opts.stylize(this.remotePublicKey && pretty(this.remotePublicKey), 'string') + '\n' + indent + '  remoteAddress: ' + opts.stylize(this.remoteAddress, 'string') + '\n' + indent + '  remoteType: ' + opts.stylize(this.remoteType, 'string') + '\n' + indent + '  live: ' + opts.stylize(this.live, 'boolean') + '\n' + indent + '  initiator: ' + opts.stylize(this.initiator, 'boolean') + '\n' + indent + '  channelCount: ' + opts.stylize(this.channelCount, 'number') + '\n' + indent + '  destroyed: ' + opts.stylize(this.destroyed, 'boolean') + '\n' + indent + '  prefinalized: ' + opts.stylize(!this.prefinalize.waiting, 'boolean') + '\n' + indent + '  bytesSent: ' + opts.stylize(this.bytesSent, 'number') + '\n' + indent + '  bytesReceived: ' + opts.stylize(this.bytesReceived, 'number') + '\n' + indent + ')';
  }

  static isProtocolStream(s) {
    return !!(s && typeof s.initiator === 'boolean' && typeof s.pipe === 'function' && s.state);
  }

  static keyPair(seed) {
    return SHP.keyPair(seed);
  }

  get remoteAddress() {
    const to = this._readableState.pipeTo;
    if (!to) return null;
    if (ProtocolStream.isProtocolStream(to)) return null;
    return to.remoteAddress;
  }

  get remoteType() {
    const to = this._readableState.pipeTo;
    if (!to) return null;
    if (to._utp) return 'utp';
    if (to.remoteAddress) return 'tcp';
    return 'unknown';
  }

  get publicKey() {
    return this.state.publicKey;
  }

  get remotePublicKey() {
    return this.state.remotePublicKey;
  }

  _onpipe(dest) {
    if (typeof dest.setContentSize === 'function') this._utp = dest;
  }

  _write(data, cb) {
    if (this.timeout !== null) this.timeout.refresh();
    this.bytesReceived += data.length;
    this.state.recv(data);
    cb(null);
  }

  _destroy(cb) {
    this._predestroy(); // make sure this always runs


    this.channelizer.destroy();
    this.state.destroy();
    cb(null);
  }

  _predestroy() {
    if (this.timeout !== null) {
      this.timeout.destroy();
      this.timeout = null;
    }

    if (this.keepAlive !== null) {
      this.keepAlive.destroy();
      this.keepAlive = null;
    }

    this.prefinalize.destroy();
  }

  _prefinalize() {
    this.emit('prefinalize');
    this.prefinalize.ready(() => {
      if (this.destroyed) return;
      if (this.channelCount) return;
      if (this.live) return;
      this.finalize();
    });
  }

  _updateExtensions(names) {
    this.remoteExtensions.update(names);
    if (this.handlers.onextensions) this.handlers.onextensions(names);
    this.emit('extensions', names);
  }

  remoteOpened(key) {
    const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
    return !!(ch && ch.remoteId > -1);
  }

  remoteVerified(key) {
    const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
    return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key));
  }

  opened(key) {
    const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
    return !!(ch && ch.localId > -1);
  }

  ping() {
    return this.state.ping();
  }

  setKeepAlive(ms) {
    if (this.keepAlive) this.keepAlive.destroy();

    if (!ms) {
      this.keepAlive = null;
      return;
    }

    this.keepAlive = timeout(ms, ping, this);

    function ping() {
      this.ping();
      this.keepAlive = timeout(ms, ping, this);
    }
  }

  setTimeout(ms, ontimeout) {
    if (this.timeout) this.timeout.destroy();

    if (!ms) {
      this.timeout = null;
      return;
    }

    this.timeout = timeout(ms, this.emit.bind(this, 'timeout'));
    if (ontimeout) this.once('timeout', ontimeout);
  }

  get channelCount() {
    return this.channelizer.created.size;
  }

  get channels() {
    return this.channelizer.created.values();
  }

  open(key, handlers) {
    const discoveryKey = crypto.discoveryKey(key);
    const ch = this.channelizer.createChannel(discoveryKey);

    if (ch.key === null) {
      ch.key = key;
      this.channelizer.attachLocal(ch);
      this.state.open(ch.localId, {
        key,
        discoveryKey
      });
    }

    if (handlers) ch.handlers = handlers;
    if (ch.remoteId > -1) this.emit('duplex-channel', ch);
    return ch;
  }

  close(discoveryKey) {
    const ch = this.channelizer.getChannel(discoveryKey);

    if (ch && ch.localId > -1) {
      ch.close();
      return;
    }

    this.state.close(this.channelizer.allocLocal(), {
      discoveryKey
    });
  }

  finalize() {
    this.push(null);
  }

};

},{"abstract-extension":14,"debug":131,"hypercore-crypto":236,"inspect-custom-symbol":280,"nanoguard":322,"pretty-hash":378,"simple-hypercore-protocol":469,"streamx":565,"timeout-refresh":570}],240:[function(require,module,exports){
const {
  Writable,
  Readable
} = require('streamx');

class WriteStream extends Writable {
  constructor(feed, opts) {
    super();
    this.feed = feed;
    this.maxBlockSize = opts && opts.maxBlockSize || 0;
  }

  _writev(batch, cb) {
    this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb);
  }

  _ensureMaxSize(batch) {
    for (let i = 0; i < batch.length; i++) {
      let blk = batch[i];

      if (blk.length > this.maxBlockSize) {
        const chunked = [];

        while (blk.length > this.maxBlockSize) {
          chunked.push(blk.slice(0, this.maxBlockSize));
          blk = blk.slice(this.maxBlockSize);
        }

        if (blk.length) chunked.push(blk);
        batch.splice(i, 1, ...chunked);
        i += chunked.length - 1;
      }
    }

    return batch;
  }

}

class ReadStream extends Readable {
  constructor(feed, opts = {}) {
    super();
    this.feed = feed;
    this.start = opts.start || 0;
    this.end = typeof opts.end === 'number' ? opts.end : -1;
    this.live = !!opts.live;
    this.snapshot = opts.snapshot !== false;
    this.tail = !!opts.tail;
    this.index = this.start;
    this.options = {
      wait: opts.wait !== false,
      ifAvailable: !!opts.ifAvailable,
      valueEncoding: opts.valueEncoding
    };
  }

  _open(cb) {
    this.feed.ready(err => {
      if (err) return cb(err);

      if (this.end === -1) {
        if (this.live) this.end = Infinity;else if (this.snapshot) this.end = this.feed.length;
        if (this.start > this.end) this.push(null);
      }

      if (this.tail) this.start = this.feed.length;
      this.index = this.start;
      cb(null);
    });
  }

  _read(cb) {
    if (this.index === this.end || this.end === -1 && this.index >= this.feed.length) {
      this.push(null);
      return cb(null);
    }

    this.feed.get(this.index++, this.options, (err, block) => {
      if (err) return cb(err);
      this.push(block);
      cb(null);
    });
  }

}

module.exports = {
  WriteStream,
  ReadStream
};

},{"streamx":565}],241:[function(require,module,exports){
(function (process,Buffer){(function (){
var low = require('last-one-wins');

var remove = require('unordered-array-remove');

var set = require('unordered-set');

var MerkleGenerator = require('merkle-tree-stream/generator');

var flat = require('flat-tree');

var codecs = require('codecs');

var batcher = require('atomic-batcher');

var inherits = require('inherits');

var bitfield = require("./lib/bitfield");

var sparseBitfield = require('sparse-bitfield');

var treeIndex = require("./lib/tree-index");

var storage = require("./lib/storage");

var crypto = require('hypercore-crypto');

var inspect = require('inspect-custom-symbol');

var pretty = require('pretty-hash');

var Nanoguard = require('nanoguard');

var safeBufferEquals = require("./lib/safe-buffer-equals");

var replicate = require("./lib/replicate");

var Protocol = require('hypercore-protocol');

var Message = require('abstract-extension');

var Nanoresource = require('nanoresource/emitter');

var defaultStorage = require('hypercore-default-storage');

var {
  WriteStream,
  ReadStream
} = require('hypercore-streams');

class Extension extends Message {
  broadcast(message) {
    const feed = this.local.handlers;
    const buf = this.encoding.encode(message);
    let broadcasted = false;

    for (const peer of feed.peers) {
      broadcasted = true;
      peer.extension(this.id, buf);
    }

    return broadcasted;
  }

  send(message, peer) {
    peer.extension(this.id, this.encode(message));
  }

}

var defaultCrypto = {
  sign(data, sk, cb) {
    return cb(null, crypto.sign(data, sk));
  },

  verify(sig, data, pk, cb) {
    return cb(null, crypto.verify(sig, data, pk));
  }

};
module.exports = Feed;

function Feed(createStorage, key, opts) {
  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts);
  Nanoresource.call(this);
  if (typeof createStorage === 'string') createStorage = defaultStorageDir(createStorage);
  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string');
  if (typeof key === 'string') key = Buffer.from(key, 'hex');

  if (!Buffer.isBuffer(key) && !opts) {
    opts = key;
    key = null;
  }

  if (!opts) opts = {};
  var self = this;
  var secretKey = opts.secretKey || null;
  if (typeof secretKey === 'string') secretKey = Buffer.from(secretKey, 'hex');
  this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair();
  this.live = opts.live !== false;
  this.sparse = !!opts.sparse;
  this.length = 0;
  this.byteLength = 0;
  this.maxRequests = opts.maxRequests || 16;
  this.key = key || opts.key || null;
  this.discoveryKey = this.key && crypto.discoveryKey(this.key);
  this.secretKey = secretKey;
  this.bitfield = null;
  this.tree = null;
  this.writable = !!opts.writable;
  this.readable = true;
  this.downloading = opts.downloading !== false;
  this.uploading = opts.uploading !== false;
  this.allowPush = !!opts.allowPush;
  this.peers = [];
  this.ifAvailable = new Nanoguard();
  this.extensions = Extension.createLocal(this); // set Feed as the handlers

  this.crypto = opts.crypto || defaultCrypto; // hooks

  this._onwrite = opts.onwrite || null;
  this._expectedLength = -1;
  this._indexing = !!opts.indexing;
  this._createIfMissing = opts.createIfMissing !== false;
  this._overwrite = !!opts.overwrite;
  this._storeSecretKey = opts.storeSecretKey !== false;
  this._alwaysIfAvailable = !!opts.ifAvailable;
  this._merkle = null;
  this._storage = storage(createStorage, opts);
  this._batch = batcher(this._onwrite ? workHook : work);
  this.timeouts = opts.timeouts || {
    get(cb) {
      cb(null);
    },

    update(cb) {
      cb(null);
    }

  };
  this._seq = 0;
  this._waiting = [];
  this._selections = [];
  this._reserved = sparseBitfield();
  this._synced = null;
  this._downloadingSet = typeof opts.downloading === 'boolean';
  this._stats = typeof opts.stats !== 'undefined' && !opts.stats ? null : {
    downloadedBlocks: 0,
    downloadedBytes: 0,
    uploadedBlocks: 0,
    uploadedBytes: 0
  };
  this._codec = toCodec(opts.valueEncoding);
  this._sync = low(sync);
  if (!this.sparse) this.download({
    start: 0,
    end: -1
  });

  if (this.sparse && opts.eagerUpdate) {
    this.update(function loop(err) {
      if (err) self.emit('update-error', err);
      self.update(loop);
    });
  } // open it right away


  this.open(onerror);

  function onerror(err) {
    if (err) self.emit('error', err);
  }

  function workHook(values, cb) {
    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb);

    self._appendHook(values, cb);
  }

  function work(values, cb) {
    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb);

    self._append(values, cb);
  }

  function sync(_, cb) {
    self._syncBitfield(cb);
  }
}

inherits(Feed, Nanoresource);
Feed.discoveryKey = crypto.discoveryKey;

Feed.prototype[inspect] = function (depth, opts) {
  var indent = '';

  if (typeof opts.indentationLvl === 'number') {
    while (indent.length < opts.indentationLvl) indent += ' ';
  }

  return 'Hypercore(\n' + indent + '  key: ' + opts.stylize(this.key && pretty(this.key), 'string') + '\n' + indent + '  discoveryKey: ' + opts.stylize(this.discoveryKey && pretty(this.discoveryKey), 'string') + '\n' + indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\n' + indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\n' + indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\n' + indent + '  length: ' + opts.stylize(this.length, 'number') + '\n' + indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\n' + indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\n' + indent + ')';
}; // TODO: instead of using a getter, update on remote-update/add/remove


Object.defineProperty(Feed.prototype, 'remoteLength', {
  enumerable: true,
  get: function () {
    var len = 0;

    for (var i = 0; i < this.peers.length; i++) {
      var remoteLength = this.peers[i].remoteLength;
      if (remoteLength > len) len = remoteLength;
    }

    return len;
  }
});
Object.defineProperty(Feed.prototype, 'stats', {
  enumerable: true,
  get: function () {
    if (!this._stats) return null;
    var peerStats = [];

    for (var i = 0; i < this.peers.length; i++) {
      var peer = this.peers[i];
      peerStats[i] = peer.stats;
    }

    return {
      peers: peerStats,
      totals: this._stats
    };
  }
});

Feed.prototype.replicate = function (initiator, opts) {
  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {
    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection
    this.download({
      start: 0,
      end: -1
    });
  }

  if (isOptions(initiator) && !opts) {
    opts = initiator;
    initiator = opts.initiator;
  }

  opts = opts || {};
  opts.stats = !!this._stats;
  opts.noise = !(opts.noise === false && opts.encrypted === false);
  var stream = replicate(this, initiator, opts);
  this.emit('replicating', stream);
  return stream;
};

Feed.prototype.registerExtension = function (name, handlers) {
  return this.extensions.add(name, handlers);
};

Feed.prototype.onextensionupdate = function () {
  for (const peer of this.peers) peer._updateOptions();
};

Feed.prototype.setDownloading = function (downloading) {
  if (this.downloading === downloading && this._downloadingSet) return;
  this.downloading = downloading;
  this._downloadingSet = true;
  this.ready(err => {
    if (err) return;

    for (const peer of this.peers) peer.setDownloading(this.downloading);
  });
};

Feed.prototype.setUploading = function (uploading) {
  if (uploading === this.uploading) return;
  this.uploading = uploading;
  this.ready(err => {
    if (err) return;

    for (const peer of this.peers) peer.setUploading(this.uploading);
  });
}; // Alias the nanoresource open method


Feed.prototype.ready = Feed.prototype.open;

Feed.prototype.update = function (opts, cb) {
  if (typeof opts === 'function') return this.update(-1, opts);
  if (typeof opts === 'number') opts = {
    minLength: opts
  };
  if (!opts) opts = {};
  if (!cb) cb = noop;
  var self = this;
  var len = typeof opts.minLength === 'number' ? opts.minLength : -1;
  this.ready(function (err) {
    if (err) return cb(err);
    if (len === -1) len = self.length + 1;
    if (self.length >= len) return cb(null);
    const ifAvailable = typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable;
    if (ifAvailable && self.writable && !opts.force) return cb(new Error('No update available from peers'));
    if (self.writable) cb = self._writeStateReloader(cb);
    var w = {
      hash: opts.hash !== false,
      bytes: 0,
      index: len - 1,
      options: opts,
      update: true,
      callback: cb
    };

    self._waiting.push(w);

    if (ifAvailable) self._ifAvailable(w, len);

    self._updatePeers();
  });
}; // Used to hint to the update guard if it can bail early


Feed.prototype.setExpectedLength = function (len) {
  this._expectedLength = len;
  this.ready(err => {
    if (err) return;
    this.ifAvailable.ready(() => {
      this._expectedLength = -1;
    });
    if (this._expectedLength === -1 || this._expectedLength > this.length) return;

    for (const w of this._waiting) {
      if (w.update && w.ifAvailable) w.callback(new Error('Expected length is less than current length'));
    }
  });
}; // Beware! This might break your core if you share forks with other people through replication


Feed.prototype.truncate = function (newLength, cb) {
  if (!cb) cb = noop;
  const self = this;
  this.ready(function (err) {
    if (err) return cb(err);

    self._roots(newLength, function (err, roots) {
      if (err) return cb(err);
      const oldLength = self.length;
      if (oldLength <= newLength) return cb(null);
      let byteLength = 0;

      for (const {
        size
      } of roots) byteLength += size;

      for (let i = oldLength; i < newLength; i++) self.data.set(i, false);

      self.byteLength = byteLength;
      self.length = newLength;
      self.tree.truncate(2 * newLength);
      self._merkle = new MerkleGenerator(crypto, roots);

      self._sync(null, function (err) {
        if (err) return cb(err);

        self._storage.deleteSignatures(newLength, oldLength, cb);
      });
    });
  });
};

Feed.prototype._ifAvailable = function (w, minLength) {
  var cb = w.callback;
  var called = false;
  var self = this;
  w.callback = done;
  w.ifAvailable = true;

  if (this._expectedLength > -1 && this._expectedLength <= this.length) {
    return process.nextTick(w.callback, new Error('Expected length is less than current length'));
  }

  this.timeouts.update(function () {
    if (self.closed) return done(new Error('Closed'));
    process.nextTick(readyNT, self.ifAvailable, function () {
      if (self.closed) return done(new Error('Closed'));
      if (self.length >= minLength || self.remoteLength >= minLength) return;
      done(new Error('No update available from peers'));
    });
  });

  function done(err) {
    if (called) return;
    called = true;

    var i = self._waiting.indexOf(w);

    if (i > -1) remove(self._waiting, i);
    cb(err);
  }
};

Feed.prototype._ifAvailableGet = function (w) {
  var cb = w.callback;
  var called = false;
  var self = this;
  w.callback = done;
  self.timeouts.get(function () {
    if (self.closed) return done(new Error('Closed'));
    process.nextTick(readyNT, self.ifAvailable, function () {
      if (self.closed) return done(new Error('Closed'));

      for (var i = 0; i < self.peers.length; i++) {
        var peer = self.peers[i];
        if (peer.remoteBitfield.get(w.index)) return;
      }

      done(new Error('Block not available from peers'));
    });
  });

  function done(err, data) {
    if (called) return;
    called = true;

    var i = self._waiting.indexOf(w);

    if (i > -1) remove(self._waiting, i);
    cb(err, data);
  }
}; // will reload the writable state. used by .update on a writable peer


Feed.prototype._writeStateReloader = function (cb) {
  var self = this;
  return function (err) {
    if (err) return cb(err);

    self._reloadMerkleState(cb);
  };
};

Feed.prototype._reloadMerkleState = function (cb) {
  var self = this;

  this._roots(self.length, function (err, roots) {
    if (err) return cb(err);
    self._merkle = new MerkleGenerator(crypto, roots);
    cb(null);
  });
};

Feed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {
  this._reloadMerkleState(function (err) {
    if (err) return cb(err);
    work(values, cb);
  });
};

Feed.prototype._open = function (cb) {
  var self = this;
  var generatedKey = false;
  var retryOpen = true; // TODO: clean up the duplicate code below ...

  this._storage.openKey(function (_, key) {
    if (key && !self._overwrite && !self.key) self.key = key;

    if (!self.key && self.live) {
      var keyPair = crypto.keyPair();
      self.secretKey = keyPair.secretKey;
      self.key = keyPair.publicKey;
      generatedKey = true;
    }

    self.discoveryKey = self.key && crypto.discoveryKey(self.key);

    self._storage.open({
      key: self.key,
      discoveryKey: self.discoveryKey
    }, onopen);
  });

  function onopen(err, state) {
    if (err) return cb(err); // if no key but we have data do a bitfield reset since we cannot verify the data.

    if (!state.key && state.bitfield.length) {
      self._overwrite = true;
    }

    if (self._overwrite) {
      state.bitfield = [];
      state.key = state.secretKey = null;
    }

    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield);
    self.tree = treeIndex(self.bitfield.tree);
    self.length = self.tree.blocks();
    self._seq = self.length;

    if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {
      return self._forceClose(cb, new Error('Another hypercore is stored here'));
    }

    if (state.key) self.key = state.key;
    if (state.secretKey) self.secretKey = state.secretKey;
    if (!self.length) return onsignature(null, null);

    self._storage.getSignature(self.length - 1, onsignature);

    function onsignature(_, sig) {
      if (self.length) self.live = !!sig;

      if ((generatedKey || !self.key) && !self._createIfMissing) {
        return self._forceClose(cb, new Error('No hypercore is stored here'));
      }

      if (!self.key && self.live) {
        var keyPair = crypto.keyPair();
        self.secretKey = keyPair.secretKey;
        self.key = keyPair.publicKey;
      }

      var writable = !!self.secretKey || self.key === null;
      if (!writable && self.writable) return self._forceClose(cb, new Error('Feed is not writable'));
      self.writable = writable;
      if (!self._downloadingSet) self.downloading = !writable;
      self.discoveryKey = self.key && crypto.discoveryKey(self.key);

      if (self._storeSecretKey && !self.secretKey) {
        self._storeSecretKey = false;
      }

      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key);
      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey));
      var missing = 1 + (shouldWriteKey ? 1 : 0) + (shouldWriteSecretKey ? 1 : 0) + (self._overwrite ? 1 : 0);
      var error = null;
      if (shouldWriteKey) self._storage.key.write(0, self.key, done);
      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done);

      if (self._overwrite) {
        self._storage.bitfield.del(32, Infinity, done);
      }

      done(null);

      function done(err) {
        if (err) error = err;
        if (--missing) return;
        if (error) return self._forceClose(cb, error);

        self._roots(self.length, onroots);
      }

      function onroots(err, roots) {
        if (err && retryOpen) {
          retryOpen = false;
          self.length--;

          self._storage.getSignature(self.length - 1, onsignature);

          return;
        }

        if (err) return self._forceClose(cb, err);
        self._merkle = new MerkleGenerator(crypto, roots);
        self.byteLength = roots.reduce(addSize, 0);
        self.emit('ready');
        cb(null);
      }
    }
  }
};

Feed.prototype.download = function (range, cb) {
  if (typeof range === 'function') return this.download(null, range);
  if (typeof range === 'number') range = {
    start: range,
    end: range + 1
  };
  if (Array.isArray(range)) range = {
    blocks: range
  };
  if (!range) range = {};
  if (!cb) cb = noop;
  if (!this.readable) return cb(new Error('Feed is closed')); // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so
  // this._updatePeers does this for us when there is a peer though, so not critical
  // We need range.start, end for the want messages so make sure to infer these
  // when blocks are passed and start,end is not set

  if (range.blocks && typeof range.start !== 'number') {
    var min = -1;
    var max = 0;

    for (var i = 0; i < range.blocks.length; i++) {
      const blk = range.blocks[i];
      if (min === -1 || blk < min) min = blk;
      if (blk >= max) max = blk + 1;
    }

    range.start = min === -1 ? 0 : min;
    range.end = max;
  }

  var sel = {
    _index: this._selections.length,
    hash: !!range.hash,
    iterator: null,
    start: range.start || 0,
    end: range.end || -1,
    want: 0,
    linear: !!range.linear,
    blocks: range.blocks || null,
    blocksDownloaded: 0,
    requested: 0,
    callback: cb
  };
  sel.want = toWantRange(sel.start);

  this._selections.push(sel);

  this._updatePeers();

  return sel;
};

Feed.prototype.undownload = function (range) {
  if (typeof range === 'number') range = {
    start: range,
    end: range + 1
  };
  if (!range) range = {};

  if (range.callback && range._index > -1) {
    set.remove(this._selections, range);
    process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'));
    return;
  }

  var start = range.start || 0;
  var end = range.end || -1;
  var hash = !!range.hash;
  var linear = !!range.linear;

  for (var i = 0; i < this._selections.length; i++) {
    var s = this._selections[i];

    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {
      set.remove(this._selections, s);
      process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'));
      return;
    }
  }
};

Feed.prototype.digest = function (index) {
  return this.tree.digest(2 * index);
};

Feed.prototype.proof = function (index, opts, cb) {
  if (typeof opts === 'function') return this.proof(index, null, opts);
  if (!this.opened) return this._readyAndProof(index, opts, cb);
  if (!opts) opts = {};
  var proof = this.tree.proof(2 * index, opts);
  if (!proof) return cb(new Error('No proof available for this index'));
  var needsSig = this.live && !!proof.verifiedBy;
  var pending = proof.nodes.length + (needsSig ? 1 : 0);
  var error = null;
  var signature = null;
  var nodes = new Array(proof.nodes.length);
  if (!pending) return cb(null, {
    nodes: nodes,
    signature: null
  });

  for (var i = 0; i < proof.nodes.length; i++) {
    this._storage.getNode(proof.nodes[i], onnode);
  }

  if (needsSig) {
    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature);
  }

  function onsignature(err, sig) {
    if (sig) signature = sig;
    onnode(err, null);
  }

  function onnode(err, node) {
    if (err) error = err;

    if (node) {
      nodes[proof.nodes.indexOf(node.index)] = node;
    }

    if (--pending) return;
    if (error) return cb(error);
    cb(null, {
      nodes: nodes,
      signature: signature
    });
  }
};

Feed.prototype._readyAndProof = function (index, opts, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    self.proof(index, opts, cb);
  });
};

Feed.prototype.put = function (index, data, proof, cb) {
  if (!this.opened) return this._readyAndPut(index, data, proof, cb);

  this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb);
};

Feed.prototype.cancel = function (start, end) {
  // TODO: use same argument scheme as download
  if (typeof start !== 'symbol') {
    if (!end) end = start + 1; // cancel these right away as .download does not wait for ready

    for (var i = this._selections.length - 1; i >= 0; i--) {
      var sel = this._selections[i];

      if (start <= sel.start && sel.end <= end) {
        this.undownload(sel);
      }
    }
  } // defer the last part until after ready as .get does that as well


  if (this.opened) this._cancel(start, end);else this._readyAndCancel(start, end);
};

Feed.prototype._cancel = function (start, end) {
  var i = 0;

  if (typeof start === 'symbol') {
    for (i = this._waiting.length - 1; i >= 0; i--) {
      const w = this._waiting[i];

      if (w.options.cancel === start) {
        remove(this._waiting, i);

        this._reserved.set(w.index, false);

        if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'));

        this._updatePeers();

        return;
      }
    }

    return;
  }

  for (i = start; i < end; i++) {
    this._reserved.set(i, false); // TODO: send cancel message if set returns true

  }

  for (i = this._waiting.length - 1; i >= 0; i--) {
    var w = this._waiting[i];

    if (start <= w.start && w.end <= end || start <= w.index && w.index < end) {
      remove(this._waiting, i);
      if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'));
    }
  }
};

Feed.prototype.clear = function (start, end, opts, cb) {
  // TODO: use same argument scheme as download
  if (typeof end === 'function') return this.clear(start, start + 1, null, end);
  if (typeof opts === 'function') return this.clear(start, end, null, opts);
  if (!opts) opts = {};
  if (!end) end = start + 1;
  if (!cb) cb = noop; // TODO: this needs some work. fx we can only calc byte offset for blocks we know about
  // so internally we should make sure to only do that. We should use the merkle tree for this

  var self = this;
  var byteOffset = start === 0 ? 0 : typeof opts.byteOffset === 'number' ? opts.byteOffset : -1;
  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1;
  this.ready(function (err) {
    if (err) return cb(err);
    var modified = false; // TODO: use a buffer.fill thing here to speed this up!

    for (var i = start; i < end; i++) {
      if (self.bitfield.set(i, false)) modified = true;
    }

    if (!modified) return process.nextTick(cb); // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing

    self._unannounce({
      start: start,
      length: end - start
    });

    if (opts.delete === false || self._indexing) return sync();
    if (byteOffset > -1) return onstartbytes(null, byteOffset);

    self._storage.dataOffset(start, [], onstartbytes);

    function sync() {
      self.emit('clear', start, end);

      self._sync(null, cb);
    }

    function onstartbytes(err, offset) {
      if (err) return cb(err);
      byteOffset = offset;
      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset);
      if (end === self.length) return onendbytes(null, self.byteLength);

      self._storage.dataOffset(end, [], onendbytes);
    }

    function onendbytes(err, end) {
      if (err) return cb(err);
      if (!self._storage.data.del) return sync(); // Not all data storage impls del

      self._storage.data.del(byteOffset, end - byteOffset, sync);
    }
  });
};

Feed.prototype.signature = function (index, cb) {
  if (typeof index === 'function') return this.signature(this.length - 1, index);
  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'));

  this._storage.nextSignature(index, cb);
};

Feed.prototype.verify = function (index, signature, cb) {
  var self = this;
  this.rootHashes(index, function (err, roots) {
    if (err) return cb(err);
    var checksum = crypto.signable(roots, index + 1);
    verifyCompat(self, checksum, signature, function (err, valid) {
      if (err) return cb(err);
      if (!valid) return cb(new Error('Signature verification failed'));
      return cb(null, true);
    });
  });
};

Feed.prototype.rootHashes = function (index, cb) {
  this._getRootsToVerify(index * 2 + 2, {}, [], cb);
};

Feed.prototype.seek = function (bytes, opts, cb) {
  if (typeof opts === 'function') return this.seek(bytes, null, opts);
  if (!opts) opts = {};
  if (!this.opened) return this._readyAndSeek(bytes, opts, cb);
  var self = this;
  if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0);

  this._seek(bytes, function (err, index, offset) {
    if (!err && isBlock(index)) return done(index / 2, offset);
    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'));
    var start = opts.start || 0;
    var end = opts.end || -1;

    if (!err) {
      var left = flat.leftSpan(index) / 2;
      var right = flat.rightSpan(index) / 2 + 1;
      if (left > start) start = left;
      if (right < end || end === -1) end = right;
    }

    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'));
    var w = {
      hash: opts.hash !== false,
      bytes: bytes,
      index: -1,
      ifAvailable: opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable,
      start: start,
      end: end,
      want: toWantRange(start),
      requested: 0,
      callback: cb || noop
    };

    self._waiting.push(w);

    self._updatePeers();

    if (w.ifAvailable) self._ifAvailableSeek(w);
  });

  function done(index, offset) {
    for (var i = 0; i < self.peers.length; i++) {
      self.peers[i].haveBytes(bytes);
    }

    cb(null, index, offset);
  }
};

Feed.prototype._ifAvailableSeek = function (w) {
  var self = this;
  var cb = w.callback;
  self.timeouts.get(function () {
    if (self.closed) return done(new Error('Closed'));
    process.nextTick(readyNT, self.ifAvailable, function () {
      if (self.closed) return done(new Error('Closed'));
      let available = false;

      for (const peer of self.peers) {
        const ite = peer._iterator;
        let i = ite.seek(w.start).next(true);

        while (self.tree.get(i * 2) && i > -1) i = ite.next(true);

        if (i > -1 && (w.end === -1 || i < w.end)) {
          available = true;
          break;
        }
      }

      if (!available) done(new Error('Seek not available from peers'));
    });
  });

  function done(err) {
    var i = self._waiting.indexOf(w);

    if (i > -1) {
      remove(self._waiting, i);
      w.callback = noop;
      cb(err);
    }
  }
};

Feed.prototype._seek = function (offset, cb) {
  if (offset === 0) return cb(null, 0, 0);
  var self = this;
  var roots = flat.fullRoots(this.length * 2);
  var nearestRoot = 0;
  loop(null, null);

  function onroot(top) {
    if (isBlock(top)) return cb(null, nearestRoot, offset);
    var left = flat.leftChild(top);

    while (!self.tree.get(left)) {
      if (isBlock(left)) return cb(null, nearestRoot, offset);
      left = flat.leftChild(left);
    }

    self._storage.getNode(left, onleftchild);
  }

  function onleftchild(err, node) {
    if (err) return cb(err);

    if (node.size > offset) {
      nearestRoot = node.index;
      onroot(node.index);
    } else {
      offset -= node.size;

      if (flat.parent(node.index) === nearestRoot) {
        nearestRoot = flat.sibling(node.index);
        onroot(nearestRoot);
      } else {
        onroot(flat.sibling(node.index));
      }
    }
  }

  function loop(err, node) {
    if (err) return cb(err);

    if (node) {
      if (node.size > offset) {
        nearestRoot = node.index;
        return onroot(node.index);
      }

      offset -= node.size;
    }

    if (!roots.length) return cb(new Error('Out of bounds'));

    self._storage.getNode(roots.shift(), loop);
  }
};

Feed.prototype._readyAndSeek = function (bytes, opts, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    self.seek(bytes, opts, cb);
  });
};

Feed.prototype._getBuffer = function (index, cb) {
  this._storage.getData(index, cb);
};

Feed.prototype._putBuffer = function (index, data, proof, from, cb) {
  // TODO: this nodes in proof are not instances of our Node prototype
  // but just similar. Check if this has any v8 perf implications.
  // TODO: if the proof contains a valid signature BUT fails, emit a critical error
  // --> feed should be considered dead
  var self = this;
  var trusted = -1;
  var missing = [];
  var next = 2 * index;
  var i = data ? 0 : 1;

  while (true) {
    if (this.tree.get(next)) {
      trusted = next;
      break;
    }

    var sib = flat.sibling(next);
    next = flat.parent(next);

    if (i < proof.nodes.length && proof.nodes[i].index === sib) {
      i++;
      continue;
    }

    if (!this.tree.get(sib)) break;
    missing.push(sib);
  }

  if (trusted === -1 && this.tree.get(next)) trusted = next;
  var error = null;
  var trustedNode = null;
  var missingNodes = new Array(missing.length);
  var pending = missing.length + (trusted > -1 ? 1 : 0);

  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing);

  if (trusted > -1) this._storage.getNode(trusted, ontrusted);
  if (!missing.length && trusted === -1) onmissingloaded(null);

  function ontrusted(err, node) {
    if (err) error = err;
    if (node) trustedNode = node;
    if (! --pending) onmissingloaded(error);
  }

  function onmissing(err, node) {
    if (err) error = err;
    if (node) missingNodes[missing.indexOf(node.index)] = node;
    if (! --pending) onmissingloaded(error);
  }

  function onmissingloaded(err) {
    if (err) return cb(err);

    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb);
  }
};

Feed.prototype._readyAndPut = function (index, data, proof, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    self.put(index, data, proof, cb);
  });
};

Feed.prototype._write = function (index, data, nodes, sig, from, cb) {
  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb);

  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb));
};

function writeHookDone(self, index, data, nodes, sig, from, cb) {
  return function (err) {
    if (err) return cb(err);

    self._writeAfterHook(index, data, nodes, sig, from, cb);
  };
}

Feed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {
  var self = this;
  var pending = nodes.length + 1 + (sig ? 1 : 0);
  var error = null;

  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone);

  if (data) this._storage.putData(index, data, nodes, ondone);else ondone();
  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone);

  function ondone(err) {
    if (err) error = err;
    if (--pending) return;
    if (error) return cb(error);

    self._writeDone(index, data, nodes, from, cb);
  }
};

Feed.prototype._writeDone = function (index, data, nodes, from, cb) {
  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index);

  this.tree.set(2 * index);

  if (data) {
    if (this.bitfield.set(index, true)) {
      if (this._stats) {
        this._stats.downloadedBlocks += 1;
        this._stats.downloadedBytes += data.length;
      }

      this.emit('download', index, data, from);
    }

    if (this.peers.length) this._announce({
      start: index
    }, from);

    if (!this.writable) {
      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length);

      if (this._synced.next() === -1) {
        this._synced.range(0, this.length);

        this._synced.seek(0);

        if (this._synced.next() === -1) {
          this.emit('sync');
        }
      }
    }
  }

  this._sync(null, cb);
};

Feed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {
  var visited = [];
  var remoteNodes = proof.nodes;
  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift(); // check if we already have the hash for this node

  if (verifyNode(trustedNode, top)) {
    this._write(index, data, visited, null, from, cb);

    return;
  } // keep hashing with siblings until we reach or trusted node


  while (true) {
    var node = null;
    var next = flat.sibling(top.index);

    if (remoteNodes.length && remoteNodes[0].index === next) {
      node = remoteNodes.shift();
      visited.push(node);
    } else if (localNodes.length && localNodes[0].index === next) {
      node = localNodes.shift();
    } else {
      // we cannot create another parent, i.e. these nodes must be roots in the tree
      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb);

      return;
    }

    visited.push(top);
    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size); // the tree checks out, write the data and the visited nodes

    if (verifyNode(trustedNode, top)) {
      this._write(index, data, visited, null, from, cb);

      return;
    }
  }
};

Feed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {
  var remoteNodes = proof.nodes;
  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index;
  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2;
  var length = verifiedBy / 2;
  var self = this;

  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {
    if (err) return cb(err);
    var checksum = crypto.signable(roots, length);
    var signature = null;

    if (self.length && self.live && !proof.signature) {
      return cb(new Error('Remote did not include a signature'));
    }

    if (proof.signature) {
      // check signatures
      verifyCompat(self, checksum, proof.signature, function (err, valid) {
        if (err) return cb(err);
        if (!valid) return cb(new Error('Remote signature could not be verified'));
        signature = {
          index: verifiedBy / 2 - 1,
          signature: proof.signature
        };
        write();
      });
    } else {
      // check tree root
      if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {
        return cb(new Error('Remote checksum failed'));
      }

      write();
    }

    function write() {
      self.live = !!signature;

      if (length > self.length) {
        // TODO: only emit this after the info has been flushed to storage
        if (self.writable) self._merkle = null; // We need to reload merkle state now

        self.length = length;
        self._seq = length;
        self.byteLength = roots.reduce(addSize, 0);
        if (self._synced) self._synced.seek(0, self.length);
        self.emit('append');
      }

      self._write(index, data, nodes.concat(extraNodes), signature, from, cb);
    }
  });
};

Feed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {
  var indexes = flat.fullRoots(verifiedBy);
  var roots = new Array(indexes.length);
  var nodes = [];
  var error = null;
  var pending = roots.length;

  for (var i = 0; i < indexes.length; i++) {
    if (indexes[i] === top.index) {
      nodes.push(top);
      onnode(null, top);
    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {
      nodes.push(remoteNodes[0]);
      onnode(null, remoteNodes.shift());
    } else if (this.tree.get(indexes[i])) {
      this._storage.getNode(indexes[i], onnode);
    } else {
      onnode(new Error('Missing tree roots needed for verify'));
    }
  }

  function onnode(err, node) {
    if (err) error = err;
    if (node) roots[indexes.indexOf(node.index)] = node;
    if (! --pending) done(error);
  }

  function done(err) {
    if (err) return cb(err);
    cb(null, roots, nodes);
  }
};

Feed.prototype._announce = function (message, from) {
  for (var i = 0; i < this.peers.length; i++) {
    var peer = this.peers[i];
    if (peer !== from) peer.have(message);
  }
};

Feed.prototype._unannounce = function (message) {
  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message);
};

Feed.prototype.downloaded = function (start, end, cb) {
  const count = this.bitfield.total(start, end);
  if (cb) process.nextTick(cb, null, count); // prepare async interface for this

  return count;
};

Feed.prototype.has = function (start, end, cb) {
  if (typeof end === 'function') return this.has(start, undefined, end);

  if (end === undefined) {
    const res = this.bitfield.get(start);
    if (cb) process.nextTick(cb, null, res);
    return res;
  }

  const total = end - start;
  const res = total === this.bitfield.total(start, end);
  if (cb) process.nextTick(cb, null, res);
  return res;
};

Feed.prototype.head = function (opts, cb) {
  if (typeof opts === 'function') return this.head({}, opts);
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    if (opts && opts.update) self.update(opts, onupdate);else process.nextTick(onupdate);
  });

  function onupdate() {
    if (self.length === 0) cb(new Error('feed is empty'));else self.get(self.length - 1, opts, cb);
  }
};

Feed.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts);
  opts = { ...opts
  };
  if (!opts.cancel) opts.cancel = Symbol('hypercore-get');
  if (!this.opened) return this._readyAndGet(index, opts, cb);

  if (!this.readable) {
    process.nextTick(cb, new Error('Feed is closed'));
    return opts.cancel;
  }

  if (opts.timeout) cb = timeoutCallback(cb, opts.timeout);

  if (!this.bitfield.get(index)) {
    if (opts && opts.wait === false) return process.nextTick(cb, new Error('Block not downloaded'));
    var w = {
      bytes: 0,
      hash: false,
      index: index,
      options: opts,
      requested: 0,
      callback: cb
    };

    this._waiting.push(w);

    if (opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w);

    this._updatePeers();

    if (opts.onwait) {
      const onwait = opts.onwait;
      opts.onwait = null;
      onwait(index);
    }

    return opts.cancel;
  }

  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb);else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb);

  this._getBuffer(index, cb);

  return opts.cancel;
};

Feed.prototype._readyAndGet = function (index, opts, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    self.get(index, opts, cb);
  });
  return opts.cancel;
};

Feed.prototype.getBatch = function (start, end, opts, cb) {
  if (typeof opts === 'function') return this.getBatch(start, end, null, opts);
  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb);
  var self = this;
  var wait = !opts || opts.wait !== false;
  if (this.has(start, end)) return this._getBatch(start, end, opts, cb);
  if (!wait) return process.nextTick(cb, new Error('Block not downloaded'));
  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout);
  this.download({
    start: start,
    end: end
  }, function (err) {
    if (err) return cb(err);

    self._getBatch(start, end, opts, cb);
  });
};

Feed.prototype._getBatch = function (start, end, opts, cb) {
  var enc = opts && opts.valueEncoding;
  var codec = enc ? toCodec(enc) : this._codec;

  this._storage.getDataBatch(start, end - start, onbatch);

  function onbatch(err, buffers) {
    if (err) return cb(err);
    var batch = new Array(buffers.length);

    for (var i = 0; i < buffers.length; i++) {
      try {
        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i];
      } catch (err) {
        return cb(err);
      }
    }

    cb(null, batch);
  }
};

Feed.prototype._readyAndGetBatch = function (start, end, opts, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);
    self.getBatch(start, end, opts, cb);
  });
};

Feed.prototype._updatePeers = function () {
  for (var i = 0; i < this.peers.length; i++) this.peers[i].update();
};

Feed.prototype.createWriteStream = function (opts) {
  return new WriteStream(this, opts);
};

Feed.prototype.createReadStream = function (opts) {
  return new ReadStream(this, opts);
}; // TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)


Feed.prototype.finalize = function (cb) {
  if (!this.key) {
    this.key = crypto.tree(this._merkle.roots);
    this.discoveryKey = crypto.discoveryKey(this.key);
  }

  this._storage.key.write(0, this.key, cb);
};

Feed.prototype.append = function (batch, cb) {
  if (!cb) cb = noop;
  var self = this;
  var list = Array.isArray(batch) ? batch : [batch];

  this._batch(list, onappend);

  function onappend(err) {
    if (err) return cb(err);
    var seq = self._seq;
    self._seq += list.length;
    cb(null, seq);
  }
};

Feed.prototype.flush = function (cb) {
  this.append([], cb);
};

Feed.prototype.destroyStorage = function (cb) {
  const self = this;
  this.close(function (err) {
    if (err) cb(err);else self._storage.destroy(cb);
  });
};

Feed.prototype._close = function (cb) {
  const self = this;

  for (const peer of this.peers) {
    if (!peer._destroyed) peer._close();
  }

  this._forceClose(onclose, null);

  function onclose(err) {
    if (!err) self.emit('close');
    cb(err);
  }
};

Feed.prototype._forceClose = function (cb, error) {
  var self = this;
  this.writable = false;
  this.readable = false;

  this._storage.close(function (err) {
    if (!err) err = error;

    self._destroy(err || new Error('Feed is closed'));

    cb(err);
  });
};

Feed.prototype._destroy = function (err) {
  this.ifAvailable.destroy();

  while (this._waiting.length) {
    this._waiting.pop().callback(err);
  }

  while (this._selections.length) {
    this._selections.pop().callback(err);
  }
};

Feed.prototype._appendHook = function (batch, cb) {
  var self = this;
  var missing = batch.length;
  var error = null;
  if (!missing) return this._append(batch, cb);

  for (var i = 0; i < batch.length; i++) {
    this._onwrite(i + this.length, batch[i], null, done);
  }

  function done(err) {
    if (err) error = err;
    if (--missing) return;
    if (error) return cb(error);

    self._append(batch, cb);
  }
};

Feed.prototype._append = function (batch, cb) {
  if (!this.opened) return this._readyAndAppend(batch, cb);
  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'));
  var self = this;
  var pending = 1;
  var offset = 0;
  var error = null;
  var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0);
  var nodeOffset = this.length * 2;
  var dataBatch = new Array(batch.length);
  if (!pending) return cb();

  for (var i = 0; i < batch.length; i++) {
    var data = this._codec.encode(batch[i]);

    var nodes = this._merkle.next(data); // the replication stream rejects frames >8MB for DOS defense. Is configurable there, so
    // we could bubble that up here. For now just hardcode it so you can't accidentally "brick" your core
    // note: this is *only* for individual blocks and is just a sanity check. most blocks are <1MB


    if (data.length > 8388608) return cb(new Error('Individual blocks has be less than 8MB'));
    offset += data.length;
    dataBatch[i] = data;

    for (var j = 0; j < nodes.length; j++) {
      var node = nodes[j];

      if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {
        nodeBatch[node.index - nodeOffset] = node;
      } else {
        pending++;

        this._storage.putNode(node.index, node, done);
      }
    }
  }

  if (this.live && batch.length) {
    pending++;
    this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function (err, sig) {
      if (err) return done(err);

      self._storage.putSignature(self.length + batch.length - 1, sig, done);
    });
  }

  if (!this._indexing) {
    pending++;
    if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done);else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done);
  }

  this._storage.putNodeBatch(nodeOffset, nodeBatch, done);

  function done(err) {
    if (err) error = err;
    if (--pending) return;
    if (error) return cb(error);
    var start = self.length; // TODO: only emit append and update length / byteLength after the info has been flushed to storage

    self.byteLength += offset;

    for (var i = 0; i < batch.length; i++) {
      self.bitfield.set(self.length, true);
      self.tree.set(2 * self.length++);
    }

    self.emit('append');
    var message = self.length - start > 1 ? {
      start: start,
      length: self.length - start
    } : {
      start: start
    };
    if (self.peers.length) self._announce(message);

    self._sync(null, cb);
  }
};

Feed.prototype._readyAndAppend = function (batch, cb) {
  var self = this;
  this.ready(function (err) {
    if (err) return cb(err);

    self._append(batch, cb);
  });
};

Feed.prototype._readyAndCancel = function (start, end) {
  var self = this;
  this.ready(function () {
    self._cancel(start, end);
  });
};

Feed.prototype._pollWaiting = function () {
  var len = this._waiting.length;

  for (var i = 0; i < len; i++) {
    var next = this._waiting[i];

    if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {
      continue;
    }

    remove(this._waiting, i--);
    len--;
    if (next.bytes) this.seek(next.bytes, next, next.callback);else if (next.update) this.update(next.index + 1, next.callback);else this.get(next.index, next.options, next.callback);
  }
};

Feed.prototype._syncBitfield = function (cb) {
  var missing = this.bitfield.pages.updates.length;
  var next = null;
  var error = null; // All data / nodes have been written now. We still need to update the bitfields though
  // TODO 1: if the program fails during this write the bitfield might not have been fully written
  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists
  // on disk. So if a get fails, it should try and recover once.
  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf
  // Added benefit is that if the program exits while flushing the bitfield the feed will only get
  // truncated and not have missing chunks which is what you expect.

  if (!missing) {
    this._pollWaiting();

    return cb(null);
  }

  while ((next = this.bitfield.pages.lastUpdate()) !== null) {
    this._storage.putBitfield(next.offset, next.buffer, ondone);
  }

  this._pollWaiting();

  function ondone(err) {
    if (err) error = err;
    if (--missing) return;
    cb(error);
  }
};

Feed.prototype._roots = function (index, cb) {
  var roots = flat.fullRoots(2 * index);
  var result = new Array(roots.length);
  var pending = roots.length;
  var error = null;
  if (!pending) return cb(null, result);

  for (var i = 0; i < roots.length; i++) {
    this._storage.getNode(roots[i], onnode);
  }

  function onnode(err, node) {
    if (err) error = err;
    if (node) result[roots.indexOf(node.index)] = node;
    if (--pending) return;
    if (error) return cb(error);
    cb(null, result);
  }
};

Feed.prototype.audit = function (cb) {
  if (!cb) cb = noop;
  var self = this;
  var report = {
    valid: 0,
    invalid: 0
  };
  this.ready(function (err) {
    if (err) return cb(err);
    var block = 0;
    var max = self.length;
    next();

    function onnode(err, node) {
      if (err) return ondata(null, null);

      self._storage.getData(block, ondata);

      function ondata(_, data) {
        var verified = data && crypto.data(data).equals(node.hash);
        if (verified) report.valid++;else report.invalid++;
        self.bitfield.set(block, verified);
        block++;
        next();
      }
    }

    function next() {
      while (block < max && !self.bitfield.get(block)) block++;

      if (block >= max) return done();

      self._storage.getNode(2 * block, onnode);
    }

    function done() {
      self._sync(null, function (err) {
        if (err) return cb(err);
        cb(null, report);
      });
    }
  });
};

Feed.prototype.extension = function (name, message) {
  var peers = this.peers;

  for (var i = 0; i < peers.length; i++) {
    peers[i].extension(name, message);
  }
};

function noop() {}

function verifyNode(trusted, node) {
  return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0;
}

function addSize(size, node) {
  return size + node.size;
}

function isBlock(index) {
  return (index & 1) === 0;
}

function toCodec(enc) {
  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \o/
  return codecs(enc === 'json' ? 'ndjson' : enc);
}

function wrapCodec(enc, cb) {
  return function (err, buf) {
    if (err) return cb(err);

    try {
      buf = enc.decode(buf);
    } catch (err) {
      return cb(err);
    }

    cb(null, buf);
  };
}

function timeoutCallback(cb, timeout) {
  var failed = false;
  var id = setTimeout(ontimeout, timeout);
  return done;

  function ontimeout() {
    failed = true; // TODO: make libs/errors for all this stuff

    var err = new Error('ETIMEDOUT');
    err.code = 'ETIMEDOUT';
    cb(err);
  }

  function done(err, val) {
    if (failed) return;
    clearTimeout(id);
    cb(err, val);
  }
}

function toWantRange(i) {
  return Math.floor(i / 1024 / 1024) * 1024 * 1024;
}

function createError(code, errno, msg) {
  var err = new Error(msg);
  err.code = code;
  err.errno = errno;
  return err;
}

function defaultStorageDir(directory) {
  return function (name) {
    return defaultStorage(name, {
      directory
    });
  };
}

function isOptions(initiator) {
  return !Protocol.isProtocolStream(initiator) && typeof initiator === 'object' && !!initiator && typeof initiator.initiator === 'boolean';
}

function readyNT(ifAvailable, fn) {
  ifAvailable.ready(fn);
}

function verifyCompat(self, checksum, signature, cb) {
  self.crypto.verify(checksum, signature, self.key, function (err, valid) {
    if (err || valid) return cb(err, valid); // compat mode, will be removed in a later version

    self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb);
  });
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./lib/bitfield":242,"./lib/replicate":244,"./lib/safe-buffer-equals":245,"./lib/storage":246,"./lib/tree-index":247,"_process":380,"abstract-extension":14,"atomic-batcher":34,"buffer":97,"codecs":118,"flat-tree":180,"hypercore-crypto":236,"hypercore-default-storage":238,"hypercore-protocol":239,"hypercore-streams":240,"inherits":279,"inspect-custom-symbol":280,"last-one-wins":288,"merkle-tree-stream/generator":309,"nanoguard":322,"nanoresource/emitter":344,"pretty-hash":378,"sparse-bitfield":547,"unordered-array-remove":574,"unordered-set":575}],242:[function(require,module,exports){
(function (Buffer){(function (){
var flat = require('flat-tree');

var rle = require('bitfield-rle');

var pager = require('memory-pager');

var bitfield = require('sparse-bitfield');

var INDEX_UPDATE_MASK = [63, 207, 243, 252];
var INDEX_ITERATE_MASK = [0, 192, 240, 252];
var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255];
var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254];
var MAP_PARENT_RIGHT = new Array(256);
var MAP_PARENT_LEFT = new Array(256);
var NEXT_DATA_0_BIT = new Array(256);
var NEXT_INDEX_0_BIT = new Array(256);
var TOTAL_1_BITS = new Array(256);

for (var i = 0; i < 256; i++) {
  var a = (i & 15 << 4) >> 4;
  var b = i & 15;
  var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];
  MAP_PARENT_RIGHT[i] = (a === 15 ? 3 : a === 0 ? 0 : 1) << 2 | (b === 15 ? 3 : b === 0 ? 0 : 1);
  MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4;
  NEXT_DATA_0_BIT[i] = i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2));
  NEXT_INDEX_0_BIT[i] = i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2);
  TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 0x0F];
}

module.exports = Bitfield;

function Bitfield(pageSize, pages) {
  if (!(this instanceof Bitfield)) return new Bitfield(pageSize, pages);
  if (!pageSize) pageSize = 2048 + 1024 + 512;
  var deduplicate = Buffer.allocUnsafe(pageSize);
  deduplicate.fill(255);
  this.indexSize = pageSize - 2048 - 1024;
  this.pages = pager(pageSize, {
    deduplicate
  });

  if (pages) {
    for (var i = 0; i < pages.length; i++) {
      this.pages.set(i, pages[i]);
    }
  }

  this.data = bitfield({
    pageSize: 1024,
    pageOffset: 0,
    pages: this.pages,
    trackUpdates: true
  });
  this.tree = bitfield({
    pageSize: 2048,
    pageOffset: 1024,
    pages: this.pages,
    trackUpdates: true
  });
  this.index = bitfield({
    pageSize: this.indexSize,
    pageOffset: 1024 + 2048,
    pages: this.pages,
    trackUpdates: true
  });
  this.length = this.data.length;
  this._iterator = flat.iterator(0);
}

Bitfield.prototype.set = function (i, value) {
  var o = i & 7;
  i = (i - o) / 8;
  var v = value ? this.data.getByte(i) | 128 >> o : this.data.getByte(i) & DATA_UPDATE_MASK[o];
  if (!this.data.setByte(i, v)) return false;
  this.length = this.data.length;

  this._setIndex(i, v);

  return true;
};

Bitfield.prototype.get = function (i) {
  return this.data.get(i);
};

Bitfield.prototype.total = function (start, end) {
  if (!start || start < 0) start = 0;
  if (!end) end = this.data.length;
  if (end < start) return 0;

  if (end > this.data.length) {
    this._expand(end);
  }

  var o = start & 7;
  var e = end & 7;
  var pos = (start - o) / 8;
  var last = (end - e) / 8;
  var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0);
  var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0;
  var byte = this.data.getByte(pos);

  if (pos === last) {
    return TOTAL_1_BITS[byte & leftMask & rightMask];
  }

  var total = TOTAL_1_BITS[byte & leftMask];

  for (var i = pos + 1; i < last; i++) {
    total += TOTAL_1_BITS[this.data.getByte(i)];
  }

  total += TOTAL_1_BITS[this.data.getByte(last) & rightMask];
  return total;
}; // TODO: use the index to speed this up *a lot*


Bitfield.prototype.compress = function (start, length) {
  if (!start && !length) return rle.encode(this.data.toBuffer());
  if (start + length > this.length) length = Math.max(1, this.length - start);
  var buf = Buffer.alloc(Math.ceil(length / 8));
  var p = start / this.data.pageSize / 8;
  var end = p + length / this.data.pageSize / 8;
  var offset = p * this.data.pageSize;

  for (; p < end; p++) {
    var page = this.data.pages.get(p, true);
    if (!page || !page.buffer) continue;
    page.buffer.copy(buf, p * this.data.pageSize - offset, this.data.pageOffset, this.data.pageOffset + this.data.pageSize);
  }

  return rle.encode(buf);
};

Bitfield.prototype._setIndex = function (i, value) {
  //                    (a + b | c + d | e + f | g + h)
  // -> (a | b | c | d)                                (e | f | g | h)
  //
  var o = i & 3;
  i = (i - o) / 4;
  var bitfield = this.index;
  var ite = this._iterator;
  var start = 2 * i;
  var byte = bitfield.getByte(start) & INDEX_UPDATE_MASK[o] | getIndexValue(value) >> 2 * o;
  var len = bitfield.length;
  var maxLength = this.pages.length * this.indexSize;
  ite.seek(start);

  while (ite.index < maxLength && bitfield.setByte(ite.index, byte)) {
    if (ite.isLeft()) {
      byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())];
    } else {
      byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())];
    }

    ite.parent();
  }

  if (len !== bitfield.length) this._expand(len);
  return ite.index !== start;
};

Bitfield.prototype._expand = function (len) {
  var roots = flat.fullRoots(2 * len);
  var bitfield = this.index;
  var ite = this._iterator;
  var byte = 0;

  for (var i = 0; i < roots.length; i++) {
    ite.seek(roots[i]);
    byte = bitfield.getByte(ite.index);

    do {
      if (ite.isLeft()) {
        byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())];
      } else {
        byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())];
      }
    } while (setByteNoAlloc(bitfield, ite.parent(), byte));
  }
};

function setByteNoAlloc(bitfield, i, b) {
  if (8 * i >= bitfield.length) return false;
  return bitfield.setByte(i, b);
}

Bitfield.prototype.iterator = function (start, end) {
  var ite = new Iterator(this);
  ite.range(start || 0, end || this.length);
  ite.seek(0);
  return ite;
};

function Iterator(bitfield) {
  this.start = 0;
  this.end = 0;
  this._indexEnd = 0;
  this._pos = 0;
  this._byte = 0;
  this._bitfield = bitfield;
}

Iterator.prototype.range = function (start, end) {
  this.start = start;
  this.end = end;
  this._indexEnd = 2 * Math.ceil(end / 32);

  if (this.end > this._bitfield.length) {
    this._bitfield._expand(this.end);
  }

  return this;
};

Iterator.prototype.seek = function (offset) {
  offset += this.start;
  if (offset < this.start) offset = this.start;

  if (offset >= this.end) {
    this._pos = -1;
    return this;
  }

  var o = offset & 7;
  this._pos = (offset - o) / 8;
  this._byte = this._bitfield.data.getByte(this._pos) | (o ? DATA_ITERATE_MASK[o - 1] : 0);
  return this;
};

Iterator.prototype.random = function () {
  var i = this.seek(Math.floor(Math.random() * (this.end - this.start))).next();
  return i === -1 ? this.seek(0).next() : i;
};

Iterator.prototype.next = function () {
  if (this._pos === -1) return -1;
  var dataBitfield = this._bitfield.data;
  var free = NEXT_DATA_0_BIT[this._byte];

  while (free === -1) {
    this._byte = dataBitfield.getByte(++this._pos);
    free = NEXT_DATA_0_BIT[this._byte];

    if (free === -1) {
      this._pos = this._skipAhead(this._pos);
      if (this._pos === -1) return -1;
      this._byte = dataBitfield.getByte(this._pos);
      free = NEXT_DATA_0_BIT[this._byte];
    }
  }

  this._byte |= DATA_ITERATE_MASK[free];
  var n = 8 * this._pos + free;
  return n < this.end ? n : -1;
};

Iterator.prototype.peek = function () {
  if (this._pos === -1) return -1;
  var free = NEXT_DATA_0_BIT[this._byte];
  var n = 8 * this._pos + free;
  return n < this.end ? n : -1;
};

Iterator.prototype._skipAhead = function (start) {
  var indexBitfield = this._bitfield.index;
  var treeEnd = this._indexEnd;
  var ite = this._bitfield._iterator;
  var o = start & 3;
  ite.seek(2 * ((start - o) / 4));
  var treeByte = indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o];

  while (NEXT_INDEX_0_BIT[treeByte] === -1) {
    if (ite.isLeft()) {
      ite.next();
    } else {
      ite.next();
      ite.parent();
    }

    if (rightSpan(ite) >= treeEnd) {
      while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild();

      if (rightSpan(ite) >= treeEnd) return -1;
    }

    treeByte = indexBitfield.getByte(ite.index);
  }

  while (ite.factor > 2) {
    if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild();else ite.rightChild();
    treeByte = indexBitfield.getByte(ite.index);
  }

  var free = NEXT_INDEX_0_BIT[treeByte];
  if (free === -1) free = 4;
  var next = ite.index * 2 + free;
  return next <= start ? start + 1 : next;
};

function rightSpan(ite) {
  return ite.index + ite.factor / 2 - 1;
}

function isParent(ite) {
  return ite.index & 1;
}

function getIndexValue(n) {
  switch (n) {
    case 255:
      return 192;

    case 0:
      return 0;

    default:
      return 64;
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bitfield-rle":37,"buffer":97,"flat-tree":180,"memory-pager":308,"sparse-bitfield":547}],243:[function(require,module,exports){
const HypercoreCache = require('hypercore-cache');

const DEFAULT_TREE_CACHE_SIZE = 65536 * 40;

function createCache(opts) {
  if (opts.cache === false) return {};
  const cacheOpts = opts.cache || {};

  if (cacheOpts.tree === undefined || typeof cacheOpts.tree === 'number') {
    const cacheSize = cacheOpts.tree || opts.storageCacheSize;
    cacheOpts.tree = new HypercoreCache({
      maxByteSize: cacheSize !== undefined ? cacheSize : DEFAULT_TREE_CACHE_SIZE,
      estimateSize: () => 40
    });
  }

  if (cacheOpts.data === undefined) return cacheOpts;

  if (typeof cacheOpts.data === 'number') {
    cacheOpts.data = new HypercoreCache({
      maxByteSize: cacheOpts.data,
      estimateSize: buf => buf.length
    });
  }

  return cacheOpts;
}

module.exports = createCache;

},{"hypercore-cache":235}],244:[function(require,module,exports){
var Protocol = require('hypercore-protocol');

var timeout = require('timeout-refresh');

var bitfield = require('fast-bitfield');

var set = require('unordered-set');

var rle = require('bitfield-rle').align(4);

var treeIndex = require("./tree-index");

var EMPTY = new Uint8Array(1024);
module.exports = replicate;

function replicate(feed, initiator, opts) {
  feed.ifAvailable.wait();
  var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream;

  if (!stream) {
    if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair;
    stream = new Protocol(initiator, opts);
  }

  if (feed.opened) onready(null);else feed.ready(onready);
  return stream;

  function onready(err) {
    feed.ifAvailable.continue();
    if (err) return stream.destroy(err);
    if (stream.destroyed) return;
    if (stream.opened(feed.key)) return;

    if (opts.noise !== false) {
      if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {
        stream.close(feed.discoveryKey);
        return;
      }
    }

    var peer = new Peer(feed, opts);
    peer.feed = feed;
    peer.stream = stream.open(feed.key, peer);
    stream.setMaxListeners(0);
    peer.ready();
  }
}

function Peer(feed, opts) {
  if (opts.extensions) throw new Error('Per peer extensions is not supported. Use feed.registerExtension instead');
  this.feed = feed;
  this.stream = null; // set by replicate just after creation

  this.wants = bitfield();
  this.remoteBitfield = bitfield();
  this.remoteLength = 0;
  this.remoteWant = false;
  this.remoteTree = null;
  this.remoteAck = false;
  this.remoteOpened = false;
  this.live = !!opts.live;
  this.sparse = feed.sparse;
  this.ack = !!opts.ack;
  this.remoteDownloading = true;
  this.remoteUploading = true;
  this.remoteExtensions = feed.extensions.remote();
  this.downloading = typeof opts.download === 'boolean' ? opts.download : feed.downloading;
  this.uploading = typeof opts.upload === 'boolean' ? opts.upload : feed.uploading;
  this.updated = false;
  this.maxRequests = opts.maxRequests || feed.maxRequests || 16;
  this.urgentRequests = this.maxRequests + 16;
  this.inflightRequests = [];
  this.inflightWants = 0;
  this._index = -1;
  this._lastBytes = 0;
  this._first = true;
  this._closed = false;
  this._destroyed = false;
  this._defaultDownloading = this.downloading;
  this._iterator = this.remoteBitfield.iterator();
  this._requestTimeout = null;
  this.stats = !opts.stats ? null : {
    uploadedBytes: 0,
    uploadedBlocks: 0,
    downloadedBytes: 0,
    downloadedBlocks: 0
  };
}

Object.defineProperty(Peer.prototype, 'remoteAddress', {
  enumerable: true,
  get: function () {
    return this.stream.stream.remoteAddress;
  }
});
Object.defineProperty(Peer.prototype, 'remoteType', {
  enumerable: true,
  get: function () {
    return this.stream.stream.remoteType;
  }
});
Object.defineProperty(Peer.prototype, 'remotePublicKey', {
  enumerable: true,
  get: function () {
    return this.stream.state.remotePublicKey;
  }
});

Peer.prototype.onwant = function (want) {
  if (!this.uploading) return; // We only reploy to multipla of 8192 in terms of offsets and lengths for want messages
  // since this is much easier for the bitfield, in terms of paging.

  if (want.start & 8191 || want.length & 8191) return;

  if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {
    // Eagerly send the length of the feed to the otherside
    // TODO: only send this if the remote is not wanting a region
    // where this is contained in
    this.stream.have({
      start: this.feed.length - 1
    });
  }

  this.remoteWant = true;
  var rle = this.feed.bitfield.compress(want.start, want.length);
  this.stream.have({
    start: want.start,
    length: want.length,
    bitfield: rle
  });
};

Peer.prototype.ondata = function (data) {
  var self = this; // Ignore unrequested messages unless we allow push
  // TODO: would be better to check if the byte range was requested instead, but this works fine

  var allowPush = this.feed.allowPush || !data.value;

  if (!allowPush && !this.feed._reserved.get(data.index)) {
    // If we do not have this block, send back unhave message for this index,
    // to let the remote know we rejected it.
    // TODO: we might want to have some "unwanted push" threshold to punish spammers
    if (!self.feed.bitfield.get(data.index)) self.unhave({
      start: data.index
    });

    self._clear(data.index, !data.value);

    return;
  }

  this.feed._putBuffer(data.index, data.value, data, this, function (err) {
    if (err) return self.destroy(err);
    if (data.value) self.remoteBitfield.set(data.index, false);

    if (self.remoteAck) {
      // Send acknowledgement.
      // In the future this could batch several ACKs at once
      self.stream.have({
        start: data.index,
        length: 1,
        ack: true
      });
    }

    if (self.stats && data.value) {
      self.stats.downloadedBlocks += 1;
      self.stats.downloadedBytes += data.value.length;
    }

    self._clear(data.index, !data.value);
  });
};

Peer.prototype._clear = function (index, hash) {
  // TODO: optimize me (no splice and do not run through all ...)
  for (var i = 0; i < this.inflightRequests.length; i++) {
    if (this.inflightRequests[i].index === index) {
      if (this._requestTimeout !== null) this._requestTimeout.refresh();
      this.inflightRequests.splice(i, 1);
      i--;
    }
  }

  this.feed._reserved.set(index, false); // TODO: only update all if we have overlapping selections


  this.feed._updatePeers();

  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
    this._requestTimeout.destroy();

    this._requestTimeout = null;
  }
};

Peer.prototype.onrequest = function (request) {
  if (!this.uploading) return;
  if (request.bytes) return this._onbytes(request); // lazily instantiate the remote tree

  if (!this.remoteTree) this.remoteTree = treeIndex();
  var self = this;
  var opts = {
    digest: request.nodes,
    hash: request.hash,
    tree: this.remoteTree
  };
  this.feed.proof(request.index, opts, onproof);

  function onproof(err, proof) {
    if (err) return self.destroy(err);
    if (request.hash) onvalue(null, null);else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue);

    function onvalue(err, value) {
      if (!self.uploading) return;
      if (err) return self.destroy(err);

      if (value) {
        if (self.stats) {
          self.stats.uploadedBlocks += 1;
          self.stats.uploadedBytes += value.length;
          self.feed._stats.uploadedBlocks += 1;
          self.feed._stats.uploadedBytes += value.length;
        }

        self.feed.emit('upload', request.index, value, self);
      } // TODO: prob not needed with new bitfield


      if (request.index + 1 > self.remoteLength) {
        self.remoteLength = request.index + 1;

        self._updateEnd();
      }

      self.stream.data({
        index: request.index,
        value: value,
        nodes: proof.nodes,
        signature: proof.signature
      });
    }
  }
};

Peer.prototype._updateOptions = function () {
  if (this.ack || this.feed.extensions.length) {
    this.stream.options({
      ack: this.ack,
      extensions: this.feed.extensions.names()
    });
  }
};

Peer.prototype.setDownloading = function (downloading) {
  if (downloading === this.downloading) return;
  this.downloading = downloading;
  this.stream.status({
    downloading,
    uploading: this.uploading
  });
  this.update();
};

Peer.prototype.setUploading = function (uploading) {
  if (uploading === this.uploading) return;
  this.uploading = uploading;
  this.stream.status({
    downloading: this.downloading,
    uploading
  });
  this.update();
};

Peer.prototype._onbytes = function (request) {
  var self = this;
  this.feed.seek(request.bytes, {
    wait: false
  }, function (err, index) {
    if (err) {
      request.bytes = 0;
      self.onrequest(request);
      return;
    } // quick'n'dirty filter for parallel bytes requests
    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization


    if (self._lastBytes === request.bytes) return;
    self._lastBytes = request.bytes;
    request.bytes = 0;
    request.index = index;
    request.nodes = 0;
    self.onrequest(request);
  });
};

Peer.prototype._onrequesttimeout = function () {
  this._requestTimeout = null;
  if (!this.inflightRequests.length) return;
  var first = this.inflightRequests[0];

  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {
    // prob a bytes response
    this.inflightRequests.shift();

    this.feed._reserved.set(first.index, false);

    if (this.stream.stream.timeout) {
      this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
    }

    return;
  }

  this.destroy(new Error('Request timeout'));
};

Peer.prototype.onhave = function (have) {
  this.feed.emit('peer-ack', this, have);

  if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {
    this.stream.stream.emit('ack', have);
    return;
  }

  var updated = this._first;
  if (this._first) this._first = false; // In this impl, we only sent WANTs for 1024 * 1024 length ranges
  // so if we get a HAVE for that it is a reply to a WANT.

  if (have.length === 1024 * 1024 && this.inflightWants > 0) {
    this.feed.ifAvailable.continue();
    this.inflightWants--;
  }

  if (have.bitfield) {
    // TODO: handle start !== 0
    if (have.length === 0 || have.length === 1) {
      // length === 1 is for backwards compat
      this.wants = null; // we are in backwards compat mode where we subscribe everything
    }

    var buf = rle.decode(have.bitfield);
    var bits = buf.length * 8;
    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start);
    this.remoteBitfield.fill(buf, have.start);

    if (bits > this.remoteLength) {
      this.remoteLength = this.remoteBitfield.last() + 1;
      updated = true;
    }
  } else {
    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield
    var start = have.start;
    var len = have.length || 1;

    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++));

    if (start > this.remoteLength) {
      this.remoteLength = start;
      updated = true;
    }
  }

  if (updated) {
    this.updated = true;
    this.feed.emit('remote-update', this);
  }

  this._updateEnd();

  this.update();
};

Peer.prototype._updateEnd = function () {
  if (this.live || this.feed.sparse || !this.feed._selections.length) return;
  var sel = this.feed._selections[0];
  var remoteLength = this.feed.length || -1;

  for (var i = 0; i < this.feed.peers.length; i++) {
    if (this.feed.peers[i].remoteLength > remoteLength) {
      remoteLength = this.feed.peers[i].remoteLength;
    }
  }

  sel.end = remoteLength;
};

Peer.prototype.onextension = function (id, message) {
  this.remoteExtensions.onmessage(id, message, this);
};

Peer.prototype.onstatus = function (info) {
  this.remoteUploading = info.uploading;
  this.remoteDownloading = info.downloading;

  if (!info.uploading) {
    while (this.inflightRequests.length) {
      const data = this.inflightRequests[0];

      this._clear(data.index, !data.value);
    }

    for (var i = 0; i < this.inflightWants; i++) {
      this.feed.ifAvailable.continue();
    }

    this.inflightWants = 0;
    this.wants = bitfield();
  }

  this.update();
  if (info.downloading || this.live) return;
  if (this.feed._selections.length && this.downloading) return;

  this._autoEnd();
};

Peer.prototype._autoEnd = function () {
  if (this.uploading && this.remoteDownloading) return;
  if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return;
  this.end();
};

Peer.prototype.onunhave = function (unhave) {
  var start = unhave.start;
  var len = unhave.length || 1;

  if (start === 0 && len >= this.remoteLength) {
    this.remoteLength = 0;
    this.remoteBitfield = bitfield();
    return;
  }

  while (len--) this.remoteBitfield.set(start++, false);
};

Peer.prototype.onunwant = Peer.prototype.oncancel = function () {// TODO: impl all of me
};

Peer.prototype.onclose = function () {
  this._close();
};

Peer.prototype.have = function (have) {
  // called by feed
  if (this.stream && this.remoteWant) this.stream.have(have);
  var start = have.start;
  var len = have.length;

  while (len--) this.remoteBitfield.set(start++, false);
};

Peer.prototype.unhave = function (unhave) {
  // called by feed
  if (this.stream && this.remoteWant) this.stream.unhave(unhave);
};

Peer.prototype.haveBytes = function (bytes) {
  // called by feed
  for (var i = 0; i < this.inflightRequests.length; i++) {
    if (this.inflightRequests[i].bytes === bytes) {
      this.feed._reserved.set(this.inflightRequests[i].index, false);

      this.inflightRequests.splice(i, 1);
      i--;
    }
  }

  this.update();

  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
    this._requestTimeout.destroy();

    this._requestTimeout = null;
  }
};

Peer.prototype.update = function () {
  // do nothing
  while (this._update()) {}

  this._sendWantsMaybe();
};

Peer.prototype._update = function () {
  // should return true if mutated false if not
  if (!this.downloading || !this.remoteUploading) return false;
  var selections = this.feed._selections;
  var waiting = this.feed._waiting;
  var wlen = waiting.length;
  var slen = selections.length;
  var inflight = this.inflightRequests.length;
  var offset = 0;
  var i = 0; // TODO: less duplicate code here
  // TODO: re-add priority levels

  while (inflight < this.urgentRequests) {
    offset = Math.floor(Math.random() * waiting.length);

    for (i = 0; i < waiting.length; i++) {
      var w = waiting[offset++];
      if (offset === waiting.length) offset = 0;

      this._downloadWaiting(w);

      if (waiting.length !== wlen) return true; // mutated

      if (this.inflightRequests.length >= this.urgentRequests) return false;
    }

    if (inflight === this.inflightRequests.length) break;
    inflight = this.inflightRequests.length;
  }

  while (inflight < this.maxRequests) {
    offset = Math.floor(Math.random() * selections.length);

    for (i = 0; i < selections.length; i++) {
      var s = selections[offset++];
      if (offset === selections.length) offset = 0;
      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end);
      if (s.blocks) this._downloadBlocks(s);else this._downloadRange(s);
      if (selections.length !== slen) return true; // mutated

      if (this.inflightRequests.length >= this.maxRequests) return false;
    }

    if (inflight === this.inflightRequests.length) return false;
    inflight = this.inflightRequests.length;
  }

  return false;
};

Peer.prototype.onopen = function () {
  this.feed.ifAvailable.continue();
  this.remoteOpened = true;

  this._updateOptions();

  if (!this.uploading || !this.downloading) {
    this.stream.status({
      uploading: this.uploading,
      downloading: this.downloading
    });
  }

  this._sendWants();

  this.feed.emit('peer-open', this);
};

Peer.prototype.onoptions = function (options) {
  this.remoteAck = options.ack;
  this.remoteExtensions.update(options.extensions);
};

Peer.prototype.ready = function () {
  this.feed.ifAvailable.wait(); // continued by onopen or close

  set.add(this.feed.peers, this);
  this.feed.emit('peer-add', this);
  if (this.stream.remoteOpened) this.onopen();
};

Peer.prototype.end = function () {
  if (!this.downloading && !this.remoteDownloading && !this.live) {
    if (!this._defaultDownloading) {
      this.stream.status({
        downloading: false,
        uploading: false
      });
    }

    this._close();

    return;
  }

  if (!this._closed) {
    this._closed = true;
    this.downloading = false;
    this.stream.status({
      downloading: false,
      uploading: true
    });
  } else {
    if (!this.live) this._close();
  }
};

Peer.prototype._close = function () {
  if (!this._destroyed) {
    this._destroyed = true;
    this.stream.close();
  }

  if (this._index === -1) return;
  set.remove(this.feed.peers, this);
  this._index = -1;

  for (var i = 0; i < this.inflightRequests.length; i++) {
    this.feed._reserved.set(this.inflightRequests[i].index, false);
  }

  if (this._requestTimeout !== null) {
    this._requestTimeout.destroy();

    this._requestTimeout = null;
  }

  this._updateEnd();

  this.remoteWant = false;

  this.feed._updatePeers();

  this.feed.emit('peer-remove', this);

  for (i = 0; i < this.inflightWants; i++) {
    this.feed.ifAvailable.continue();
  }

  if (!this.remoteOpened) {
    this.feed.ifAvailable.continue();
  }
};

Peer.prototype.destroy = function (err) {
  if (this._index === -1 || this._destroyed) return;
  this.stream.destroy(err);
  this._destroyed = true;

  this._close();
};

Peer.prototype._sendWantsMaybe = function () {
  if (this.inflightRequests.length < this.urgentRequests) this._sendWants();
};

Peer.prototype._sendWants = function () {
  if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return;
  if (this.inflightWants >= 16) return;
  var i;

  for (i = 0; i < this.feed._waiting.length; i++) {
    var w = this.feed._waiting[i];
    if (w.index === -1) this._sendWantRange(w);else this._sendWant(w.index);
    if (this.inflightWants >= 16) return;
  }

  for (i = 0; i < this.feed._selections.length; i++) {
    var s = this.feed._selections[i];

    this._sendWantRange(s);

    if (this.inflightWants >= 16) return;
  } // always sub to the first range for now, usually what you want


  this._sendWant(0);
};

Peer.prototype._sendWantRange = function (s) {
  if (s.blocks) {
    if (!s.selected) s.selected = new WeakSet();
    if (s.selected.has(this)) return;
    s.selected.add(this);

    for (const block of s.blocks) {
      this._sendWant(block);
    }

    return;
  }

  var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0;

  while (true) {
    if (want >= this.remoteLength) return;
    if (s.end !== -1 && want >= s.end) return;
    if (this._sendWant(want)) return; // check if region is already selected - if so try next one

    if (!this.wants.get(Math.floor(want / 1024 / 1024))) return;
    want += 1024 * 1024;
  }
};

Peer.prototype._sendWant = function (index) {
  var len = 1024 * 1024;
  var j = Math.floor(index / len);
  if (this.wants.get(j)) return false;
  this.wants.set(j, true);
  this.inflightWants++;
  this.feed.ifAvailable.wait();
  this.stream.want({
    start: j * len,
    length: len
  });
  return true;
};

Peer.prototype._downloadWaiting = function (wait) {
  if (!wait.bytes) {
    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {
      if (!wait.update || this.feed._reserved.get(wait.index)) return;

      const i = this._iterator.seek(wait.index).next(true);

      if (i === -1 || !this.feed._reserved.set(i, true)) return;
      wait.index = i;
    }

    this._request(wait.index, 0, wait.hash === true);

    return;
  }

  this._downloadRange(wait);
};

Peer.prototype._downloadBlocks = function (range) {
  while (range.blocksDownloaded < range.blocks.length) {
    const blk = range.blocks[range.blocksDownloaded];
    if (!this.feed.bitfield.get(blk)) break;
    range.blocksDownloaded++;
  }

  if (range.blocksDownloaded >= range.blocks.length) {
    set.remove(this.feed._selections, range);
    range.callback(null);
    return;
  }

  for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {
    const blk = range.blocks[i];

    if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {
      range.requested++;

      this._request(blk, 0, false);

      return;
    }
  }
};

Peer.prototype._downloadRange = function (range) {
  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end);
  var reserved = this.feed._reserved;
  var ite = this._iterator;
  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength);
  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd);
  var start = i;

  if (i === -1 || i >= wantedEnd) {
    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {
      set.remove(this.feed._selections, range);
      range.callback(null);
      if (!this.live && !this.sparse && !this.feed._selections.length) this.end();
    }

    return;
  }

  while (range.hash && this.feed.tree.get(2 * i) || !reserved.set(i, true)) {
    i = ite.next(true);

    if (i > -1 && i < wantedEnd) {
      // check this index
      continue;
    }

    if (!range.linear && start !== 0) {
      // retry from the beginning since we are iterating randomly and started !== 0
      i = ite.seek(range.start).next(true);
      start = 0;
      if (i > -1 && i < wantedEnd) continue;
    } // we have checked all indexes.
    // if we are looking for hashes we should check if we have all now (first check only checks blocks)


    if (range.hash) {
      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots
      // but we don't really request long ranges of hashes so yolo
      for (var j = range.start; j < wantedEnd; j++) {
        if (!this.feed.tree.get(2 * j)) return;
      }

      if (!range.bytes) {
        set.remove(this.feed._selections, range);
        range.callback(null);
      }
    } // exit the update loop - nothing to do


    return;
  }

  range.requested++;

  this._request(i, range.bytes || 0, range.hash);
};

Peer.prototype._request = function (index, bytes, hash) {
  var request = {
    bytes: bytes,
    index: index,
    hash: hash,
    nodes: this.feed.digest(index)
  };

  if (this._requestTimeout === null && this.stream.stream.timeout) {
    this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
  }

  this.inflightRequests.push(request);
  this.stream.request(request);
};

Peer.prototype.extension = function (id, message) {
  this.stream.extension(id, message);
};

function createView(page) {
  var buf = page ? page.buffer : EMPTY;
  return new DataView(buf.buffer, buf.byteOffset, 1024);
}

function remoteAndNotLocal(local, buf, le, start) {
  var remote = new DataView(buf.buffer, buf.byteOffset);
  var len = Math.floor(buf.length / 4);
  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len);
  var p = start / 8192; // 8192 is bits per bitfield page

  var l = 0;
  var page = createView(local.pages.get(p++, true));

  for (var i = 0; i < len; i++) {
    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * l++, !le);

    if (l === 256) {
      page = createView(local.pages.get(p++, true));
      l = 0;
    }
  }
}

function nextRandom(ite, start, end) {
  var len = end - start;
  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true);
  return i === -1 || i >= end ? ite.seek(start).next(true) : i;
}

},{"./tree-index":247,"bitfield-rle":37,"fast-bitfield":174,"hypercore-protocol":239,"timeout-refresh":570,"unordered-set":575}],245:[function(require,module,exports){
(function (Buffer){(function (){
// buffer-equals, but handle 'null' buffer parameters.
module.exports = function safeBufferEquals(a, b) {
  if (!a) return !b;
  if (!b) return !a;
  return Buffer.compare(a, b) === 0;
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],246:[function(require,module,exports){
(function (process,Buffer){(function (){
var uint64be = require('uint64be');

var flat = require('flat-tree');

var createCache = require("./cache");

module.exports = Storage;
var noarr = [];

function Storage(create, opts) {
  if (!(this instanceof Storage)) return new Storage(create, opts);
  const cache = createCache(opts);
  this.treeCache = cache.tree || null;
  this.dataCache = cache.data || null;
  this.key = null;
  this.secretKey = null;
  this.tree = null;
  this.data = null;
  this.bitfield = null;
  this.signatures = null;
  this.create = create;
}

Storage.prototype.putData = function (index, data, nodes, cb) {
  if (!cb) cb = noop;
  var self = this;
  if (!data.length) return cb(null);
  this.dataOffset(index, nodes, function (err, offset, size) {
    if (err) return cb(err);
    if (size !== data.length) return cb(new Error('Unexpected data size'));
    self.data.write(offset, data, cb);
  });
};

Storage.prototype.getData = function (index, cb) {
  var self = this;
  var cached = this.dataCache && this.dataCache.get(index);
  if (cached) return process.nextTick(cb, null, cached);
  this.dataOffset(index, noarr, function (err, offset, size) {
    if (err) return cb(err);
    self.data.read(offset, size, (err, data) => {
      if (err) return cb(err);
      if (self.dataCache) self.dataCache.set(index, data);
      return cb(null, data);
    });
  });
};

Storage.prototype.nextSignature = function (index, cb) {
  var self = this;

  this._getSignature(index, function (err, signature) {
    if (err) return cb(err);
    if (isBlank(signature)) return self.nextSignature(index + 1, cb);
    cb(null, {
      index: index,
      signature: signature
    });
  });
};

Storage.prototype.getSignature = function (index, cb) {
  this._getSignature(index, function (err, signature) {
    if (err) return cb(err);
    if (isBlank(signature)) return cb(new Error('No signature found'));
    cb(null, signature);
  });
}; // Caching not enabled for signatures because they are rarely reused.


Storage.prototype._getSignature = function (index, cb) {
  this.signatures.read(32 + 64 * index, 64, cb);
};

Storage.prototype.putSignature = function (index, signature, cb) {
  this.signatures.write(32 + 64 * index, signature, cb);
};

Storage.prototype.deleteSignatures = function (start, end, cb) {
  this.signatures.del(32 + 64 * start, (end - start) * 64, cb);
};

Storage.prototype.dataOffset = function (index, cachedNodes, cb) {
  var roots = flat.fullRoots(2 * index);
  var self = this;
  var offset = 0;
  var pending = roots.length;
  var error = null;
  var blk = 2 * index;

  if (!pending) {
    pending = 1;
    onnode(null, null);
    return;
  }

  for (var i = 0; i < roots.length; i++) {
    var node = findNode(cachedNodes, roots[i]);
    if (node) onnode(null, node);else this.getNode(roots[i], onnode);
  }

  function onlast(err, node) {
    if (err) return cb(err);
    cb(null, offset, node.size);
  }

  function onnode(err, node) {
    if (err) error = err;
    if (node) offset += node.size;
    if (--pending) return;
    if (error) return cb(error);
    var last = findNode(cachedNodes, blk);
    if (last) onlast(null, last);else self.getNode(blk, onlast);
  }
}; // Caching not enabled for batch reads because they'd be complicated to batch and they're rarely used.


Storage.prototype.getDataBatch = function (start, n, cb) {
  var result = new Array(n);
  var sizes = new Array(n);
  var self = this;
  this.dataOffset(start, noarr, function (err, offset, size) {
    if (err) return cb(err);
    start++;
    n--;
    if (n <= 0) return ontree(null, null);
    self.tree.read(32 + 80 * start, 80 * n - 40, ontree);

    function ontree(err, buf) {
      if (err) return cb(err);
      var total = sizes[0] = size;

      if (buf) {
        for (var i = 1; i < sizes.length; i++) {
          sizes[i] = uint64be.decode(buf, 32 + (i - 1) * 80);
          total += sizes[i];
        }
      }

      self.data.read(offset, total, ondata);
    }

    function ondata(err, buf) {
      if (err) return cb(err);
      var total = 0;

      for (var i = 0; i < result.length; i++) {
        result[i] = buf.slice(total, total += sizes[i]);
      }

      cb(null, result);
    }
  });
};

Storage.prototype.getNode = function (index, cb) {
  if (this.treeCache) {
    var cached = this.treeCache.get(index);
    if (cached) return cb(null, cached);
  }

  var self = this;
  this.tree.read(32 + 40 * index, 40, function (err, buf) {
    if (err) return cb(err);
    var hash = buf.slice(0, 32);
    var size = uint64be.decode(buf, 32);
    if (!size && isBlank(hash)) return cb(new Error('No node found'));
    var val = new Node(index, self.treeCache ? copyMaybe(hash, 40) : hash, size, null);
    if (self.treeCache) self.treeCache.set(index, val);
    cb(null, val);
  });
};

Storage.prototype.putNodeBatch = function (index, nodes, cb) {
  if (!cb) cb = noop;
  var buf = Buffer.alloc(nodes.length * 40);

  for (var i = 0; i < nodes.length; i++) {
    var offset = i * 40;
    var node = nodes[i];
    if (!node) continue;
    node.hash.copy(buf, offset);
    uint64be.encode(node.size, buf, 32 + offset);
  }

  this.tree.write(32 + 40 * index, buf, cb);
};

Storage.prototype.putNode = function (index, node, cb) {
  if (!cb) cb = noop; // TODO: re-enable put cache. currently this causes a memleak
  // because node.hash is a slice of the big data buffer on replicate
  // if (this.cache) this.cache.set(index, node)

  var buf = Buffer.allocUnsafe(40);
  node.hash.copy(buf, 0);
  uint64be.encode(node.size, buf, 32);
  this.tree.write(32 + 40 * index, buf, cb);
};

Storage.prototype.putBitfield = function (offset, data, cb) {
  this.bitfield.write(32 + offset, data, cb);
};

Storage.prototype.close = function (cb) {
  if (!cb) cb = noop;
  var missing = 6;
  var error = null;
  close(this.bitfield, done);
  close(this.tree, done);
  close(this.data, done);
  close(this.key, done);
  close(this.secretKey, done);
  close(this.signatures, done);

  function done(err) {
    if (err) error = err;
    if (--missing) return;
    cb(error);
  }
};

Storage.prototype.destroy = function (cb) {
  if (!cb) cb = noop;
  var missing = 6;
  var error = null;
  destroy(this.bitfield, done);
  destroy(this.tree, done);
  destroy(this.data, done);
  destroy(this.key, done);
  destroy(this.secretKey, done);
  destroy(this.signatures, done);

  function done(err) {
    if (err) error = err;
    if (--missing) return;
    cb(error);
  }
};

Storage.prototype.openKey = function (opts, cb) {
  if (typeof opts === 'function') return this.openKey({}, opts);
  if (!this.key) this.key = this.create('key', opts);
  this.key.read(0, 32, cb);
};

Storage.prototype.open = function (opts, cb) {
  if (typeof opts === 'function') return this.open({}, opts);
  var self = this;
  var error = null;
  var missing = 5;
  if (!this.key) this.key = this.create('key', opts);
  if (!this.secretKey) this.secretKey = this.create('secret_key', opts);
  if (!this.tree) this.tree = this.create('tree', opts);
  if (!this.data) this.data = this.create('data', opts);
  if (!this.bitfield) this.bitfield = this.create('bitfield', opts);
  if (!this.signatures) this.signatures = this.create('signatures', opts);
  var result = {
    bitfield: [],
    bitfieldPageSize: 3584,
    // we upgraded the page size to fix a bug
    secretKey: null,
    key: null
  };
  this.bitfield.read(0, 32, function (err, h) {
    if (err && err.code === 'ELOCKED') return cb(err);
    if (h) result.bitfieldPageSize = h.readUInt16BE(5);
    self.bitfield.write(0, header(0, result.bitfieldPageSize, null), function (err) {
      if (err) return cb(err);
      readAll(self.bitfield, 32, result.bitfieldPageSize, function (err, pages) {
        if (pages) result.bitfield = pages;
        done(err);
      });
    });
  });
  this.signatures.write(0, header(1, 64, 'Ed25519'), done);
  this.tree.write(0, header(2, 40, 'BLAKE2b'), done); // TODO: Improve the error handling here.
  // I.e. if secretKey length === 64 and it fails, error

  this.secretKey.read(0, 64, function (_, data) {
    if (data) result.secretKey = data;
    done(null);
  });
  this.key.read(0, 32, function (_, data) {
    if (data) result.key = data;
    done(null);
  });

  function done(err) {
    if (err) error = err;
    if (--missing) return;
    if (error) cb(error);else cb(null, result);
  }
};

Storage.Node = Node;

function noop() {}

function copyMaybe(buf, maxSize) {
  if (buf.buffer.byteLength <= maxSize) return buf;
  const cpy = Buffer.alloc(buf.byteLength);
  buf.copy(cpy);
  return cpy;
}

function header(type, size, name) {
  var buf = Buffer.alloc(32); // magic number

  buf[0] = 5;
  buf[1] = 2;
  buf[2] = 87;
  buf[3] = type; // version

  buf[4] = 0; // block size

  buf.writeUInt16BE(size, 5);

  if (name) {
    // algo name
    buf[7] = name.length;
    buf.write(name, 8);
  }

  return buf;
}

function Node(index, hash, size) {
  this.index = index;
  this.hash = hash;
  this.size = size;
}

function findNode(nodes, index) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].index === index) return nodes[i];
  }

  return null;
}

function isBlank(buf) {
  for (var i = 0; i < buf.length; i++) {
    if (buf[i]) return false;
  }

  return true;
}

function close(st, cb) {
  if (st.close) st.close(cb);else cb();
}

function destroy(st, cb) {
  if (st.destroy) st.destroy(cb);else cb();
}

function statAndReadAll(st, offset, pageSize, cb) {
  st.stat(function (err, stat) {
    if (err) return cb(null, []);
    var result = [];
    loop(null, null);

    function loop(err, batch) {
      if (err) return cb(err);

      if (batch) {
        offset += batch.length;

        for (var i = 0; i < batch.length; i += pageSize) {
          result.push(batch.slice(i, i + pageSize));
        }
      }

      var next = Math.min(stat.size - offset, 32 * pageSize);
      if (!next) return cb(null, result);
      st.read(offset, next, loop);
    }
  });
}

function readAll(st, offset, pageSize, cb) {
  if (st.statable === true) return statAndReadAll(st, offset, pageSize, cb);
  var bufs = [];
  st.read(offset, pageSize, loop);

  function loop(err, buf) {
    if (err) return cb(null, bufs);
    bufs.push(buf);
    st.read(offset + bufs.length * pageSize, pageSize, loop);
  }
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./cache":243,"_process":380,"buffer":97,"flat-tree":180,"uint64be":572}],247:[function(require,module,exports){
var flat = require('flat-tree');

var bitfield = require('sparse-bitfield');

module.exports = TreeIndex;

function TreeIndex(bits) {
  if (!(this instanceof TreeIndex)) return new TreeIndex(bits);
  this.bitfield = bits || bitfield();
}

TreeIndex.prototype.proof = function (index, opts) {
  if (!opts) opts = {};
  var nodes = [];
  var remoteTree = opts.tree || new TreeIndex();
  var digest = opts.digest || 0;
  if (!this.get(index)) return null;
  if (opts.hash) nodes.push(index); // always return hash - no matter what the digest says

  if (digest === 1) return {
    nodes: nodes,
    verifiedBy: 0
  };
  var roots = null;
  var sibling = index;
  var next = index;
  var hasRoot = digest & 1;
  digest = rightShift(digest);

  while (digest) {
    if (digest === 1 && hasRoot) {
      if (this.get(next)) remoteTree.set(next); // having a root implies having prev roots as well
      // TODO: this can be optimized away be only sending "newer" roots,
      // when sending roots

      if (flat.sibling(next) < next) next = flat.sibling(next);
      roots = flat.fullRoots(flat.rightSpan(next) + 2);

      for (var i = 0; i < roots.length; i++) {
        if (this.get(roots[i])) remoteTree.set(roots[i]);
      }

      break;
    }

    sibling = flat.sibling(next);

    if (digest & 1) {
      if (this.get(sibling)) remoteTree.set(sibling);
    }

    next = flat.parent(next);
    digest = rightShift(digest);
  }

  next = index;

  while (!remoteTree.get(next)) {
    sibling = flat.sibling(next);

    if (!this.get(sibling)) {
      // next is a local root
      var verifiedBy = this.verifiedBy(next);
      addFullRoots(verifiedBy, nodes, next, remoteTree);
      return {
        nodes: nodes,
        verifiedBy: verifiedBy
      };
    } else {
      if (!remoteTree.get(sibling)) nodes.push(sibling);
    }

    next = flat.parent(next);
  }

  return {
    nodes: nodes,
    verifiedBy: 0
  };
};

TreeIndex.prototype.digest = function (index) {
  if (this.get(index)) return 1;
  var digest = 0;
  var next = flat.sibling(index);
  var max = Math.max(next + 2, this.bitfield.length); // TODO: make this less ... hacky

  var bit = 2;
  var depth = flat.depth(index);
  var parent = flat.parent(next, depth++);

  while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
    if (this.get(next)) {
      digest += bit; // + cause in this case it's the same as | but works for large nums
    }

    if (this.get(parent)) {
      digest += 2 * bit;
      if (!(digest & 1)) digest += 1;
      if (digest + 1 === 4 * bit) return 1;
      return digest;
    }

    next = flat.sibling(parent);
    parent = flat.parent(next, depth++);
    bit *= 2;
  }

  return digest;
};

TreeIndex.prototype.blocks = function () {
  var top = 0;
  var next = 0;
  var max = this.bitfield.length;

  while (flat.rightSpan(next) < max) {
    next = flat.parent(next);
    if (this.get(next)) top = next;
  }

  return (this.get(top) ? this.verifiedBy(top) : 0) / 2;
};

TreeIndex.prototype.roots = function () {
  return flat.fullRoots(2 * this.blocks());
};

TreeIndex.prototype.verifiedBy = function (index, nodes) {
  var hasIndex = this.get(index);
  if (!hasIndex) return 0; // find root of current tree

  var depth = flat.depth(index);
  var top = index;
  var parent = flat.parent(top, depth++);

  while (this.get(parent) && this.get(flat.sibling(top))) {
    top = parent;
    parent = flat.parent(top, depth++);
  } // expand right down


  depth--;

  while (depth) {
    top = flat.leftChild(flat.index(depth, flat.offset(top, depth) + 1), depth);
    depth--;

    while (!this.get(top) && depth) top = flat.leftChild(top, depth--);

    if (nodes && this.get(top)) nodes.push(top);
  }

  return this.get(top) ? top + 2 : top;
};

TreeIndex.prototype.get = function (index) {
  return this.bitfield.get(index);
};

TreeIndex.prototype.truncate = function (len) {
  const currentLen = 2 * this.blocks();
  const roots = flat.fullRoots(len);

  for (let i = len; i < currentLen; i++) {
    this.bitfield.set(i, false);
  }

  for (const root of roots) {
    let p = flat.parent(root);

    while (p < len) {
      this.bitfield.set(p, false);
      p = flat.parent(p);
    }
  }
};

TreeIndex.prototype.set = function (index) {
  if (!this.bitfield.set(index, true)) return false;

  while (this.bitfield.get(flat.sibling(index))) {
    index = flat.parent(index);
    if (!this.bitfield.set(index, true)) break;
  }

  return true;
};

function rightShift(n) {
  return (n - (n & 1)) / 2;
}

function addFullRoots(verifiedBy, nodes, root, remoteTree) {
  var roots = flat.fullRoots(verifiedBy);

  for (var i = 0; i < roots.length; i++) {
    if (roots[i] !== root && !remoteTree.get(roots[i])) nodes.push(roots[i]);
  }
}

},{"flat-tree":180,"sparse-bitfield":547}],248:[function(require,module,exports){
(function (__dirname){(function (){
const p = require('path');

const API_VERSION = 0;
module.exports = {
  hyperdriveSchemaPath: p.join(__dirname, 'schemas', 'hyperdrive.proto'),
  messages: require("./lib/messages"),
  Stat: require("./lib/stat"),
  version: API_VERSION
};

}).call(this)}).call(this,"/node_modules/hyperdrive-schemas")
},{"./lib/messages":249,"./lib/stat":250,"path":371}],249:[function(require,module,exports){
(function (Buffer){(function (){
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */

/* eslint-disable indent */

/* eslint-disable no-redeclare */

/* eslint-disable camelcase */
// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings');

var varint = encodings.varint;
var skip = encodings.skip;
var Index = exports.Index = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Mount = exports.Mount = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Stat = exports.Stat = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Map_string_bytes = exports.Map_string_bytes = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
defineIndex();
defineMount();
defineStat();
defineMap_string_bytes();

function defineIndex() {
  var enc = [encodings.string, encodings.bytes];
  Index.encodingLength = encodingLength;
  Index.encode = encode;
  Index.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.type)) throw new Error("type is required");
    var len = enc[0].encodingLength(obj.type);
    length += 1 + len;

    if (defined(obj.content)) {
      var len = enc[1].encodingLength(obj.content);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.type)) throw new Error("type is required");
    buf[offset++] = 10;
    enc[0].encode(obj.type, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.content)) {
      buf[offset++] = 18;
      enc[1].encode(obj.content, buf, offset);
      offset += enc[1].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      type: "",
      content: null
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.type = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.content = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineMount() {
  var enc = [encodings.bytes, encodings.varint, encodings.bool];
  Mount.encodingLength = encodingLength;
  Mount.encode = encode;
  Mount.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.key)) throw new Error("key is required");
    var len = enc[0].encodingLength(obj.key);
    length += 1 + len;

    if (defined(obj.version)) {
      var len = enc[1].encodingLength(obj.version);
      length += 1 + len;
    }

    if (defined(obj.hash)) {
      var len = enc[0].encodingLength(obj.hash);
      length += 1 + len;
    }

    if (defined(obj.hypercore)) {
      var len = enc[2].encodingLength(obj.hypercore);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.key)) throw new Error("key is required");
    buf[offset++] = 10;
    enc[0].encode(obj.key, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.version)) {
      buf[offset++] = 16;
      enc[1].encode(obj.version, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.hash)) {
      buf[offset++] = 26;
      enc[0].encode(obj.hash, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.hypercore)) {
      buf[offset++] = 32;
      enc[2].encode(obj.hypercore, buf, offset);
      offset += enc[2].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      key: null,
      version: 0,
      hash: null,
      hypercore: false
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.key = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.version = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 3:
          obj.hash = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 4:
          obj.hypercore = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineStat() {
  var enc = [encodings.varint, encodings.string, Mount, Map_string_bytes];
  Stat.encodingLength = encodingLength;
  Stat.encode = encode;
  Stat.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.mode)) throw new Error("mode is required");
    var len = enc[0].encodingLength(obj.mode);
    length += 1 + len;

    if (defined(obj.uid)) {
      var len = enc[0].encodingLength(obj.uid);
      length += 1 + len;
    }

    if (defined(obj.gid)) {
      var len = enc[0].encodingLength(obj.gid);
      length += 1 + len;
    }

    if (defined(obj.size)) {
      var len = enc[0].encodingLength(obj.size);
      length += 1 + len;
    }

    if (defined(obj.blocks)) {
      var len = enc[0].encodingLength(obj.blocks);
      length += 1 + len;
    }

    if (defined(obj.offset)) {
      var len = enc[0].encodingLength(obj.offset);
      length += 1 + len;
    }

    if (defined(obj.byteOffset)) {
      var len = enc[0].encodingLength(obj.byteOffset);
      length += 1 + len;
    }

    if (defined(obj.mtime)) {
      var len = enc[0].encodingLength(obj.mtime);
      length += 1 + len;
    }

    if (defined(obj.ctime)) {
      var len = enc[0].encodingLength(obj.ctime);
      length += 1 + len;
    }

    if (defined(obj.linkname)) {
      var len = enc[1].encodingLength(obj.linkname);
      length += 1 + len;
    }

    if (defined(obj.mount)) {
      var len = enc[2].encodingLength(obj.mount);
      length += varint.encodingLength(len);
      length += 1 + len;
    }

    if (defined(obj.metadata)) {
      var tmp = Object.keys(obj.metadata);

      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {
          key: tmp[i],
          value: obj.metadata[tmp[i]]
        };
      }

      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue;
        var len = enc[3].encodingLength(tmp[i]);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.mode)) throw new Error("mode is required");
    buf[offset++] = 8;
    enc[0].encode(obj.mode, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.uid)) {
      buf[offset++] = 16;
      enc[0].encode(obj.uid, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.gid)) {
      buf[offset++] = 24;
      enc[0].encode(obj.gid, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.size)) {
      buf[offset++] = 32;
      enc[0].encode(obj.size, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.blocks)) {
      buf[offset++] = 40;
      enc[0].encode(obj.blocks, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.offset)) {
      buf[offset++] = 48;
      enc[0].encode(obj.offset, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.byteOffset)) {
      buf[offset++] = 56;
      enc[0].encode(obj.byteOffset, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.mtime)) {
      buf[offset++] = 64;
      enc[0].encode(obj.mtime, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.ctime)) {
      buf[offset++] = 72;
      enc[0].encode(obj.ctime, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.linkname)) {
      buf[offset++] = 82;
      enc[1].encode(obj.linkname, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.mount)) {
      buf[offset++] = 90;
      varint.encode(enc[2].encodingLength(obj.mount), buf, offset);
      offset += varint.encode.bytes;
      enc[2].encode(obj.mount, buf, offset);
      offset += enc[2].encode.bytes;
    }

    if (defined(obj.metadata)) {
      var tmp = Object.keys(obj.metadata);

      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {
          key: tmp[i],
          value: obj.metadata[tmp[i]]
        };
      }

      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue;
        buf[offset++] = 98;
        varint.encode(enc[3].encodingLength(tmp[i]), buf, offset);
        offset += varint.encode.bytes;
        enc[3].encode(tmp[i], buf, offset);
        offset += enc[3].encode.bytes;
      }
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0,
      blocks: 0,
      offset: 0,
      byteOffset: 0,
      mtime: 0,
      ctime: 0,
      linkname: "",
      mount: null,
      metadata: {}
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.mode = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.uid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 3:
          obj.gid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 4:
          obj.size = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 5:
          obj.blocks = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 6:
          obj.offset = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 7:
          obj.byteOffset = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 8:
          obj.mtime = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 9:
          obj.ctime = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 10:
          obj.linkname = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 11:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.mount = enc[2].decode(buf, offset, offset + len);
          offset += enc[2].decode.bytes;
          break;

        case 12:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tmp = enc[3].decode(buf, offset, offset + len);
          obj.metadata[tmp.key] = tmp.value;
          offset += enc[3].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineMap_string_bytes() {
  var enc = [encodings.string, encodings.bytes];
  Map_string_bytes.encodingLength = encodingLength;
  Map_string_bytes.encode = encode;
  Map_string_bytes.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.key)) throw new Error("key is required");
    var len = enc[0].encodingLength(obj.key);
    length += 1 + len;

    if (defined(obj.value)) {
      var len = enc[1].encodingLength(obj.value);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.key)) throw new Error("key is required");
    buf[offset++] = 10;
    enc[0].encode(obj.key, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.value)) {
      buf[offset++] = 18;
      enc[1].encode(obj.value, buf, offset);
      offset += enc[1].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      key: "",
      value: null
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.key = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.value = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"protocol-buffers-encodings":382}],250:[function(require,module,exports){
const {
  Stat: StatEncoder
} = require("./messages"); // http://man7.org/linux/man-pages/man2/stat.2.html


var DEFAULT_FMODE = (4 | 2 | 0) << 6 | (4 | 0 | 0) << 3 | (4 | 0 | 0); // rw-r--r--

var DEFAULT_DMODE = (4 | 2 | 1) << 6 | (4 | 0 | 1) << 3 | (4 | 0 | 1); // rwxr-xr-x

class Stat {
  constructor(data) {
    this.dev = 0;
    this.nlink = 1;
    this.rdev = 0;
    this.blksize = 0;
    this.ino = 0;
    this.mode = data && data.mode || 0;
    this.uid = data && data.uid || 0;
    this.gid = data && data.gid || 0;
    this.size = data && data.size || 0;
    this.offset = data && data.offset || 0;
    this.byteOffset = data && data.byteOffset || 0;
    this.blocks = data && data.blocks || 0;
    this.atime = data && data.atime ? new Date(data.atime) : new Date(); // we just set this to mtime ...

    this.mtime = data && data.mtime ? new Date(data.mtime) : new Date();
    this.ctime = data && data.ctime ? new Date(data.ctime) : new Date();
    this.linkname = data && data.linkname || null;
    this.mount = data && data.mount || null;
    this.metadata = data && data.metadata || null;
  }

  _check(mask) {
    return (mask & this.mode) === mask;
  }

  encode() {
    return StatEncoder.encode(this);
  }

  isSocket() {
    return this._check(Stat.IFSOCK);
  }

  isSymbolicLink() {
    return this._check(Stat.IFLNK);
  }

  isFile() {
    return this._check(Stat.IFREG);
  }

  isBlockDevice() {
    return this._check(Stat.IFBLK);
  }

  isDirectory() {
    return this._check(Stat.IFDIR);
  }

  isCharacterDevice() {
    return this._check(Stat.IFCHR);
  }

  isFIFO() {
    return this._check(Stat.IFIFO);
  }

}

Stat.file = function (data) {
  data = data || {};
  data.mode = (data.mode || DEFAULT_FMODE) | Stat.IFREG;
  return new Stat(data);
};

Stat.directory = function (data) {
  data = data || {};
  data.mode = (data.mode || DEFAULT_DMODE) | Stat.IFDIR;
  return new Stat(data);
};

Stat.symlink = function (data) {
  data = data || {};
  data.mode = (data.mode || DEFAULT_FMODE) | Stat.IFLNK;
  return new Stat(data);
};

Stat.decode = function (encodedStat) {
  const st = StatEncoder.decode(encodedStat);
  return new Stat(st);
};

Stat.IFSOCK = 0b1100 << 12;
Stat.IFLNK = 0b1010 << 12;
Stat.IFREG = 0b1000 << 12;
Stat.IFBLK = 0b0110 << 12;
Stat.IFDIR = 0b0100 << 12;
Stat.IFCHR = 0b0010 << 12;
Stat.IFIFO = 0b0001 << 12;
module.exports = Stat;

},{"./messages":249}],251:[function(require,module,exports){
(function (process,Buffer){(function (){
const pathRoot = require('path');

const path = pathRoot.posix || pathRoot;

const {
  EventEmitter
} = require('events');

const collect = require('stream-collector');

const thunky = require('thunky');

const ThunkyMap = require('thunky-map');

const unixify = require('unixify');

const duplexify = require('duplexify');

const pump = require('pump');

const pumpify = require('pumpify');

const {
  Transform
} = require('streamx');

const coreByteStream = require('hypercore-byte-stream');

const Nanoresource = require('nanoresource/emitter');

const HypercoreProtocol = require('hypercore-protocol');

const MountableHypertrie = require('mountable-hypertrie');

const Corestore = require('corestore');

const {
  Stat
} = require('hyperdrive-schemas');

const createFileDescriptor = require("./lib/fd");

const errors = require("./lib/errors");

const defaultCorestore = require("./lib/storage");

const TagManager = require("./lib/tagging");

const HyperdrivePromises = require("./promises");

const {
  contentKeyPair,
  contentOptions,
  ContentState
} = require("./lib/content");

const {
  statIterator,
  createStatStream,
  createMountStream,
  createReaddirStream,
  readdirIterator
} = require("./lib/iterator"); // 20 is arbitrary, just to make the fds > stdio etc


const STDIO_CAP = 20;
const WRITE_STREAM_BLOCK_SIZE = 524288;
const NOOP_FILE_PATH = ' ';
module.exports = HyperdriveCompat;
module.exports.constants = require('filesystem-constants').linux;

class Hyperdrive extends Nanoresource {
  constructor(storage, key, opts) {
    super();

    this._initialize(storage, key, opts);
  }

  _initialize(storage, key, opts) {
    if (isObject(key)) {
      opts = key;
      key = null;
    }

    if (!opts) opts = {};
    this.opts = opts;
    this.key = key;
    this.discoveryKey = null;
    this.live = true;
    this.sparse = opts.sparse !== false;
    this.sparseMetadata = opts.sparseMetadata !== false;
    this.subtype = opts.subtype || 'hyperdrive';
    this.promises = new HyperdrivePromises(this);
    this._namespace = opts.namespace;
    this.corestore = defaultCorestore(storage, { ...opts,
      valueEncoding: 'binary',
      // TODO: Support mixed sparsity.
      sparse: this.sparse || this.sparseMetadata,
      extensions: opts.extensions
    });
    if (this.corestore !== storage) this.corestore.on('error', err => this.emit('error', err));

    if (opts.namespace) {
      this.corestore = this.corestore.namespace(opts.namespace);
    } // Set in ready.


    this.metadata = null;
    this.db = opts._db;
    this.tags = new TagManager(this);
    this.isCheckout = !!this.db;
    this._contentStates = opts._contentStates || new ThunkyMap(this._contentStateFromMetadata.bind(this));
    this._fds = [];
    this._writingFds = new Map();
    this._unlistens = [];
    this._unmirror = null;
    this._metadataOpts = {
      key,
      sparse: this.sparseMetadata,
      keyPair: opts.keyPair,
      extensions: opts.extensions
    };
    this.ready(onReady);
    const self = this;

    function onReady(err) {
      if (err) return self.emit('error', err);
      self.emit('ready');
      if (self._contentStates.has(self.db.feed)) return;

      self._getContent(self.db.feed, noop);
    }
  }

  get version() {
    // TODO: The trie version starts at 1, so the empty hyperdrive version is also 1. This should be 0.
    return this.db.version;
  }

  get writable() {
    return this.metadata.writable;
  }

  get contentWritable() {
    const contentState = this._contentStates.cache.get(this.db.feed);

    if (!contentState) return false;
    return contentState.feed.writable;
  }

  ready(cb) {
    return this.open(cb);
  }

  _open(cb) {
    const self = this;
    return this.corestore.ready(err => {
      if (err) return cb(err);
      this.metadata = this.corestore.default(this._metadataOpts);
      this.db = this.db || new MountableHypertrie(this.corestore, this.key, {
        feed: this.metadata,
        sparse: this.sparseMetadata,
        extension: this.opts.extension !== false,
        subtype: this.subtype
      });
      this.db.on('hypertrie', onhypertrie);
      this.db.on('error', onerror);
      self.metadata.on('error', onerror);
      self.metadata.on('append', update);
      self.metadata.on('extension', extension);
      self.metadata.on('peer-add', peeradd);
      self.metadata.on('peer-open', peeropen);
      self.metadata.on('peer-remove', peerremove);

      this._unlistens.push(() => {
        self.db.removeListener('error', onerror);
        self.db.removeListener('hypertrie', onhypertrie);
        self.metadata.removeListener('error', onerror);
        self.metadata.removeListener('append', update);
        self.metadata.removeListener('extension', extension);
        self.metadata.removeListener('peer-add', peeradd);
        self.metadata.removeListener('peer-open', peeropen);
        self.metadata.removeListener('peer-remove', peerremove);
      });

      return self.metadata.ready(err => {
        if (err) return done(err);
        /**
        * TODO: Update comment to reflect mounts.
        *
        * If a db is provided as input, ensure that a contentFeed is also provided, then return (this is a checkout).
        * If the metadata feed is writable:
        *    If the metadata feed has length 0, then the db should be initialized with the content feed key as metadata.
        *    Else, initialize the db without metadata and load the content feed key from the header.
        * If the metadata feed is readable:
        *    Initialize the db without metadata and load the content feed key from the header.
        */

        if (self.metadata.writable && !self.metadata.length && !self.isCheckout) {
          initialize();
        } else {
          restore();
        }
      });
    });
    /**
     * The first time the hyperdrive is created, we initialize both the db (metadata feed) and the content feed here.
     */

    function initialize() {
      const contentName = self.metadata.key.toString('hex') + '-content';

      self._contentStateFromOpts({
        name: contentName
      }, (err, contentState) => {
        if (err) return done(err); // warm up the thunky map

        self._contentStates.cache.set(self.db.feed, contentState);

        self.db.setMetadata(contentState.feed.key);
        self.db.ready(err => {
          if (err) return done(err);
          return done(null);
        });
      });
    }
    /**
     * If the hyperdrive has already been created, wait for the db (metadata feed) to load.
     * If the metadata feed is writable, we can immediately load the content feed from its private key.
     * (Otherwise, we need to read the feed's metadata block first)
     */


    function restore(keyPair) {
      self.db.ready(err => {
        if (err) return done(err);
        self.metadata.has(0, (err, hasMetadataBlock) => {
          if (err) return done(err);
          if (hasMetadataBlock) self._getContent(self.db.feed, done);else done(null);
        });
      });
    }

    function done(err) {
      if (err) return cb(err);
      self.key = self.metadata.key;
      self.discoveryKey = self.metadata.discoveryKey;
      return cb(null);
    }

    function onerror(err) {
      if (err) self.emit('error', err);
      return cb(err);
    }

    function update() {
      self.emit('update');
    }

    function extension(name, message, peer) {
      self.emit('extension', name, message, peer);
    }

    function peeradd(peer) {
      self.emit('peer-add', peer);
    }

    function peeropen(peer) {
      self.emit('peer-open', peer);
    }

    function peerremove(peer) {
      self.emit('peer-remove', peer);
    }

    function onhypertrie(trie) {
      self.emit('metadata-feed', trie.feed);
      self.emit('mount', trie);
    }
  }

  _getContent(metadata, cb) {
    this._contentStates.get(metadata, cb);
  }

  _contentStateFromMetadata(metadata, cb) {
    MountableHypertrie.getMetadata(metadata, (err, publicKey) => {
      if (err) return cb(err);

      this._contentStateFromKey(publicKey, cb);
    });
  }

  _contentStateFromKey(publicKey, cb) {
    this._contentStateFromOpts({
      key: publicKey
    }, cb);
  }

  _contentStateFromOpts(opts, cb) {
    const contentOpts = { ...opts,
      ...contentOptions(this),
      cache: {
        data: false
      }
    };

    try {
      var feed = this.corestore.get(contentOpts);
    } catch (err) {
      return cb(err);
    }

    const contentErrorListener = err => this.emit('error', err);

    feed.on('error', contentErrorListener);

    this._unlistens.push(() => feed.removeListener('error', contentErrorListener));

    feed.ready(err => {
      if (err) return cb(err);
      this.emit('content-feed', feed);
      return cb(null, new ContentState(feed));
    });
  }

  _putStat(name, stat, opts, cb) {
    if (typeof opts === 'function') return this._putStat(name, stat, null, opts);

    try {
      var encoded = stat.encode();
    } catch (err) {
      return cb(err);
    }

    this.db.put(name, encoded, opts, err => {
      if (err) return cb(err);
      return cb(null, stat);
    });
  }

  _update(name, stat, cb) {
    name = fixName(name);
    this.db.get(name, (err, st) => {
      if (err) return cb(err);
      if (!st) return cb(new errors.FileNotFound(name));

      try {
        var decoded = Stat.decode(st.value);
      } catch (err) {
        return cb(err);
      }

      const oldMetadata = decoded.metadata;
      const newStat = Object.assign(decoded, stat);

      if (stat.metadata) {
        newStat.metadata = Object.assign({}, oldMetadata || {}, stat.metadata);
      }

      return this._putStat(name, newStat, {
        flags: st.flags
      }, cb);
    });
  }

  _upsert(name, stat, cb) {
    name = fixName(name);
    this.db.get(name, (err, st) => {
      if (err) return cb(err);

      if (!st) {
        var decoded = Stat.file();
      } else {
        try {
          var decoded = Stat.decode(st.value);
        } catch (err) {
          return cb(err);
        }
      }

      const oldMetadata = decoded.metadata;
      const newStat = Object.assign(decoded, stat);

      if (stat.metadata) {
        newStat.metadata = Object.assign({}, oldMetadata || {}, stat.metadata);
      }

      return this._putStat(name, newStat, {
        flags: st ? st.flags : 0
      }, cb);
    });
  }

  getContent(cb) {
    if (!this.db) return cb(null, null);

    this._getContent(this.db.feed, (err, contentState) => {
      if (err) return cb(err);
      return cb(null, contentState.feed);
    });
  }

  open(name, flags, cb) {
    if (!name || typeof name === 'function') return super.open(name);
    name = fixName(name);
    this.ready(err => {
      if (err) return cb(err);
      createFileDescriptor(this, name, flags, (err, fd) => {
        if (err) return cb(err);
        cb(null, STDIO_CAP + (this._fds.push(fd) - 1) * 2);
      });
    });
  }

  read(fd, buf, offset, len, pos, cb) {
    if (typeof pos === 'function') {
      cb = pos;
      pos = null;
    }

    const desc = this._fds[(fd - STDIO_CAP) / 2];
    if (!desc) return process.nextTick(cb, new errors.BadFileDescriptor(`Bad file descriptor: ${fd}`));
    if (pos == null) pos = desc.position;
    desc.read(buf, offset, len, pos, cb);
  }

  write(fd, buf, offset, len, pos, cb) {
    if (typeof pos === 'function') {
      cb = pos;
      pos = null;
    }

    const desc = this._fds[(fd - STDIO_CAP) / 2];
    if (!desc) return process.nextTick(cb, new errors.BadFileDescriptor(`Bad file descriptor: ${fd}`));
    if (pos == null) pos = desc.position;
    desc.write(buf, offset, len, pos, cb);
  }

  createReadStream(name, opts) {
    if (!opts) opts = {};
    const self = this;
    name = fixName(name);
    const length = typeof opts.end === 'number' ? 1 + opts.end - (opts.start || 0) : typeof opts.length === 'number' ? opts.length : -1;
    const stream = coreByteStream({ ...opts,
      highWaterMark: opts.highWaterMark || 64 * 1024
    });
    this.ready(err => {
      if (err) return stream.destroy(err);
      return this.stat(name, {
        file: true
      }, (err, st, trie) => {
        if (err) return stream.destroy(err);

        if (st.mount && st.mount.hypercore) {
          const feed = self.corestore.get({
            key: st.mount.key,
            sparse: self.sparse
          });
          return feed.ready(err => {
            if (err) return stream.destroy(err);
            st.blocks = feed.length;
            return oncontent(st, {
              feed
            });
          });
        }

        return this._getContent(trie.feed, (err, contentState) => {
          if (err) return stream.destroy(err);
          return oncontent(st, contentState);
        });
      });
    });

    function oncontent(st, contentState) {
      if (st.mount && st.mount.hypercore) {
        var byteOffset = 0;
        var blockOffset = 0;
        var blockLength = st.blocks;
      } else {
        blockOffset = st.offset;
        blockLength = st.blocks;
        byteOffset = opts.start ? st.byteOffset + opts.start : length === -1 ? -1 : st.byteOffset;
      }

      const byteLength = Math.min(length, st.size);
      stream.start({
        feed: contentState.feed,
        blockOffset,
        blockLength,
        byteOffset,
        byteLength
      });
    }

    return stream;
  }

  createDiffStream(other, prefix, opts) {
    if (other instanceof Hyperdrive) other = other.version;
    if (typeof prefix === 'object') return this.createDiffStream(other, '/', prefix);
    prefix = prefix || '/';
    const diffStream = this.db.createDiffStream(other, prefix, opts);
    return pumpify.obj(diffStream, new Transform({
      transform(chunk, cb) {
        const entry = {
          type: chunk.type,
          name: chunk.key
        };
        if (chunk.left) entry.seq = chunk.left.seq;
        if (chunk.right) entry.previous = {
          seq: chunk.right.seq
        };

        if (chunk.left && entry.type !== 'mount' && entry.type !== 'unmount') {
          try {
            entry.value = Stat.decode(chunk.left.value);
          } catch (err) {
            return cb(err);
          }
        } else if (chunk.left) {
          entry.value = chunk.left.info;
        }

        return cb(null, entry);
      }

    }));
  }

  createDirectoryStream(name, opts) {
    if (!opts) opts = {};
    name = fixName(name);
    return createReaddirStream(this, name, { ...opts,
      includeStats: true
    });
  }

  createWriteStream(name, opts) {
    if (!opts) opts = {};
    name = fixName(name);
    const self = this;
    var release;
    const proxy = duplexify();
    proxy.setReadable(false); // TODO: support piping through a "split" stream like rabin

    this.ready(err => {
      if (err) return proxy.destroy(err);
      this.stat(name, {
        trie: true
      }, (err, stat, trie) => {
        if (err && err.errno !== 2) return proxy.destroy(err);

        this._getContent(trie.feed, (err, contentState) => {
          if (err) return proxy.destroy(err);
          if (opts.wait === false && contentState.isLocked()) return cb(new Error('Content is locked.'));
          contentState.lock(_release => {
            release = _release;
            append(contentState);
          });
        });
      });
    });
    return proxy;

    function append(contentState) {
      if (proxy.destroyed) return release();
      const byteOffset = contentState.feed.byteLength;
      const offset = contentState.feed.length;
      self.emit('appending', name, opts); // TODO: revert the content feed if this fails!!!! (add an option to the write stream for this (atomic: true))

      const stream = contentState.feed.createWriteStream({
        maxBlockSize: WRITE_STREAM_BLOCK_SIZE
      });
      proxy.on('close', ondone);
      proxy.on('finish', ondone);
      proxy.setWritable(stream);
      proxy.on('prefinish', function () {
        const stat = Stat.file({ ...opts,
          offset,
          byteOffset,
          size: contentState.feed.byteLength - byteOffset,
          blocks: contentState.feed.length - offset
        });
        proxy.cork();

        self._putStat(name, stat, function (err) {
          if (err) return proxy.destroy(err);
          self.emit('append', name, opts);
          proxy.uncork();
        });
      });
    }

    function ondone() {
      proxy.removeListener('close', ondone);
      proxy.removeListener('finish', ondone);
      release();
    }
  }

  create(name, opts, cb) {
    if (typeof opts === 'function') return this.create(name, null, opts);
    name = fixName(name);
    this.ready(err => {
      if (err) return cb(err);
      this.lstat(name, {
        file: true,
        trie: true
      }, (err, stat) => {
        if (err && err.errno !== 2) return cb(err);
        if (stat) return cb(null, stat);
        const st = Stat.file(opts);
        return this._putStat(name, st, cb);
      });
    });
  }

  readFile(name, opts, cb) {
    if (typeof opts === 'function') return this.readFile(name, null, opts);
    if (typeof opts === 'string') opts = {
      encoding: opts
    };
    if (!opts) opts = {};
    name = fixName(name);
    collect(this.createReadStream(name, opts), function (err, bufs) {
      if (err) return cb(err);
      let buf = bufs.length === 1 ? bufs[0] : Buffer.concat(bufs);
      cb(null, opts.encoding && opts.encoding !== 'binary' ? buf.toString(opts.encoding) : buf);
    });
  }

  writeFile(name, buf, opts, cb) {
    if (typeof opts === 'function') return this.writeFile(name, buf, null, opts);
    if (typeof opts === 'string') opts = {
      encoding: opts
    };
    if (!opts) opts = {};
    if (typeof buf === 'string') buf = Buffer.from(buf, opts.encoding || 'utf-8');
    if (!cb) cb = noop;
    name = fixName(name); // Make sure that the buffer is chunked into blocks of 0.5MB.

    let stream = this.createWriteStream(name, opts); // TODO: Do we need to maintain the error state? What's triggering 'finish' after 'error'?

    var errored = false;
    stream.on('error', err => {
      errored = true;
      return cb(err);
    });
    stream.on('finish', () => {
      if (!errored) return cb(null);
    });
    stream.end(buf);
  }

  truncate(name, size, cb) {
    name = fixName(name);
    this.lstat(name, {
      file: true,
      trie: true
    }, (err, st) => {
      if (err && err.errno !== 2) return cb(err);
      if (!st || !size) return this.create(name, cb);
      if (size === st.size) return cb(null);

      if (size < st.size) {
        const readStream = this.createReadStream(name, {
          length: size
        });
        const writeStream = this.createWriteStream(name);
        return pump(readStream, writeStream, cb);
      } else {
        this.open(name, 'a', (err, fd) => {
          if (err) return cb(err);
          const length = size - st.size;
          this.write(fd, Buffer.alloc(length), 0, length, st.size, err => {
            if (err) return cb(err);
            this.close(fd, cb);
          });
        });
      }
    });
  }

  ftruncate(fd, size, cb) {
    const desc = this._fds[(fd - STDIO_CAP) / 2];
    if (!desc) return process.nextTick(cb, new errors.BadFileDescriptor(`Bad file descriptor: ${fd}`));
    return desc.truncate(size, cb);
  }

  _createStat(name, opts, cb) {
    const self = this;
    const statConstructor = opts && opts.directory ? Stat.directory : Stat.file;
    const shouldForce = !!opts.force;
    this.ready(err => {
      if (err) return cb(err);
      this.db.get(name, (err, node, trie) => {
        if (err) return cb(err);
        if (node && !shouldForce) return cb(new errors.PathAlreadyExists(name));
        onexisting(node, trie);
      });
    });

    function onexisting(node, trie) {
      self.ready(err => {
        if (err) return cb(err);

        self._getContent(trie.feed, (err, contentState) => {
          if (err) return cb(err);
          const st = statConstructor({ ...opts,
            offset: contentState.feed.length,
            byteOffset: contentState.feed.byteLength
          });
          return cb(null, st);
        });
      });
    }
  }

  mkdir(name, opts, cb) {
    if (typeof opts === 'function') return this.mkdir(name, null, opts);
    if (typeof opts === 'number') opts = {
      mode: opts
    };
    if (!opts) opts = {};
    if (!cb) cb = noop;
    name = fixName(name);
    opts.directory = true;

    this._createStat(name, opts, (err, st) => {
      if (err) return cb(err);

      this._putStat(name, st, {
        condition: ifNotExists
      }, cb);
    });
  }

  _statDirectory(name, opts, cb) {
    const ite = this.db.iterator(name);
    ite.next((err, st) => {
      if (err) return cb(err);
      if (name !== '/' && !st) return cb(new errors.FileNotFound(name));
      if (name === '/') return cb(null, Stat.directory(), this.db);
      const trie = st[MountableHypertrie.Symbols.TRIE];
      const mount = st[MountableHypertrie.Symbols.MOUNT];
      const innerPath = st[MountableHypertrie.Symbols.INNER_PATH];

      try {
        st = Stat.decode(st.value);
      } catch (err) {
        return cb(err);
      }

      const noMode = Object.assign({}, st, {
        mode: 0
      });
      return cb(null, Stat.directory(noMode), trie, mount, innerPath);
    });
  }

  readlink(name, cb) {
    this.lstat(name, function (err, st) {
      if (err) return cb(err);
      cb(null, st.linkname);
    });
  }

  lstat(name, opts, cb) {
    if (typeof opts === 'function') return this.lstat(name, null, opts);
    if (!opts) opts = {};
    const self = this;
    name = fixName(name);
    this.ready(err => {
      if (err) return cb(err);
      this.db.get(name, opts, onstat);
    });

    function onstat(err, node, trie, mount, mountPath) {
      if (err) return cb(err);
      if (!node && opts.trie) return cb(null, null, trie, mount, mountPath);
      if (!node && opts.file) return cb(new errors.FileNotFound(name));
      if (!node) return self._statDirectory(name, opts, cb);

      try {
        var st = Stat.decode(node.value);
      } catch (err) {
        return cb(err);
      }

      const writingFd = self._writingFds.get(name);

      if (writingFd) {
        st.size = writingFd.stat.size;
      }

      cb(null, st, trie, mount, mountPath);
    }
  }

  stat(name, opts, cb) {
    if (typeof opts === 'function') return this.stat(name, null, opts);
    if (!opts) opts = {};
    this.lstat(name, opts, (err, stat, trie, mount, mountPath) => {
      if (err) return cb(err);
      if (!stat) return cb(null, null, trie, name, mount, mountPath);

      if (stat.linkname) {
        if (path.isAbsolute(stat.linkname)) return this.stat(stat.linkname, opts, cb);
        const relativeStat = path.resolve('/', path.dirname(name), stat.linkname);
        return this.stat(relativeStat, opts, cb);
      }

      return cb(null, stat, trie, name, mount, mountPath);
    });
  }

  info(name, cb) {
    name = fixName(name);
    const noopPath = path.join(name, NOOP_FILE_PATH);
    this.stat(noopPath, {
      trie: true
    }, (err, stat, trie, _, mountInfo, mountPath) => {
      if (err) return cb(err);
      return cb(null, {
        feed: trie.feed,
        mountPath: fixName(noopPath.slice(0, noopPath.length - mountPath.length)),
        mountInfo
      });
    });
  }

  access(name, opts, cb) {
    if (typeof opts === 'function') return this.access(name, null, opts);
    if (!opts) opts = {};
    name = fixName(name);
    this.stat(name, opts, err => {
      cb(err);
    });
  }

  exists(name, opts, cb) {
    if (typeof opts === 'function') return this.exists(name, null, opts);
    if (!opts) opts = {};
    this.access(name, opts, err => {
      cb(!err);
    });
  }

  readdir(name, opts, cb) {
    if (typeof opts === 'function') return this.readdir(name, null, opts);
    name = fixName(name);
    const readdirStream = createReaddirStream(this, name, opts);
    return collect(readdirStream, (err, entries) => {
      if (err) return cb(err);
      return cb(null, entries);
    });
  }

  _del(name, cb) {
    this.ready(err => {
      if (err) return cb(err);
      this.db.del(name, (err, node) => {
        if (err) return cb(err);
        if (!node) return cb(new errors.FileNotFound(name));
        return cb(null);
      });
    });
  }

  unlink(name, cb) {
    name = fixName(name);

    this._del(name, cb || noop);
  }

  rmdir(name, cb) {
    if (!cb) cb = noop;
    name = fixName(name);
    const self = this;
    const ite = readdirIterator(this, name);
    ite.next((err, val) => {
      if (err) return cb(err);
      if (val) return cb(new errors.DirectoryNotEmpty(name));

      self._del(name, cb);
    });
  }

  replicate(isInitiator, opts) {
    // support replicate({ initiator: bool }) also
    if (typeof isInitiator === 'object' && isInitiator && !opts) {
      opts = isInitiator;
      isInitiator = !!opts.initiator;
    }

    const stream = opts && opts.stream || new HypercoreProtocol(isInitiator, { ...opts
    });
    this.ready(err => {
      if (err) return stream.destroy(err);
      this.corestore.replicate(isInitiator, { ...opts,
        stream
      });
    });
    return stream;
  }

  checkout(version, opts) {
    opts = { ...opts,
      _db: this.db.checkout(version),
      _contentStates: this._contentStates
    };
    return new Hyperdrive(this.corestore, this.key, opts);
  }

  _closeFile(fd, cb) {
    const idx = (fd - STDIO_CAP) / 2;
    const desc = this._fds[idx];
    if (!desc) return process.nextTick(cb, new Error('Invalid file descriptor'));
    this._fds[idx] = null;

    while (this._fds.length && !this._fds[this._fds.length - 1]) this._fds.pop();

    desc.close(cb);
  }

  _close(cb) {
    this.db.close(err => {
      for (const unlisten of this._unlistens) {
        unlisten();
      }

      this._unlistens = [];
      this.emit('close');
      cb(err);
    });
  }

  close(fd, cb) {
    if (typeof fd === 'number') return this._closeFile(fd, cb || noop);
    super.close(false, fd);
  }

  destroyStorage(cb) {
    const metadata = this.db.feed;

    this._getContent(metadata, (err, contentState) => {
      const content = contentState.feed;
      metadata.destroyStorage(() => {
        content.destroyStorage(() => {
          this.close(cb);
        });
      });
    });
  }

  stats(path, opts, cb) {
    if (typeof opts === 'function') return this.stats(path, null, opts);
    const self = this;
    const stats = new Map();
    this.stat(path, (err, stat, trie) => {
      if (err) return cb(err);

      if (stat.isFile()) {
        return fileStats(path, cb);
      } else {
        const recursive = opts && opts.recursive !== false;
        const ite = statIterator(self, path, {
          recursive
        });
        return ite.next(function loop(err, info) {
          if (err) return cb(err);
          if (!info) return cb(null, stats);
          fileStats(info.path, (err, fileStats) => {
            if (err && err.errno !== 2) return cb(err);
            if (!fileStats) return ite.next(loop);
            stats.set(info.path, fileStats);
            return ite.next(loop);
          });
        });
      }
    });

    function onstats(err, path, fileStats) {
      if (err) return cb(err);
      stats.set(path, fileStats);
    }

    function fileStats(path, cb) {
      const total = emptyStats();
      return self.stat(path, (err, stat, trie) => {
        if (err) return cb(err);
        return self._getContent(trie.feed, (err, contentState) => {
          if (err) return cb(err);
          contentState.feed.downloaded(stat.offset, stat.offset + stat.blocks, (err, downloadedBlocks) => {
            if (err) return cb(err);
            total.blocks = stat.blocks;
            total.size = stat.size;
            total.downloadedBlocks = downloadedBlocks; // TODO: This is not possible to implement now. Need a better byte length index in hypercore.
            // total.downloadedBytes = 0

            return cb(null, total);
          });
        });
      });
    }

    function emptyStats() {
      return {
        blocks: 0,
        size: 0,
        downloadedBlocks: 0
      };
    }
  }

  watchStats(path, opts) {
    const self = this;
    var timer = setInterval(collectStats, opts && opts.statsInveral || 2000);
    var collecting = false;
    var destroyed = false;
    const handle = new EventEmitter();
    Object.assign(handle, {
      destroy
    });
    return handle;

    function collectStats() {
      if (collecting) return;
      collecting = true;
      self.stats(path, opts, (err, stats) => {
        if (err) return destroy(err);
        collecting = false;
        handle.stats = stats;
        handle.emit('update');
      });
    }

    function destroy(err) {
      handle.emit('destroy', err);
      clearInterval(timer);
      destroyed = true;
    }
  }

  mirror() {
    const self = this;
    if (this._unmirror) return this._unmirror;
    const mirrorRanges = new Map();
    this.on('content-feed', oncore);
    this.on('metadata-feed', oncore);
    this.getAllMounts({
      content: true
    }, (err, mounts) => {
      if (err) return this.emit('error', err);

      for (const {
        metadata,
        content
      } of mounts.values()) {
        oncore(metadata);
        oncore(content);
      }
    });
    this._unmirror = unmirror;
    return this._unmirror;

    function unmirror() {
      if (!self._unmirror) return;
      self._unmirror = null;
      self.removeListener('content-feed', oncore);
      self.removeListener('metadata-feed', oncore);

      for (const [core, range] of mirrorRanges) {
        core.undownload(range);
      }
    }

    function oncore(core) {
      if (!core) return;
      if (!self._unmirror || self._unmirror !== unmirror || mirrorRanges.has(core)) return;
      mirrorRanges.set(core, core.download({
        start: 0,
        end: -1
      }));
    }
  }

  clear(path, opts, cb) {
    if (typeof opts === 'function') {
      cb = opts;
      opts = null;
    }

    opts = opts || {};
    if (!cb) cb = noop;

    opts.on = (feed, range, cb) => {
      feed.clear(range.start, range.end, cb);
      return range;
    };

    opts.off = noop;
    return this._walk(path, opts, cb);
  }

  download(path, opts, cb) {
    if (typeof opts === 'function') {
      cb = opts;
      opts = null;
    }

    opts = opts || {};
    if (!cb) cb = noop;

    opts.on = (feed, range, cb) => {
      return feed.download(range, cb);
    };

    opts.off = (feed, range) => {
      return feed.undownload(range);
    };

    return this._walk(path, opts, cb);
  }

  _walk(path, opts, cb) {
    if (!opts.on || !opts.off) throw new Error('_walk requires on and off');
    if (!cb) cb = noop;
    const self = this;
    const ranges = new Map();
    var pending = 0;
    var destroyed = false;
    const handle = new EventEmitter();
    Object.assign(handle, {
      destroy
    });
    self.stat(path, (err, stat, trie) => {
      if (err) return destroy(err);

      if (stat.isFile()) {
        downloadFile(path, stat, trie, destroy);
      } else {
        const recursive = opts.recursive !== false;
        const noMounts = opts.noMounts !== false;
        const ite = statIterator(self, path, {
          recursive,
          noMounts,
          random: true
        });
        downloadNext(ite);
      }
    });
    return handle;

    function downloadNext(ite) {
      if (destroyed) return;
      ite.next((err, info) => {
        if (err) return destroy(err);

        if (!info) {
          if (!ranges.size) return destroy(null);else return;
        }

        const {
          path,
          stat,
          trie
        } = info;
        if (!stat.blocks || stat.mount || stat.isDirectory()) return downloadNext(ite);
        downloadFile(path, stat, trie, err => {
          if (err) return destroy(err);
          return downloadNext(ite);
        });

        if (pending < (opts && opts.maxConcurrent || 50)) {
          return downloadNext(ite);
        }
      });
    }

    function downloadFile(path, stat, trie, cb) {
      pending++;

      self._getContent(trie.feed, (err, contentState) => {
        if (err) return destroy(err);
        const feed = contentState.feed;
        const range = opts.on(feed, {
          start: stat.offset,
          end: stat.offset + stat.blocks
        }, err => {
          pending--;
          if (err) return cb(err);
          ranges.delete(path);
          return cb(null);
        });
        ranges.set(path, {
          range,
          feed
        });
      });
    }

    function destroy(err) {
      if (destroyed) return null;
      destroyed = true;

      for (const [path, {
        feed,
        range
      }] of ranges) {
        opts.off(feed, range);
      }

      if (err) return cb(err);
      return cb(null);
    }
  }

  watch(name, onchange) {
    name = fixName(name);
    return this.db.watch(name, onchange);
  }

  mount(path, key, opts, cb) {
    if (typeof opts === 'function') return this.mount(path, key, null, opts);
    const self = this;
    path = fixName(path);
    opts = opts || {};
    const statOpts = {
      uid: opts.uid,
      gid: opts.gid
    };
    statOpts.mount = {
      key,
      version: opts.version,
      hash: opts.hash,
      hypercore: !!opts.hypercore
    };
    statOpts.directory = !opts.hypercore;

    if (opts.hypercore) {
      const core = this.corestore.get({
        key,
        ...opts,
        parents: [this.key],
        sparse: this.sparse
      });
      core.ready(err => {
        if (err) return cb(err);
        this.emit('content-feed', core);
        statOpts.size = core.byteLength;
        statOpts.blocks = core.length;
        return mountCore();
      });
    } else {
      return process.nextTick(mountTrie, null);
    }

    function mountCore() {
      self._createStat(path, statOpts, (err, st) => {
        if (err) return cb(err);
        return self.db.put(path, st.encode(), cb);
      });
    }

    function mountTrie() {
      self._createStat(path, statOpts, (err, st) => {
        if (err) return cb(err);
        self.db.mount(path, key, { ...opts,
          value: st.encode()
        }, err => {
          return self.db.loadMount(path, cb);
        });
      });
    }
  }

  unmount(path, cb) {
    this.stat(path, (err, st) => {
      if (err) return cb(err);
      if (!st.mount) return cb(new Error('Can only unmount mounts.'));

      if (st.mount.hypercore) {
        return this.unlink(path, cb);
      } else {
        return this.db.unmount(path, cb);
      }
    });
  }

  symlink(target, linkName, cb) {
    target = unixify(target);
    linkName = fixName(linkName);
    this.lstat(linkName, (err, stat) => {
      if (err && err.errno !== 2) return cb(err);
      if (!err) return cb(new errors.PathAlreadyExists(linkName));
      const st = Stat.symlink({
        linkname: target
      });
      return this._putStat(linkName, st, cb);
    });
  }

  createMountStream(opts) {
    return createMountStream(this, opts);
  }

  getAllMounts(opts, cb) {
    if (typeof opts === 'function') return this.getAllMounts(null, opts);
    const mounts = new Map();
    this.ready(err => {
      if (err) return cb(err);
      collect(this.createMountStream(opts), (err, mountList) => {
        if (err) return cb(err);

        for (const {
          path,
          metadata,
          content
        } of mountList) {
          mounts.set(path, {
            metadata,
            content
          });
        }

        return cb(null, mounts);
      });
    });
  }

  extension(name, message) {
    this.metadata.extension(name, message);
  }

  registerExtension(name, handlers) {
    return this.metadata.registerExtension(name, handlers);
  }

  get peers() {
    return this.metadata.peers;
  }

  setMetadata(path, key, value, cb) {
    const metadata = {};
    metadata[key] = value;

    this._update(path, {
      metadata
    }, cb);
  }

  removeMetadata(path, key, cb) {
    const metadata = {};
    metadata[key] = null;

    this._update(path, {
      metadata
    }, cb);
  }

  copy(from, to, cb) {
    this.stat(from, (err, stat) => {
      if (err) return cb(err);
      this.create(to, stat, cb);
    });
  } // Tag-related methods.


  createTag(name, version, cb) {
    return this.tags.create(name, version, cb);
  }

  getAllTags(cb) {
    return this.tags.getAll(cb);
  }

  deleteTag(name, cb) {
    return this.tags.delete(name, cb);
  }

  getTaggedVersion(name, cb) {
    return this.tags.get(name, cb);
  }

}

function HyperdriveCompat(...args) {
  if (!(this instanceof HyperdriveCompat)) return new HyperdriveCompat(...args);
  Nanoresource.call(this);

  Hyperdrive.prototype._initialize.call(this, ...args);
}

Object.setPrototypeOf(HyperdriveCompat.prototype, Hyperdrive.prototype);

function isObject(val) {
  return !!val && typeof val !== 'string' && !Buffer.isBuffer(val);
}

function ifNotExists(oldNode, newNode, cb) {
  if (oldNode) return cb(new errors.PathAlreadyExists(oldNode.key));
  return cb(null, true);
}

function fixName(name) {
  name = unixify(name);
  if (!name.startsWith('/')) name = '/' + name;
  return name;
}

function noop() {}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./lib/content":252,"./lib/errors":253,"./lib/fd":254,"./lib/iterator":255,"./lib/storage":256,"./lib/tagging":257,"./promises":258,"_process":380,"buffer":97,"corestore":120,"duplexify":147,"events":172,"filesystem-constants":179,"hypercore-byte-stream":219,"hypercore-protocol":239,"hyperdrive-schemas":248,"mountable-hypertrie":315,"nanoresource/emitter":344,"path":371,"pump":394,"pumpify":395,"stream-collector":563,"streamx":565,"thunky":568,"thunky-map":567,"unixify":573}],252:[function(require,module,exports){
const mutexify = require('mutexify');

const CONTENT_LOCK = Symbol('HyperdriveContentLock');

function contentOptions(self) {
  return {
    sparse: self.sparse || self.latest,
    maxRequests: self.maxRequests,
    storageCacheSize: self.contentStorageCacheSize
  };
}

class ContentState {
  constructor(feed) {
    this.feed = feed instanceof ContentState ? feed.feed : feed;
    if (!this.feed[CONTENT_LOCK]) this.feed[CONTENT_LOCK] = mutexify();
  }

  lock(cb) {
    return this.feed[CONTENT_LOCK](cb);
  }

  isLocked() {
    return this.feed[CONTENT_LOCK].locked;
  }

}

module.exports = {
  contentOptions,
  ContentState
};

},{"mutexify":318}],253:[function(require,module,exports){
const CustomError = require('custom-error-class');

class FileNotFound extends CustomError {
  constructor(fileName) {
    super(`No such file or directory: '${fileName}'.`);
    this.code = 'ENOENT';
    this.errno = 2;
  }

}

class DirectoryNotEmpty extends CustomError {
  constructor(dirName) {
    super(`Directory '${dirName}' is not empty.`);
    this.code = 'ENOTEMPTY';
    this.errno = 39;
  }

}

class PathAlreadyExists extends CustomError {
  constructor(dirName) {
    super(`Path ${dirName} already exists.`);
    this.code = 'EEXIST';
    this.errno = 17;
  }

}

class BadFileDescriptor extends CustomError {
  constructor(msg) {
    super(msg);
    this.code = 'EBADF';
    this.errno = 9;
  }

}

class InvalidArgument extends CustomError {
  constructor(msg) {
    super(msg);
    this.code = 'EINVAL';
    this.errno = 22;
  }

}

class InvalidPermission extends CustomError {
  constructor(msg) {
    super(msg);
    this.code = 'EPERM';
    this.errno = 1;
  }

}

module.exports = {
  FileNotFound,
  DirectoryNotEmpty,
  PathAlreadyExists,
  BadFileDescriptor,
  InvalidArgument,
  InvalidPermission
};

},{"custom-error-class":129}],254:[function(require,module,exports){
(function (process,Buffer){(function (){
const byteStream = require('byte-stream');

const errors = require("./errors");

const pumpify = require('pumpify');

const {
  Transform
} = require('streamx');

const {
  linux: linuxConstants,
  parse
} = require('filesystem-constants');

const {
  O_RDONLY,
  O_WRONLY,
  O_RDWR,
  O_CREAT,
  O_TRUNC,
  O_APPEND,
  O_SYNC,
  O_EXCL,
  O_ACCMODE
} = linuxConstants;

class FileDescriptor {
  constructor(drive, path, stat, contentState, readable, writable, appending, creating) {
    this.drive = drive;
    this.stat = stat;
    this.path = path;
    this.contentState = contentState;
    this.readable = readable;
    this.writable = writable;
    this.creating = creating;
    this.appending = appending;
    this.position = null;
    this.blockPosition = stat ? stat.offset : null;
    this.blockOffset = 0;
    this._gets = new Set();
    this._appendStream = null;
    this._err = null;

    if (this.writable) {
      if (this.appending) {
        this._appendStream = this.drive.createReadStream(this.path);
        this.position = this.stat.size;
      }
    }

    this._batcher = byteStream({
      time: 100,
      limit: 4096 * 16
    });
    this._range = null;
  }

  read(buffer, offset, len, pos, cb) {
    if (!this.readable) return cb(new errors.BadFileDescriptor('File descriptor not open for reading.'));

    this._readAcc(buffer, offset, len, pos, 0, cb);
  }

  _readAcc(buffer, offset, len, pos, totalRead, cb) {
    if (this.position !== null && this.position === pos) this._read(buffer, offset, len, totalRead, cb);else this._seekAndRead(buffer, offset, len, pos, totalRead, cb);
  }

  write(buffer, offset, len, pos, cb) {
    if (!this.writable) return cb(new errors.BadFileDescriptor('File descriptor not open for writing.'));

    if (!this.stat && !this.creating) {
      return process.nextTick(cb, new errors.BadFileDescriptor('File descriptor not open in create mode.'));
    }

    if (this.position !== null && pos !== this.position) {
      return process.nextTick(cb, new errors.BadFileDescriptor('Random-access writes are not currently supported.'));
    }

    if (this.appending && pos < this.stat.size) {
      return process.nextTick(cb, new errors.BadFileDescriptor('Position cannot be less than the file size when appending.'));
    }

    if (!this._writeStream && !this.appending && pos) {
      return process.nextTick(cb, new errors.BadFileDescriptor('Random-access writes are not currently supported.'));
    }

    const self = this;
    const slice = buffer.slice(offset, len);

    if (!this._writeStream) {
      this._writeStream = createWriteStream(this.drive, this.stat, this.path);

      this.drive._writingFds.set(this.path, this);
    }

    this._writeStream.on('error', done); // TODO: This is a temporary (bad) way of supporting appends.


    if (this._appendStream) {
      this.position = this.stat.size; // pump does not support the `end` option.

      this._appendStream.pipe(this._writeStream, {
        end: false
      });

      this._appendStream.on('error', err => this._writeStream.destroy(err));

      this._writeStream.on('error', err => this._appendStream.destroy(err));

      return this._appendStream.on('end', doWrite);
    }

    return doWrite();

    function done(err) {
      self._writeStream.removeListener('error', done);

      self._writeStream.removeListener('drain', done);

      if (err) return cb(err);
      self.position += slice.length;
      self.stat.size += slice.length;
      return cb(null, slice.length, buffer);
    }

    function doWrite(err) {
      self._appendStream = null;
      if (err) return cb(err);
      if (self._err) return cb(self._err);
      if (self._writeStream.destroyed) return cb(new errors.BadFileDescriptor('Write stream was destroyed.'));

      if (self._writeStream.write(slice) === false) {
        self._writeStream.once('drain', done);
      } else {
        process.nextTick(done);
      }
    }
  }

  truncate(size, cb) {
    if (!this.writable) return cb(new errors.BadFileDescriptor('File descriptor is not writable')); // TODO: Handle all the different truncation scenarios (wait for inode table).

    if (size) return cb(new errors.InvalidArgument('Non-zero sizes are not currently supported in ftruncate.'));

    this.drive._update(this.path, {
      size: 0,
      blocks: 0
    }, (err, st) => {
      if (err) return cb(err);
      this.stat = st;
      return cb(null);
    });
  }

  close(cb) {
    // TODO: If we ever support multiple file descriptors for one path at one time, this will need updating.
    if (this.writable) this.drive._writingFds.delete(this.path);

    if (this._writeStream) {
      if (this._writeStream.destroyed) {
        this._writeStream = null;
      } else {
        return this._writeStream.end(err => {
          if (err) return cb(err);
          this._writeStream = null;
          return cb(null);
        });
      }
    }

    if (this._range) {
      for (const get of this._gets) this.contentState.feed.cancel(get);

      this.contentState.feed.undownload(this._range);
      this._range = null;
    }

    process.nextTick(cb, null);
  }
  /**
   * Will currently request until the end of the file linearly.
   *
   * TODO: This behavior should be more customizable in the future.
   */


  _refreshDownload(start, cb) {
    // const end = Math.min(this.stat.blocks + this.stat.offset, start + 16)
    const end = this.stat.offset + this.stat.blocks;

    if (this._range) {
      this.contentState.feed.undownload(this._range);
    }

    this._range = this.contentState.feed.download({
      start,
      end,
      linear: true
    }, cb || noop);
  }

  _seekAndRead(buffer, offset, len, pos, totalRead, cb) {
    const start = this.stat.offset;
    const end = start + this.stat.blocks;
    this.contentState.feed.seek(this.stat.byteOffset + pos, {
      start,
      end
    }, (err, blk, blockOffset) => {
      if (err) return cb(err);
      this.position = pos;
      this.blockPosition = blk;
      this.blockOffset = blockOffset;

      this._refreshDownload(blk);

      this._read(buffer, offset, len, totalRead, cb);
    });
  }

  _read(buffer, offset, len, totalRead, cb) {
    const self = this;
    const position = this.position;
    readNextBlock();

    function readNextBlock() {
      self._readBlock(buffer, offset + totalRead, Math.max(len - totalRead, 0), (err, bytesRead) => {
        if (err) return cb(err);
        if (!bytesRead) return cb(null, totalRead, buffer);
        totalRead += bytesRead;

        if (totalRead < len) {
          return self._readAcc(buffer, offset, len, position + bytesRead, totalRead, cb);
        }

        return cb(null, totalRead, buffer);
      });
    }
  }

  _readBlock(buffer, offset, len, cb) {
    const buf = buffer.slice(offset, offset + len);
    const blkOffset = this.blockOffset;
    const blk = this.blockPosition;

    if (this._range && (blk < this._range.start || blk > this._range.end)) {
      this._refreshDownload(blk);
    }

    if (this.stat.offset + this.stat.blocks <= blk || blk < this.stat.offset) {
      return process.nextTick(cb, null, 0, buffer);
    }

    const get = this.contentState.feed.get(blk, (err, data) => {
      this._gets.delete(get);

      if (err) return cb(err);
      if (blkOffset) data = data.slice(blkOffset);
      data.copy(buf);
      const read = Math.min(data.length, buf.length);

      if (blk === this.blockPosition && blkOffset === this.blockOffset) {
        this.position += read;

        if (read === data.length) {
          this.blockPosition++;
          this.blockOffset = 0;
        } else {
          this.blockOffset = blkOffset + read;
        }
      }

      cb(null, read, buffer);
    });

    this._gets.add(get);
  }

}

module.exports = function create(drive, name, flags, cb) {
  try {
    flags = parse(linuxConstants, flags);
  } catch (err) {
    return process.nextTick(cb, new errors.InvalidArgument(err.message));
  }

  const accmode = flags & O_ACCMODE;
  const writable = !!(accmode & (O_WRONLY | O_RDWR));
  const readable = accmode === 0 || !!(accmode & O_RDWR);
  const appending = !!(flags & O_APPEND);
  const truncating = !!(flags & O_TRUNC);
  const creating = !!(flags & O_CREAT);
  const canExist = !(flags & O_EXCL);
  drive.stat(name, {
    trie: true
  }, (err, st, trie) => {
    if (err && err.errno !== 2) return cb(err);
    if (st && !canExist) return cb(new errors.PathAlreadyExists(name));
    if (!st && (!writable || !creating)) return cb(new errors.FileNotFound(name));

    drive._getContent(trie.feed, (err, contentState) => {
      if (err) return cb(err);
      const fd = new FileDescriptor(drive, name, st, contentState, readable, writable, appending, creating);
      if (!contentState.feed.writable && writable) return cb(new errors.InvalidArgument('Cannot open a writable fd on a read-only drive.'));

      if (truncating) {
        return drive._upsert(name, {
          size: 0,
          blocks: 0
        }, (err, st) => {
          if (err) return cb(err);
          fd.stat = st;
          return cb(null, fd);
        });
      }

      if (creating || writable && !appending) {
        return drive.create(name, (err, st) => {
          if (err) return cb(err);
          fd.stat = st;
          return cb(null, fd);
        });
      } else {
        return cb(null, fd);
      }
    });
  });
};

function createWriteStream(drive, opts, path) {
  const writeStream = drive.createWriteStream(path, opts);
  const batcher = byteStream({
    time: 100,
    limit: 4096 * 16
  });
  return pumpify(batcher, new Transform({
    transform(chunk, cb) {
      return cb(null, Buffer.concat(chunk));
    }

  }), writeStream);
}

function noop() {}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./errors":253,"_process":380,"buffer":97,"byte-stream":99,"filesystem-constants":179,"pumpify":395,"streamx":565}],255:[function(require,module,exports){
(function (process){(function (){
const pathRoot = require('path');

const p = pathRoot.posix || pathRoot;

const nanoiterator = require('nanoiterator');

const toStream = require('nanoiterator/to-stream');

const MountableHypertrie = require('mountable-hypertrie');

const {
  Stat
} = require('hyperdrive-schemas');

function statIterator(drive, path, opts) {
  const stack = [];
  return nanoiterator({
    open,
    next
  });

  function open(cb) {
    drive.ready(err => {
      if (err) return cb(err);
      stack.unshift({
        path: '/',
        target: null,
        iterator: drive.db.iterator(path, opts)
      });
      return cb(null);
    });
  }

  function next(cb) {
    if (!stack.length) return cb(null, null);
    stack[0].iterator.next((err, node) => {
      if (err) return cb(err);

      if (!node) {
        stack.shift();
        return next(cb);
      }

      const trie = node[MountableHypertrie.Symbols.TRIE];
      const mount = node[MountableHypertrie.Symbols.MOUNT];
      const innerPath = node[MountableHypertrie.Symbols.INNER_PATH];

      try {
        var st = Stat.decode(node.value);
      } catch (err) {
        return cb(err);
      }

      if (st.linkname && (opts.recursive || stack.length === 1)) {
        if (p.isAbsolute(st.linkname)) {
          var linkPath = st.linkname;
        } else {
          linkPath = p.resolve('/', p.dirname(node.key), st.linkname);
        }

        return pushLink(prefix(node.key), linkPath, st, (err, linkStat) => {
          if (err) return cb(err);
          if (linkStat) return cb(null, {
            stat: st,
            path: prefix(node.key),
            trie,
            mount,
            innerPath
          });
          return next(cb);
        });
      }

      linkPath = stack[0].path;
      const resolved = linkPath === '/' ? node.key : p.join(linkPath, node.key.slice(stack[0].target.length));
      return cb(null, {
        stat: st,
        path: prefix(resolved),
        trie,
        mount,
        innerPath
      });
    });
  }

  function pushLink(nodePath, linkPath, stat, cb) {
    if (opts && opts.recursive || nodePath === path) {
      return drive.stat(linkPath, (err, targetStat, _, resolvedLink) => {
        if (err && err.errno !== 2) return cb(err);
        if (!targetStat) return cb(null);

        if (targetStat.isDirectory()) {
          stack.unshift({
            path: nodePath,
            target: resolvedLink,
            iterator: drive.db.iterator(resolvedLink, {
              gt: true,
              ...opts
            })
          });
        }

        return cb(null, stat);
      });
    }

    return process.nextTick(cb, null, stat);
  }
}

function mountIterator(drive, opts) {
  const loadContent = !!(opts && opts.content);
  var ite = null;
  var first = drive;
  return nanoiterator({
    open(cb) {
      drive.ready(function (err) {
        if (err) return cb(err);
        ite = drive.db.mountIterator(opts);
        return cb(null);
      });
    },

    next(cb) {
      if (first) return onfirst();
      ite.next((err, val) => {
        if (err) return cb(err);
        if (!val) return cb(null, null);

        const contentState = drive._contentStates.cache.get(val.trie.feed);

        let mountMetadataFeed = val.trie.feed;
        if (contentState) return process.nextTick(oncontent, val.path, mountMetadataFeed, contentState);
        mountMetadataFeed.has(0, (err, hasMetadataBlock) => {
          if (err) return cb(err);
          if (!(loadContent || hasMetadataBlock)) return oncontent(val.path, mountMetadataFeed, null);
          return drive._getContent(val.trie.feed, (err, contentState) => {
            if (err) return cb(err);
            return oncontent(val.path, mountMetadataFeed, contentState);
          });
        });
      });

      function onfirst() {
        first = null;
        drive.metadata.has(0, (err, hasMetadataBlock) => {
          if (err) return cb(err);

          if (loadContent || hasMetadataBlock) {
            return drive._getContent(drive.db.feed, err => {
              if (err) return cb(err);
              return cb(null, {
                path: '/',
                metadata: drive.metadata,
                content: drive._contentStates.cache.get(drive.db.feed).feed
              });
            });
          } else {
            return cb(null, {
              path: '/',
              metadata: drive.metadata,
              content: null
            });
          }
        });
      }

      function oncontent(path, metadata, contentState) {
        return cb(null, {
          path,
          metadata,
          content: contentState ? contentState.feed : null
        });
      }
    }

  });
}

function readdirIterator(drive, name, opts) {
  const recursive = !!(opts && opts.recursive);
  const noMounts = !!(opts && opts.noMounts);
  const includeStats = !!(opts && opts.includeStats);
  const ite = statIterator(drive, name, { ...opts,
    recursive,
    noMounts,
    gt: false
  });
  return nanoiterator({
    next
  });

  function next(cb) {
    ite.next((err, value) => {
      if (err) return cb(err);
      if (!value) return cb(null, null);
      const {
        path,
        stat,
        mount,
        innerPath
      } = value;
      const relativePath = name === path ? path : p.relative(name, path);
      if (relativePath === name) return next(cb);

      if (recursive) {
        if (includeStats) return cb(null, {
          name: relativePath,
          path,
          stat,
          mount,
          innerPath
        });
        return cb(null, relativePath);
      }

      const split = relativePath.split('/'); // Note: When doing a non-recursive readdir, we need to create a fake directory Stat (since the returned Stat might be a child file here)
      // If this is a problem, one should follow the readdir with the appropriate stat() calls.

      if (includeStats) return cb(null, {
        name: split[0],
        path,
        stat: split.length > 1 ? Stat.directory() : stat,
        mount,
        innerPath
      });
      return cb(null, split[0]);
    });
  }
}

function createReaddirStream(drive, path, opts) {
  return toStream(readdirIterator(drive, path, opts));
}

function createStatStream(drive, path, opts) {
  return toStream(statIterator(drive, path, opts));
}

function createMountStream(drive, opts) {
  return toStream(mountIterator(drive, opts));
}

function prefix(key) {
  if (key.startsWith('/')) return key;
  return '/' + key;
}

module.exports = {
  statIterator,
  createStatStream,
  mountIterator,
  createMountStream,
  readdirIterator,
  createReaddirStream
};

}).call(this)}).call(this,require('_process'))
},{"_process":380,"hyperdrive-schemas":248,"mountable-hypertrie":315,"nanoiterator":323,"nanoiterator/to-stream":324,"path":371}],256:[function(require,module,exports){
const raf = require('random-access-file');

const Corestore = require('corestore');

module.exports = function defaultCorestore(storage, opts) {
  if (isCorestore(storage)) return storage;

  if (typeof storage === 'function') {
    var factory = path => storage(path);
  } else if (typeof storage === 'string') {
    factory = path => raf(storage + '/' + path);
  }

  return new Corestore(factory, opts);
};

function isCorestore(storage) {
  return storage.default && storage.get && storage.replicate && storage.close;
}

},{"corestore":120,"random-access-file":416}],257:[function(require,module,exports){
(function (Buffer){(function (){
const TAGS_PREFIX = 'hyperdrive-tags/';

const varint = require('varint');

module.exports = class TagManager {
  constructor(drive) {
    this.drive = drive;
  }

  _toTag(name) {
    return TAGS_PREFIX + name;
  }

  _fromTag(tag) {
    return tag.slice(TAGS_PREFIX.length);
  }

  create(name, version, cb) {
    if (typeof version === 'function') {
      cb = version;
      version = null;
    }

    if (typeof name !== 'string') return cb(new Error('Tag name must be a string.'));
    this.drive.ready(err => {
      if (err) return cb(err);
      if (version === null) version = this.drive.version;
      const buf = Buffer.alloc(varint.encodingLength(version));
      varint.encode(version, buf);
      return this.drive.db.put(this._toTag(name), buf, {
        hidden: true
      }, cb);
    });
  }

  get(name, cb) {
    this.drive.ready(err => {
      if (err) return cb(err);
      this.drive.db.get(this._toTag(name), {
        hidden: true
      }, (err, node) => {
        if (err) return cb(err);
        if (!node) return cb(null, null);
        return cb(null, varint.decode(node.value));
      });
    });
  }

  getAll(cb) {
    this.drive.ready(err => {
      if (err) return cb(err);
      this.drive.db.list(TAGS_PREFIX, {
        hidden: true
      }, (err, nodes) => {
        if (err) return cb(err);
        if (!nodes || !nodes.length) return cb(null, []);
        const tagMap = new Map();

        for (const node of nodes) {
          tagMap.set(this._fromTag(node.key), varint.decode(node.value));
        }

        return cb(null, tagMap);
      });
    });
  }

  delete(name, cb) {
    this.drive.ready(err => {
      if (err) return cb(err);
      return this.drive.db.del(this._toTag(name), {
        hidden: true
      }, cb);
    });
  }

};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"varint":582}],258:[function(require,module,exports){
/**
 * A promisified version of the Hyperdrive API
 *
 * Note: The promises API does not currently include file descriptor operations.
*/
module.exports = class HyperdrivePromises {
  constructor(drive) {
    this.drive = drive;
  }

  get key() {
    return this.drive.key;
  }

  get discoveryKey() {
    return this.drive.discoveryKey;
  }

  get version() {
    return this.drive.version;
  }

  get metadata() {
    return this.drive.metadata;
  }

  get writable() {
    return this.drive.metadata.writable;
  }

  ready() {
    return new Promise((resolve, reject) => {
      this.drive.ready(err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  close() {
    return new Promise((resolve, reject) => {
      this.drive.close(err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  create(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.create(name, opts, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  createReadStream(name, opts) {
    return this.drive.createReadStream(name, opts);
  }

  readFile(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.readFile(name, opts, (err, contents) => {
        if (err) return reject(err);
        return resolve(contents);
      });
    });
  }

  createWriteStream(name, opts) {
    return this.drive.createWriteStream(name, opts);
  }

  writeFile(name, buf, opts) {
    return new Promise((resolve, reject) => {
      this.drive.writeFile(name, buf, opts, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  createDiffStream(other, prefix, opts) {
    return this.drive.createDiffStream(other, prefix, opts);
  }

  createDirectoryStream(name, opts) {
    return this.drive.createDirectoryStream(name, opts);
  }

  replicate(isInitiator, opts) {
    return this.drive.replicate(isInitiator, opts);
  }

  truncate(name, size) {
    return new Promise((resolve, reject) => {
      this.drive.truncate(name, size, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  mkdir(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.mkdir(name, opts, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  lstat(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.lstat(name, opts, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  stat(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.stat(name, opts, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  info(name) {
    return new Promise((resolve, reject) => {
      this.drive.info(name, (err, info) => {
        if (err) return reject(err);
        return resolve(info);
      });
    });
  }

  access(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.access(name, opts, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  exists(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.exists(name, opts, exists => {
        return resolve(exists);
      });
    });
  }

  readdir(name, opts) {
    return new Promise((resolve, reject) => {
      this.drive.readdir(name, opts, (err, entries) => {
        if (err) return reject(err);
        return resolve(entries);
      });
    });
  }

  unlink(name) {
    return new Promise((resolve, reject) => {
      this.drive.unlink(name, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  rmdir(name) {
    return new Promise((resolve, reject) => {
      this.drive.rmdir(name, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  checkout(version, opts) {
    return this.drive.checkout(version, opts).promises;
  }

  destroyStorage() {
    return new Promise((resolve, reject) => {
      this.drive.destroyStorage(err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  stats(path, opts) {
    return new Promise((resolve, reject) => {
      this.drive.stats(path, opts, (err, stats) => {
        if (err) return reject(err);
        return resolve(stats);
      });
    });
  }

  watchStats(path, opts) {
    return this.drive.watchStats(path, opts);
  }

  mirror() {
    return this.drive.mirror();
  }

  download(path, opts) {
    var handle = null;
    const prom = new Promise((resolve, reject) => {
      handle = this.drive.download(path, opts, err => {
        if (err) return reject(err);
        return resolve(handle);
      });
    });
    prom.destroy = handle.destroy;
    prom.catch(() => {});
    return prom;
  }

  watch(name, onchange) {
    return this.drive.watch(name, onchange);
  }

  mount(path, key, opts) {
    return new Promise((resolve, reject) => {
      this.drive.mount(path, key, opts, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  extension(name, message) {
    return this.drive.extension(name, message);
  }

  createMountStream(opts) {
    return this.drive.createMountStream(opts);
  }

  unmount(path) {
    return new Promise((resolve, reject) => {
      this.drive.unmount(path, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  symlink(target, linkname) {
    return new Promise((resolve, reject) => {
      this.drive.symlink(target, linkname, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  readlink(name) {
    return new Promise((resolve, reject) => {
      this.drive.readlink(name, (err, linkname) => {
        if (err) return reject(err);
        return resolve(linkname);
      });
    });
  }

  getAllMounts(opts) {
    return new Promise((resolve, reject) => {
      this.drive.getAllMounts(opts, (err, allMounts) => {
        if (err) return reject(err);
        return resolve(allMounts);
      });
    });
  }

  setMetadata(path, key, value) {
    return new Promise((resolve, reject) => {
      this.drive.setMetadata(path, key, value, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  removeMetadata(path, key) {
    return new Promise((resolve, reject) => {
      this.drive.removeMetadata(path, key, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  copy(from, to) {
    return new Promise((resolve, reject) => {
      this.drive.copy(from, to, (err, st) => {
        if (err) return reject(err);
        return resolve(st);
      });
    });
  }

  createTag(name, version) {
    return new Promise((resolve, reject) => {
      this.drive.createTag(name, version, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  getAllTags() {
    return new Promise((resolve, reject) => {
      this.drive.getAllTags((err, allTags) => {
        if (err) return reject(err);
        return resolve(allTags);
      });
    });
  }

  deleteTag(name) {
    return new Promise((resolve, reject) => {
      this.drive.deleteTag(name, err => {
        if (err) return reject(err);
        return resolve(null);
      });
    });
  }

  getTaggedVersion(name) {
    return new Promise((resolve, reject) => {
      this.drive.getTaggedVersion(name, (err, version) => {
        if (err) return reject(err);
        return resolve(version);
      });
    });
  }

};

},{}],259:[function(require,module,exports){
const HyperswarmProxyClient = require('hyperswarm-proxy/client');

const websocket = require('websocket-stream');

const DEFAULT_PORT = '4977'; // HYPR on a cellphone keypad

const LOCAL_PROXY = `ws://localhost:${DEFAULT_PORT}`;
const DEFAULT_PROXY = [LOCAL_PROXY];
const DEFAULT_RECONNECT_DELAY = 1000;

class HyperswarmProxyWSClient extends HyperswarmProxyClient {
  constructor(opts = {}) {
    super(opts);
    const {
      proxy = DEFAULT_PROXY,
      reconnectDelay = DEFAULT_RECONNECT_DELAY
    } = opts;
    this.reconnectDelay = reconnectDelay;
    this.proxy = null;
    this._urls = typeof proxy === 'string' ? [proxy] : proxy;
    this._urlIndex = 0;
    this.reconnect();
  }

  reconnect() {
    this._nextUrl();

    const localSocket = websocket(LOCAL_PROXY); // Re-emit errors

    localSocket.on('error', e => this.emit('connection-error', e));
    localSocket.once('error', () => {
      // Couldn't connect to a local proxy
      // Attempt to connect to the internet proxy
      const proxySocket = websocket(this.proxy); // Re-emit errors

      proxySocket.on('error', e => this.emit('connection-error', e));
      proxySocket.once('close', () => {
        setTimeout(() => {
          if (this.destroyed) return;
          this.reconnect();
        }, this.reconnectDelay);
      });
      super.reconnect(proxySocket);
    });
    super.reconnect(localSocket);
  }

  _nextUrl() {
    this.proxy = this._urls[this._urlIndex++ % this._urls.length];
    return this.proxy;
  }

}

module.exports = HyperswarmProxyWSClient;

},{"hyperswarm-proxy/client":260,"websocket-stream":585}],260:[function(require,module,exports){
(function (process){(function (){
const EventEmitter = require('events');

const HyperswarmProxyStream = require("./");

const NOT_CONNECTED = 'Not connected to proxy';
module.exports = class HyperswarmProxyClient extends EventEmitter {
  constructor(options = {}) {
    super();
    const {
      connection,
      autoconnect = true,
      maxPeers = 24
    } = options;
    this.maxPeers = maxPeers;
    this._handleStream = this._handleStream.bind(this);
    this._handleClose = this._handleClose.bind(this);
    this._handlePeer = this._handlePeer.bind(this);
    this._handleError = this._handleError.bind(this);
    this._reJoin = this._reJoin.bind(this);
    this._protocol = null;
    this._connection = null;
    this._topics = [];
    this._connectedPeers = new Set();
    this._seenPeers = [];
    this._autoconnect = autoconnect;
    this.destroyed = false;

    if (connection) {
      this.reconnect(connection);
    }
  }

  disconnect() {
    if (!this._protocol) {
      return;
    }

    this._protocol.removeListener('close', this._handleClose);

    this._connection.end();

    this._protocol.end();

    this._connection = null;
    this._protocol = null;
  }

  reconnect(connection) {
    this.disconnect();
    this._connection = connection;
    this._protocol = new HyperswarmProxyStream(connection);

    this._protocol.on('stream', this._handleStream);

    this._protocol.on('on_peer', this._handlePeer);

    this._protocol.once('close', this._handleClose);

    this._protocol.on('error', this._handleError); // Once the other side is ready, re-join known topics


    this._protocol.once('ready', this._reJoin);

    this._protocol.ready();
  }

  _handleStream(stream, {
    topic,
    peer
  }) {
    if (this.destroyed) {
      // Already destroyed
      stream.end();
      return;
    }

    const details = new Details(peer, topic);

    this._connectedPeers.add(peer);

    this.emit('connection', stream, details);
    stream.once('close', () => {
      if (this.destroyed) {
        return;
      }

      this.emit('disconnection', stream, details);

      this._connectedPeers.delete(peer);
    });
  }

  _handleClose() {
    this._protocol = null;

    for (const peer of this._connectedPeers) {
      peer.end();
    }

    this.emit('disconnected');
  }

  _handleError(e) {
    this.emit('error', e);
  }

  _handlePeer({
    topic,
    peer
  }) {
    const peerData = {
      host: peer,
      port: 0,
      local: false,
      topic
    };
    this.emit('peer', peerData);

    const hasConnected = this._connectedPeers.has(peer);

    const hasMaxPeers = this._connectedPeers.size >= this.maxPeers;
    const shouldConnect = this._autoconnect && !hasConnected && !hasMaxPeers;

    if (shouldConnect) {
      this.connect(peerData);
    } else if (!this._seenPeers.find(data => data.peer === peer)) {
      // TODO: Do something with this, like connect to them after disconnection
      this._seenPeers.push(peerData);
    }
  }

  _reJoin() {
    for (const topic of this._topics) {
      this.join(topic);
    }
  }

  get connections() {
    if (!this._protocol) return new Set();
    return this._protocol.connections;
  }

  join(topic) {
    if (!this._protocol) throw new Error(NOT_CONNECTED);

    this._protocol.join(topic);

    const hasSeen = this._topics.some(other => other.equals(topic));

    if (!hasSeen) {
      this._topics.push(topic);
    }
  }

  leave(topic) {
    if (!this._protocol) throw new Error(NOT_CONNECTED);

    this._protocol.leave(topic);

    this._topics = this._topics.filter(other => !other.equals(topic));
    this._seenPeers = this._seenPeers.filter(({
      topic: other
    }) => !other.equals(topic));
  }

  connect(peer, cb = noop) {
    if (!this._protocol) return setTimeout(() => cb(new Error(NOT_CONNECTED)), 0);
    const id = peer.host;

    const listenStreams = (stream, details) => {
      const foundId = details.peer.host;
      if (foundId !== id) return;
      cb(null, stream, details);
      this.removeListener('connection', listenStreams);
    };

    if (cb) {
      this.on('connection', listenStreams);
    }

    this._protocol.connect(id);
  }

  flush(cb = noop) {
    // No clue how to implement this.
    if (cb) process.nextTick(cb);
  }

  status() {
    // Hardcoded since we only do lookups through the proxy
    return {
      lookup: true,
      announce: false
    };
  }

  destroy(cb) {
    this.destroyed = true;
    this.disconnect();
    this._topics = null;
    this._connectedPeers = null;
    this._seenPeers = null;
    if (cb) process.nextTick(cb);
  }

};

function noop() {}

class Details {
  constructor(peer, topic) {
    this.type = 'proxy';
    this.client = true;
    this.peer = {
      host: peer,
      port: 0,
      local: false,
      topic
    };
  } // Can't easily deduplicate yet?


  deduplicate() {
    return false;
  }

}

}).call(this)}).call(this,require('_process'))
},{"./":261,"_process":380,"events":172}],261:[function(require,module,exports){
(function (Buffer){(function (){
const Duplex = require('stream').Duplex;

const lps = require('length-prefixed-stream');

const {
  SwarmEvent,
  EventType
} = require("./messages");

const ProxyStream = require("./proxystream");

const pump = require('pump');

module.exports = class HyperswarmProxyStream extends Duplex {
  constructor(stream) {
    super({
      emitClose: true
    });
    this.connections = new Set(); // There's going to be a lot of listeners

    this.setMaxListeners(256);
    pump(stream, lps.decode(), this, lps.encode(), stream, () => {
      this._closeAllStreams();
    });
    this.on('on_stream_open', this._handleStreamOpen.bind(this));
  }

  ready() {
    this.sendMessage('READY');
  }

  join(topic) {
    this.sendMessage('JOIN', {
      topic
    });
  }

  leave(topic) {
    this.sendMessage('LEAVE', {
      topic
    });
  }

  onPeer(topic, peer) {
    this.sendMessage('ON_PEER', {
      topic,
      peer
    });
  }

  connect(peer) {
    this.sendMessage('CONNECT', {
      peer
    });
  }

  onStreamOpen(topic, peer, stream) {
    this.sendMessage('ON_STREAM_OPEN', {
      topic,
      peer,
      stream
    });
  }

  onStreamData(stream, data) {
    if (typeof data === 'string') {
      data = Buffer.from(data, 'utf8');
    }

    this.sendMessage('ON_STREAM_DATA', {
      stream,
      data
    });
  }

  onStreamClose(stream) {
    this.sendMessage('ON_STREAM_CLOSE', {
      stream
    });
  }

  onStreamError(stream, message, peer) {
    const data = Buffer.from(message, 'utf8');
    this.sendMessage('ON_STREAM_ERROR', {
      stream,
      data
    });
  }

  openStream(topic, peer, stream) {
    const proxy = new ProxyStream(this, stream);

    this._addStream(proxy);

    this.onStreamOpen(topic, peer, stream);
    return proxy;
  }

  _closeAllStreams() {
    for (const connection of this.connections) {
      connection.end();
    }
  }

  _addStream(stream) {
    this.connections.add(stream);
    stream.once('close', () => {
      this.connections.delete(stream);
    });
  }

  _handleStreamOpen({
    topic,
    peer,
    stream
  }) {
    const proxy = new ProxyStream(this, stream);

    this._addStream(proxy);

    this.emit('stream', proxy, {
      topic,
      peer
    });
  }

  sendMessage(type, data = {}) {
    this.push(SwarmEvent.encode({
      type: EventType[type],
      ...data
    }));
  }

  _write(chunk, encoding, callback) {
    try {
      const decoded = SwarmEvent.decode(chunk);
      const {
        type
      } = decoded;

      for (const name of Object.keys(EventType)) {
        if (EventType[name] === type) {
          this.emit(name.toLowerCase(), decoded);
        }
      }

      callback();
    } catch (e) {
      callback(e);
    }
  } // NOOP


  _read() {}

};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./messages":262,"./proxystream":263,"buffer":97,"length-prefixed-stream":291,"pump":394,"stream":548}],262:[function(require,module,exports){
(function (Buffer){(function (){
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */

/* eslint-disable indent */

/* eslint-disable no-redeclare */

/* eslint-disable camelcase */
// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings');

var varint = encodings.varint;
var skip = encodings.skip;
exports.EventType = {
  READY: 1,
  JOIN: 2,
  LEAVE: 3,
  ON_STREAM_OPEN: 4,
  ON_STREAM_CLOSE: 5,
  ON_STREAM_DATA: 6,
  ON_STREAM_ERROR: 7,
  ON_PEER: 8,
  CONNECT: 9
};
var SwarmEvent = exports.SwarmEvent = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
defineSwarmEvent();

function defineSwarmEvent() {
  var enc = [encodings.enum, encodings.bytes, encodings.string, encodings.int32];
  SwarmEvent.encodingLength = encodingLength;
  SwarmEvent.encode = encode;
  SwarmEvent.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.type)) throw new Error("type is required");
    var len = enc[0].encodingLength(obj.type);
    length += 1 + len;

    if (defined(obj.topic)) {
      var len = enc[1].encodingLength(obj.topic);
      length += 1 + len;
    }

    if (defined(obj.data)) {
      var len = enc[1].encodingLength(obj.data);
      length += 1 + len;
    }

    if (defined(obj.peer)) {
      var len = enc[2].encodingLength(obj.peer);
      length += 1 + len;
    }

    if (defined(obj.stream)) {
      var len = enc[3].encodingLength(obj.stream);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.type)) throw new Error("type is required");
    buf[offset++] = 8;
    enc[0].encode(obj.type, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.topic)) {
      buf[offset++] = 18;
      enc[1].encode(obj.topic, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.data)) {
      buf[offset++] = 26;
      enc[1].encode(obj.data, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.peer)) {
      buf[offset++] = 34;
      enc[2].encode(obj.peer, buf, offset);
      offset += enc[2].encode.bytes;
    }

    if (defined(obj.stream)) {
      buf[offset++] = 40;
      enc[3].encode(obj.stream, buf, offset);
      offset += enc[3].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      type: 1,
      topic: null,
      data: null,
      peer: "",
      stream: 0
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.type = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.topic = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 3:
          obj.data = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 4:
          obj.peer = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;

        case 5:
          obj.stream = enc[3].decode(buf, offset);
          offset += enc[3].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"protocol-buffers-encodings":382}],263:[function(require,module,exports){
var Duplex = require('stream').Duplex;

module.exports = class ProxyStream extends Duplex {
  constructor(protocol, id) {
    super({
      emitClose: true
    });
    this._secretId = Math.random();
    this._id = id;
    this._protocol = protocol;
    this._isClosed = false;
    this._handle_data = this._handleData.bind(this);
    this._handle_close = this._handleClose.bind(this);
    this._handle_error = this._handleError.bind(this);

    this._protocol.on('on_stream_data', this._handle_data);

    this._protocol.on('on_stream_close', this._handle_close);

    this._protocol.on('on_stream_error', this._handle_error);
  }

  _handleData({
    stream,
    data
  }) {
    // See if the event was for this stream
    if (this._isId(stream)) {
      this.push(data);
    }
  }

  _handleClose({
    stream
  }) {
    if (this._isId(stream)) {
      this.destroy();

      this._cleanup();
    }
  }

  _handleError({
    stream,
    data
  }) {
    if (this._isId(stream)) {
      const message = data.toString('utf8');
      this.emit('error', new Error(message));
      this.destroy();

      this._cleanup();
    }
  }

  _cleanup() {
    this._isClosed = true;

    this._protocol.removeListener('on_stream_data', this._handle_data);

    this._protocol.removeListener('on_stream_close', this._handle_close);

    this._protocol.removeListener('on_stream_error', this._handle_error);
  }

  _isId(streamid) {
    return streamid === this._id;
  }

  _read() {}

  _write(chunk, encoding, callback) {
    this._protocol.onStreamData(this._id, chunk);

    callback();
  }

  _final(callback) {
    if (!this._isClosed) {
      this._protocol.onStreamClose(this._id);

      this._cleanup();
    }

    callback();
  }

};

},{"stream":548}],264:[function(require,module,exports){
(function (process){(function (){
const {
  EventEmitter
} = require('events');

const webRTCSwarm = require('@geut/discovery-swarm-webrtc');

const HyperswarmClient = require('hyperswarm-proxy-ws/client');

const DuplexPair = require('duplexpair');

const DEFAULT_WEBRTC_BOOTSTRAP = ['wss://geut-webrtc-signal-v3.herokuapp.com', 'wss://signal.dat-web.eu', 'wss://geut-webrtc-signal-v3.glitch.me'];
const DEFAULT_PROXY_SERVER = 'wss://hyperswarm.mauve.moe';

module.exports = function swarm(opts) {
  return new HyperswarmWeb(opts);
};

function getBootstrapUrls(path, defaultUrls = [], specificUrls = []) {
  let urls = defaultUrls.map(url => {
    if (url.endsWith('/')) {
      url = url.slice(0, -1);
    }

    return `${url}/${path}`;
  });
  urls = urls.concat(specificUrls);
  if (urls.length === 0) return;
  return urls;
}

class HyperswarmWeb extends EventEmitter {
  constructor(opts = {}) {
    super();
    const {
      bootstrap,
      webrtcBootstrap,
      wsProxy,
      maxPeers,
      simplePeer,
      wsReconnectDelay
    } = opts;
    this.webrtcOpts = {
      maxPeers,
      simplePeer,
      bootstrap: getBootstrapUrls('signal', bootstrap, webrtcBootstrap) || DEFAULT_WEBRTC_BOOTSTRAP
    };
    this.wsOpts = {
      maxPeers,
      proxy: getBootstrapUrls('proxy', bootstrap, wsProxy) || DEFAULT_PROXY_SERVER
    };

    if (wsReconnectDelay) {
      this.wsOpts.reconnectDelay = wsReconnectDelay;
    }

    this.isListening = false;
    this.destroyed = false;
  }

  _handleWS(connection, info) {
    this.emit('connection', connection, info);
  }

  _handleWebRTC(connection, info) {
    const {
      id,
      channel,
      initiator
    } = info;
    const peerInfo = {
      type: 'webrtc',
      client: initiator,
      peer: {
        port: 0,
        host: id,
        topic: channel
      },
      // TODO: Add deduplication to WebRTC logic
      deduplicate: () => false
    };
    this.emit('connection', connection, peerInfo);
  }

  address() {
    // TODO: What could possibly go here?!?!?!
    return {
      port: 0,
      family: 'IPv4',
      address: '127.0.0.1'
    };
  }

  listen(port, cb) {
    if (this.isListening) return setTimeout(cb, 0);
    this.isListening = true;
    this.webrtc = webRTCSwarm(this.webrtcOpts);
    this.ws = new HyperswarmClient(this.wsOpts);
    this.ws.on('connection', (connection, info) => this._handleWS(connection, info));
    this.webrtc.on('connection', (connection, info) => this._handleWebRTC(connection, info));
  }

  join(key, opts) {
    this.listen();
    this.webrtc.join(key);
    this.ws.join(key, opts);
  }

  leave(key) {
    this.listen();
    this.webrtc.leave(key);
    this.ws.leave(key);
  }

  connect(peer, cb) {
    this.listen();
    this.ws.connect(peer, cb);
  }

  connectivity(cb) {
    this.listen(() => {
      cb(null, {
        bound: true,
        bootstrapped: true,
        holepunched: true
      });
    });
  } // No clue how to implement this, it's undocumented


  flush(cb) {
    process.nextTick(cb);
  } // Always return that we're looking up and not announcing


  status() {
    return {
      lookup: true,
      announce: false
    };
  }

  destroy(cb) {
    this.destroyed = true;
    this.webrtc.close(() => {
      this.ws.destroy(cb);
    });
  }

}

}).call(this)}).call(this,require('_process'))
},{"@geut/discovery-swarm-webrtc":5,"_process":380,"duplexpair":148,"events":172,"hyperswarm-proxy-ws/client":259}],265:[function(require,module,exports){
(function (Buffer,process){(function (){
const events = require('events');

const mutexify = require('mutexify');

const thunky = require('thunky');

const codecs = require('codecs');

const bulk = require('bulk-write-stream');

const toStream = require('nanoiterator/to-stream');

const isOptions = require('is-options');

const hypercore = require('hypercore');

const inherits = require('inherits');

const alru = require('array-lru');

const set = require('unordered-set');

const Extension = require("./lib/extension");

const Node = require("./lib/node");

const Get = require("./lib/get");

const Put = require("./lib/put");

const Batch = require("./lib/batch");

const Delete = require("./lib/del");

const History = require("./lib/history");

const Iterator = require("./lib/iterator");

const Watch = require("./lib/watch");

const Diff = require("./lib/diff");

const {
  Header
} = require("./lib/messages");

module.exports = HyperTrie;

function HyperTrie(storage, key, opts) {
  if (!(this instanceof HyperTrie)) return new HyperTrie(storage, key, opts);

  if (isOptions(key)) {
    opts = key;
    key = null;
  }

  if (!opts) opts = {};
  events.EventEmitter.call(this);
  this.id = null;
  this.key = null;
  this.discoveryKey = null;
  this.secretKey = null;
  this.metadata = opts.metadata || null;
  this.hash = opts.hash || null;
  this.valueEncoding = opts.valueEncoding ? codecs(opts.valueEncoding) : null;
  this.alwaysUpdate = !!opts.alwaysUpdate;
  this.alwaysReconnect = !!opts.alwaysReconnect;
  this.subtype = opts.subtype;
  const feedOpts = Object.assign({}, opts, {
    valueEncoding: 'binary'
  });
  this.feed = opts.feed || hypercore(storage, key, feedOpts);
  this.feed.maxRequests = opts.maxRequests || 256; // set max requests higher since the payload is small

  this.opened = false;
  this.ready = thunky(this._ready.bind(this));
  this._extension = opts.extension === false ? null : (opts.extension === true ? null : opts.extension) || new Extension(this);
  if (this._extension && !this._extension.outgoing) this._extension.outgoing = this.feed.registerExtension('hypertrie', this._extension);
  this._watchers = [];
  this._checkout = opts && opts.checkout || 0;
  this._cache = alru(opts && opts.cacheSize || 32768);
  this._lock = mutexify();
  if (this.feed !== opts.feed) this.feed.on('error', this._onerror.bind(this));
  if (!this._checkout) this.feed.on('append', this._onappend.bind(this));
}

inherits(HyperTrie, events.EventEmitter);
Object.defineProperty(HyperTrie.prototype, 'version', {
  enumerable: true,
  get: function () {
    return this._checkout || this.feed.length;
  }
});

HyperTrie.prototype._removeWatch = function (w) {
  set.remove(this._watchers, w);
};

HyperTrie.prototype._addWatch = function (w) {
  const self = this;
  set.add(this._watchers, w);
  if (this._watchers.length > 1 || !this.feed.sparse) return;
  this.feed.update({
    ifAvailable: false
  }, function loop() {
    if (self._watchers.length === 0) return;
    self.feed.update({
      ifAvailable: false
    }, loop);
  });
};

HyperTrie.prototype.reconnect = function (from, opts) {
  opts = opts ? Object.assign({}, opts, {
    reconnect: true
  }) : {
    reconnect: true
  };
  return this.diff(from, opts);
};

HyperTrie.prototype._onerror = function (err) {
  this.emit('error', err);
};

HyperTrie.prototype._onappend = function () {
  for (var i = 0; i < this._watchers.length; i++) {
    this._watchers[i].update();
  }

  this.emit('append');
};

HyperTrie.prototype._ready = function (cb) {
  const self = this;
  this.feed.ready(function (err) {
    if (err) return done(err);
    if (self.feed.length || !self.feed.writable) return done(null);
    self.feed.append(Header.encode({
      type: 'hypertrie',
      metadata: self.metadata,
      subtype: this.subtype
    }), done);

    function done(err) {
      if (err) return cb(err);
      if (self._checkout === -1) self._checkout = self.feed.length;
      self.id = self.feed.id;
      self.key = self.feed.key;
      self.discoveryKey = self.feed.discoveryKey;
      self.secretKey = self.feed.secretKey;
      self.opened = true;
      self.emit('ready');

      if (self.alwaysReconnect) {
        var from = self.feed.length;
        var active = null;
        self.feed.on('append', function () {
          if (!from) {
            from = self.feed.length;
            return;
          }

          if (active) active.destroy();
          self.emit('reconnecting');
          const r = active = self.reconnect(from);
          active.next(function loop(err, data) {
            if (r !== active) return;

            if (err || !data) {
              active = null;
              from = self.feed.length;
              if (!err) self.emit('reconnected');
              return;
            }

            active.next(loop);
          });
        });
      }

      cb(null);
    }
  });
};

HyperTrie.getMetadata = function (feed, cb) {
  feed.get(0, (err, msg) => {
    if (err) return cb(err);

    try {
      var header = Header.decode(msg);
    } catch (err) {
      return cb(err);
    }

    cb(null, header.metadata);
  });
};

HyperTrie.prototype.getMetadata = function (cb) {
  HyperTrie.getMetadata(this.feed, cb);
};

HyperTrie.prototype.setMetadata = function (metadata) {
  // setMetadata can only be called before this.ready is first called.
  if (this.feed.length || !this.feed.writable) throw new Error('The metadata must be set before any puts have occurred.');
  this.metadata = metadata;
};

HyperTrie.prototype.replicate = function (isInitiator, opts) {
  return this.feed.replicate(isInitiator, opts);
};

HyperTrie.prototype.checkout = function (version) {
  if (version === 0) version = 1;
  return new HyperTrie(null, null, {
    checkout: version || 1,
    valueEncoding: this.valueEncoding,
    feed: this.feed,
    extension: this._extension === null ? false : this._extension
  });
};

HyperTrie.prototype.snapshot = function () {
  return this.checkout(this.version);
};

HyperTrie.prototype.headSeq = function (opts, cb) {
  const self = this;
  if (!this.opened) return readyAndHeadSeq(this, opts, cb);
  if (this._checkout !== 0) return process.nextTick(cb, null, this._checkout - 1);
  if (this.alwaysUpdate && (!opts || opts.wait !== false)) this.feed.update({
    hash: false,
    ifAvailable: true
  }, onupdated);else process.nextTick(onupdated);

  function onupdated() {
    if (self.feed.length < 2) return cb(null, 0);
    cb(null, self.feed.length - 1);
  }
};

HyperTrie.prototype.head = function (opts, cb) {
  if (typeof opts === 'function') return this.head(null, opts);
  const self = this;
  this.headSeq(opts, function (err, seq) {
    if (err) return cb(err);
    if (!seq) return cb(null, null);
    self.getBySeq(seq, opts, cb);
  });
};

HyperTrie.prototype.list = function (prefix, opts, cb) {
  if (typeof prefix === 'function') return this.list('', null, prefix);
  if (typeof opts === 'function') return this.list(prefix, null, opts);
  const ite = this.iterator(prefix, opts);
  const res = [];
  ite.next(function loop(err, node) {
    if (err) return cb(err);
    if (!node) return cb(null, res);
    res.push(node);
    ite.next(loop);
  });
};

HyperTrie.prototype.iterator = function (prefix, opts) {
  if (isOptions(prefix)) return this.iterator('', prefix);
  return new Iterator(this, prefix, opts);
};

HyperTrie.prototype.createReadStream = function (prefix, opts) {
  return toStream(this.iterator(prefix, opts));
};

HyperTrie.prototype.history = function (opts) {
  return new History(this, opts);
};

HyperTrie.prototype.createHistoryStream = function (opts) {
  return toStream(this.history(opts));
};

HyperTrie.prototype.diff = function (other, prefix, opts) {
  if (Buffer.isBuffer(other)) return this.diff(0, prefix, Object.assign(opts || {}, {
    checkpoint: other
  }));
  if (isOptions(prefix)) return this.diff(other, null, prefix);
  const checkout = typeof other === 'number' || !other ? this.checkout(other) : other;
  return new Diff(this, checkout, prefix, opts);
};

HyperTrie.prototype.createDiffStream = function (other, prefix, opts) {
  return toStream(this.diff(other, prefix, opts));
};

HyperTrie.prototype.get = function (key, opts, cb) {
  if (typeof opts === 'function') return this.get(key, null, opts);
  return new Get(this, key, opts, cb);
};

HyperTrie.prototype.watch = function (key, onchange) {
  if (typeof key === 'function') return this.watch('', key);
  return new Watch(this, key, onchange);
};

HyperTrie.prototype.batch = function (ops, cb) {
  return new Batch(this, ops, cb || noop);
};

HyperTrie.prototype.put = function (key, value, opts, cb) {
  if (typeof opts === 'function') return this.put(key, value, null, opts);
  opts = Object.assign({}, opts, {
    batch: null,
    del: 0
  });
  return new Put(this, key, value, opts, cb || noop);
};

HyperTrie.prototype.del = function (key, opts, cb) {
  if (typeof opts === 'function') return this.del(key, null, opts);
  opts = Object.assign({}, opts, {
    batch: null
  });
  return new Delete(this, key, opts, cb);
};

HyperTrie.prototype.createWriteStream = function (opts) {
  const self = this;
  return bulk.obj(write);

  function write(batch, cb) {
    if (batch.length && Array.isArray(batch[0])) batch = flatten(batch);
    self.batch(batch, cb);
  }
};

HyperTrie.prototype.getBySeq = function (seq, opts, cb) {
  if (typeof opts === 'function') return this.getBySeq(seq, null, opts);
  if (seq < 1) return process.nextTick(cb, null, null);
  const self = this;

  const cached = this._cache.get(seq);

  if (cached) return process.nextTick(onnode, null, cached);
  this.feed.get(seq, opts, onnode);

  function onnode(err, val) {
    if (err) return cb(err);
    const node = Node.decode(val, seq, self.valueEncoding, self.hash);

    self._cache.set(seq, val); // early exit for the key: '' nodes we write to reset the db


    if (!node.value && !node.key) return cb(null, null);
    cb(null, node);
  }
};

function noop() {}

function readyAndHeadSeq(self, opts, cb) {
  self.ready(function (err) {
    if (err) return cb(err);
    self.headSeq(opts, cb);
  });
}

function flatten(list) {
  const result = [];

  for (var i = 0; i < list.length; i++) {
    const next = list[i];

    for (var j = 0; j < next.length; j++) result.push(next[j]);
  }

  return result;
}

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))
},{"../is-buffer/index.js":282,"./lib/batch":266,"./lib/del":267,"./lib/diff":268,"./lib/extension":269,"./lib/get":270,"./lib/history":271,"./lib/iterator":272,"./lib/messages":273,"./lib/node":274,"./lib/put":275,"./lib/watch":277,"_process":380,"array-lru":17,"bulk-write-stream":98,"codecs":118,"events":172,"hypercore":241,"inherits":279,"is-options":284,"mutexify":318,"nanoiterator/to-stream":324,"thunky":568,"unordered-set":575}],266:[function(require,module,exports){
const Put = require("./put");

const Delete = require("./del");

module.exports = Batch;

function Batch(db, ops, cb) {
  this._db = db;
  this._ops = ops;
  this._callback = cb;
  this._head = null;
  this._nodes = [];
  this._offset = 0;
  this._op = null;

  this._start();
}

Batch.prototype.get = function (seq) {
  if (seq < this._offset) return null;
  return this._nodes[seq - this._offset];
};

Batch.prototype.head = function () {
  return this._head;
};

Batch.prototype.append = function (node) {
  node.seq = this._offset + this._nodes.length;
  node.preencode();

  this._nodes.push(node);
};

Batch.prototype._finalize = function (err) {
  const self = this;
  if (err) return done(err);
  const buffers = new Array(this._nodes.length);

  for (var i = 0; i < buffers.length; i++) {
    buffers[i] = this._nodes[i].encode();
  }

  this._db.feed.append(buffers, done);

  function done(err) {
    self._release(self._callback, err, self._nodes);
  }
};

Batch.prototype._start = function () {
  const self = this;

  this._db._lock(function (release) {
    self._release = release;

    self._db.ready(function () {
      self._offset = self._db.feed.length;

      self._db.head(function (err, head) {
        if (err) return self._finalize(err);
        self._head = head;

        self._update();
      });
    });
  });
};

Batch.prototype._update = function () {
  var i = 0;
  const self = this;
  loop(null, null);

  function loop(err, head) {
    if (err) return self._finalize(err);
    if (i === self._ops.length) return self._finalize(null);
    if (head) self._head = head;
    const {
      type,
      key,
      value,
      hidden,
      flags
    } = self._ops[i++];
    if (type === 'del') self._op = new Delete(self._db, key, {
      batch: self,
      hidden
    }, loop);else self._op = new Put(self._db, key, value === undefined ? null : value, {
      batch: self,
      del: 0,
      hidden,
      flags
    }, loop);
  }
};

},{"./del":267,"./put":275}],267:[function(require,module,exports){
(function (process){(function (){
const Put = require("./put");

const Node = require("./node");

module.exports = Delete;

function Delete(db, key, {
  batch,
  condition = null,
  hidden = false,
  closest = false
}, cb) {
  this._db = db;
  this._key = key;
  this._callback = cb;
  this._release = null;
  this._put = null;
  this._batch = batch;
  this._condition = condition;
  this._node = new Node({
    key,
    flags: hidden ? Node.Flags.HIDDEN : 0
  }, null, null, db.hash);
  this._length = this._node.length;
  this._returnClosest = closest;
  this._closest = 0;
  if (this._batch) this._update(0, this._batch.head());else this._lock();
}

Delete.prototype._lock = function () {
  const self = this;

  this._db._lock(function (release) {
    self._release = release;

    self._start();
  });
};

Delete.prototype._start = function () {
  const self = this;

  this._db.head(onhead);

  function onhead(err, head) {
    if (err) return self._finalize(err, null);
    if (!head) return self._finalize(null, null);

    self._update(0, head);
  }
};

Delete.prototype._finalize = function (err, node) {
  if (!this._release) this._callback(err, node);else this._release(this._callback, err, node);
};

Delete.prototype._splice = function (closest, node) {
  const key = closest ? closest.key : '';
  const valueBuffer = closest ? closest.valueBuffer : null;
  const hidden = closest ? closest.hidden : node.hidden;
  const flags = closest ? closest.flags >> 8 : 0;
  const self = this;
  if (this._condition) this._condition(node.final(), oncondition);else del();

  function oncondition(err, proceed) {
    if (err) return done(err);
    if (!proceed) return done(null);
    return del();
  }

  function del() {
    self._put = new Put(self._db, key, null, {
      batch: self._batch,
      del: node.seq,
      hidden,
      valueBuffer,
      flags
    }, done);
  }

  function done(err, node) {
    self._finalize(err, node);
  }
};

Delete.prototype._update = function (i, head) {
  const self = this;
  if (!head) return terminate();
  const node = this._node;

  for (; i < this._length; i++) {
    const val = node.path(i);
    const bucket = head.trie[i] || [];

    if (head.path(i) === val) {
      const closest = firstSeq(bucket, val);
      if (closest) this._closest = closest;
      continue;
    }

    const seq = bucket[val];
    if (!seq) return terminate();
    this._closest = head.seq;

    this._updateHead(i, seq);

    return;
  } // TODO: collisions


  if (node.key !== head.key) return terminate();

  this._spliceClosest(head);

  function terminate() {
    if (self._condition && self._returnClosest) {
      return self._condition(head && head.final(), (err, proceed) => {
        if (err) return self._finalize(err);
        return self._finalize(null, null);
      });
    }

    return self._finalize(null, null);
  }
};

Delete.prototype._spliceClosest = function (head) {
  if (!this._closest) return this._splice(null, head);
  const self = this;

  this._get(this._closest, function (err, closest) {
    if (err) return self._finalize(err, null);

    self._splice(closest, head);
  });
};

Delete.prototype._get = function (seq, onnode) {
  const node = this._batch && this._batch.get(seq);

  if (node) return process.nextTick(onnode, null, node);

  this._db.getBySeq(seq, onnode);
};

Delete.prototype._updateHead = function (i, seq) {
  const self = this;

  this._get(seq, onnode);

  function onnode(err, node) {
    if (err) return self._finalize(err, null);

    self._update(i + 1, node);
  }
};

function firstSeq(bucket, val) {
  for (var i = 0; i < bucket.length; i++) {
    if (i === val) continue;
    const seq = bucket[i];
    if (seq) return seq;
  }

  return 0;
}

}).call(this)}).call(this,require('_process'))
},{"./node":274,"./put":275,"_process":380}],268:[function(require,module,exports){
(function (Buffer){(function (){
const Nanoiterator = require('nanoiterator');

const inherits = require('inherits');

const Node = require("./node");

const varint = require('varint');

module.exports = Diff;

function Diff(db, checkout, prefix, opts) {
  Nanoiterator.call(this);
  this._db = db;
  this._prefix = prefix || '';
  this._checkout = checkout;
  this._stack = [];
  this._pending = 0;
  this._error = null;
  this._callback = null;
  this._left = [];
  this._right = [];
  this._onnode = opts && opts.onnode || null;
  this._hidden = !!(opts && opts.hidden);
  this._needsCheck = [];
  this._skipLeftNull = !!(opts && opts.skipLeftNull);
  this._skipRightNull = !!(opts && opts.skipRightNull);
  this._checkpoint = opts && opts.checkpoint || null;
  this._reconnect = !!(opts && opts.reconnect);
  this._pendingQueue = [];
  this.maxInflight = opts && opts.maxInflight || (this._reconnect ? 4 : Infinity);
  if (this._reconnect) this._skipRightNull = true;
}

inherits(Diff, Nanoiterator);

Diff.prototype._open = function (cb) {
  if (this._checkpoint) return this._openCheckpoint(cb);
  const self = this;
  const opts = {
    onnode: this._onnode,
    prefix: true,
    hidden: this._hidden
  };

  const get = this._db.get(this._prefix, opts, function (err, a) {
    if (err) return cb(err);

    self._checkout.get(self._prefix, opts, function (err, b) {
      if (err) return cb(err);

      self._stack.push({
        i: get._length,
        left: a,
        right: b,
        skip: false
      });

      cb(null);
    });
  });
};

Diff.prototype._openCheckpoint = function (cb) {
  const self = this;
  const buf = this._checkpoint;
  var ptr = 0;
  loop();

  function loop() {
    if (ptr >= buf.length) return cb(null);
    const i = varint.decode(buf, ptr);
    ptr += varint.decode.bytes;
    const l = varint.decode(buf, ptr);
    ptr += varint.decode.bytes;
    const r = varint.decode(buf, ptr);
    ptr += varint.decode.bytes;

    self._db.getBySeq(l, function (err, left) {
      if (err) return cb(err);

      self._db.getBySeq(r, function (err, right) {
        if (err) return cb(err);

        self._stack.push({
          i,
          left,
          right,
          skip: false
        });

        loop();
      });
    });
  }
};

Diff.prototype.checkpoint = function () {
  const buf = Buffer.alloc(this._stack.length * 8 * 3);
  var ptr = 0;

  for (var i = 0; i < this._stack.length; i++) {
    const s = this._stack[i];
    if (s.skip) continue;
    varint.encode(s.i, buf, ptr);
    ptr += varint.encode.bytes;
    varint.encode(s.left ? s.left.seq : 0, buf, ptr);
    ptr += varint.encode.bytes;
    varint.encode(s.right ? s.right.seq : 0, buf, ptr);
    ptr += varint.encode.bytes;
  }

  return buf.slice(0, ptr);
};

Diff.prototype._finalize = function () {
  const callback = this._callback;
  if (!callback) return;
  if (this.closed) return callback(new Error('Iterator closed'));
  const err = this._error;
  this._callback = this._error = null;
  if (err) return callback(err);

  while (this._needsCheck.length) {
    const end = this._needsCheck.pop();

    const start = this._needsCheck.pop();

    this._maybeCollides(start, end);
  }

  this._next(callback);
};

Diff.prototype._next = function (cb) {
  this._nextAsync(cb);
};

Diff.prototype._has = async function (seq) {
  this._pending++;

  try {
    return await this._db.feed.has(seq);
  } catch (err) {
    this._error = err;
  } finally {
    this._pending--;
  }
};

Diff.prototype._nextAsync = async function (cb) {
  if (this._pending) {
    this._callback = cb;
    return;
  }

  if (this._error) return cb(this._error);

  while (this._stack.length) {
    const {
      i,
      left,
      right,
      skip
    } = this._stack.pop();

    if (skip || seq(left) === seq(right)) continue;
    const doneLeft = done(left, i);
    const doneRight = done(right, i);
    if (doneLeft && doneRight) return call(cb, left, right);
    if (!right && left && this._skipRightNull) continue;
    if (right && !left && this._skipLeftNull) continue;
    const leftVal = left ? left.path(i) : 5;
    const rightVal = right ? right.path(i) : 6;
    const leftBucket = trie(left, i);
    const rightBucket = trie(right, i);

    for (var j = 0; j < 5; j++) {
      const leftSeq = leftVal === j ? left.seq : 0;
      const rightSeq = rightVal === j ? right.seq : 0;
      const len = this._stack.length;
      var leftLen = this._stack.length;
      var rightLen = this._stack.length;
      var val;

      if (leftSeq !== rightSeq) {
        if (!doneLeft && leftSeq && notInBucket(j, leftSeq, rightBucket)) {
          set(this._pushStack(leftLen++, i + 1), true, left);
        }

        if (!doneRight && rightSeq && notInBucket(j, rightSeq, leftBucket)) {
          set(this._pushStack(rightLen++, i + 1), false, right);
        }
      }

      if (!doneLeft) {
        const pushLeft = !this._skipRightNull || rightBucket[j] && (!this._reconnect || (await this._hasSeqInBucket(rightBucket, j)));

        for (val = j; val < leftBucket.length; val += 5) {
          const seq = leftBucket[val];
          if (!seq) break;

          if (seq !== rightSeq && notInBucket(j, seq, rightBucket)) {
            const top = this._pushStack(leftLen++, i + 1);

            if (pushLeft || top.right) this._getNode(seq, top, true);else top.skip = true;
          }
        }
      }

      if (!doneRight) {
        const pushRight = !this._skipLeftNull || leftBucket[j];

        for (val = j; val < rightBucket.length; val += 5) {
          const seq = rightBucket[val];
          if (!seq) break;

          if (seq !== leftSeq && notInBucket(j, seq, leftBucket) && (!this._reconnect || (await this._has(seq)))) {
            const top = this._pushStack(rightLen++, i + 1);

            if (pushRight || top.left) this._getNode(seq, top, false);else top.skip = true;
          }
        }
      }

      if (Node.terminator(i) && this._stack.length > len) {
        if (!this._pending) this._maybeCollides(len, this._stack.length);else this._needsCheck.push(len, this._stack.length);
      }
    }

    if (doneLeft) return call(cb, left, null);
    if (doneRight) return call(cb, null, right);
    if (!this._pending) continue;
    this._callback = cb;
    return;
  }

  cb(null, null);
};

Diff.prototype._hasSeqInBucket = async function (bucket, val) {
  for (; val < bucket.length; val += 5) {
    if (bucket[val] && (await this._has(bucket[val]))) return true;
  }

  return false;
};

Diff.prototype._maybeCollides = function (start, end) {
  // all nodes, start -> end, share the same hash
  // we need to check that there are no collisions
  // much simpler and *much* more likely - only one node
  if (end - start === 1) {
    const top = this._stack[start];

    if (collides(top)) {
      this._stack.push({
        i: top.i,
        left: null,
        right: top.right,
        skip: top.skip
      });

      top.right = null;
    }

    return;
  } // very unlikely, but multiple collisions or a trie reordering
  // due to a collision being deleted


  for (var i = start; i < end; i++) {
    const top = this._stack[i];

    if (collides(top) || !top.left) {
      const right = top.right;

      for (var j = start; j < end; j++) {
        const other = this._stack[j];

        if (other.left && !other.left.collides(right)) {
          top.right = other.right;
          other.right = right;
          i--; // revisit top again, as it might still collide

          break;
        }
      }

      if (top.right === right && top.left) {
        this._stack.push({
          i: top.i,
          left: null,
          right,
          skip: top.skip
        });

        top.right = null;
      }
    }
  }
};

Diff.prototype._pushStack = function (len, i) {
  if (this._stack.length === len) this._stack.push({
    i,
    left: null,
    right: null,
    skip: false
  });
  return this._stack[len];
};

Diff.prototype._getNode = function (seq, top, left) {
  const self = this;
  this._pending++;
  const inflight = this._pending - this._pendingQueue.length;

  if (inflight >= this.maxInflight) {
    this._pendingQueue.push([seq, top, left]);

    return;
  }

  this._db.getBySeq(seq, onnode);

  function onnode(err, node) {
    if (self._onnode && node) self._onnode(node);
    if (node) set(top, left, node);else if (err) self._error = err;
    if (! --self._pending) self._finalize();

    if (self._pendingQueue.length && self._pending - self._pendingQueue.length < self.maxInflight) {
      const [seq, top, left] = self._pendingQueue.pop();

      self._pending--;

      self._getNode(seq, top, left);
    }
  }
};

function notInBucket(val, seq, bucket) {
  for (; val < bucket.length; val += 5) {
    if (bucket[val] === seq) return false;
  }

  return true;
}

function set(top, left, node) {
  if (left) top.left = node;else top.right = node;
}

function call(cb, left, right) {
  cb(null, {
    key: left ? left.key : right.key,
    left: left && left.final(),
    right: right && right.final()
  });
}

function trie(node, i) {
  return node && node.trie[i] || [];
}

function seq(node) {
  return node ? node.seq : 0;
}

function done(node, i) {
  return !!node && i >= node.length;
}

function collides(top) {
  if (!top.left || !top.right || !Node.terminator(top.i)) return false;
  return top.left.collides(top.right, top.i);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./node":274,"buffer":97,"inherits":279,"nanoiterator":323,"varint":582}],269:[function(require,module,exports){
const MAX_ACTIVE = 32;
const FLUSH_BATCH = 128;
const MAX_PASSIVE_BATCH = 2048;
const MAX_ACTIVE_BATCH = MAX_PASSIVE_BATCH + FLUSH_BATCH;

const {
  Extension
} = require("./messages");

class Batch {
  constructor(outgoing, from) {
    this.blocks = [];
    this.start = 0;
    this.end = 0;
    this.outgoing = outgoing;
    this.from = from;
  }

  push(seq) {
    const len = this.blocks.push(seq);
    if (len === 1 || seq < this.start) this.start = seq;
    if (len === 1 || seq >= this.end) this.end = seq + 1;

    if (len >= FLUSH_BATCH) {
      this.send();
      this.clear();
    }
  }

  send() {
    if (!this.blocks.length) return;
    this.outgoing.send(Extension.encode({
      cache: {
        blocks: this.blocks,
        start: this.start,
        end: this.end
      }
    }), this.from);
  }

  clear() {
    this.start = this.end = 0;
    this.blocks = [];
  }

}

class HypertrieExtension {
  constructor(trie) {
    this.encoding = null;
    this.outgoing = null;
    this.trie = trie;
    this.active = 0;
  }

  onmessage(buf, from) {
    const message = decode(buf);
    if (!message) return;
    if (message.cache) this.oncache(message.cache, from);
    if (message.iterator) this.oniterator(message.iterator, from);
    if (message.get) this.onget(message.get, from);
  }

  get(head, key) {
    this.outgoing.broadcast(Extension.encode({
      get: {
        head,
        key
      }
    }));
  }

  iterator(head, key, flags, checkpoint) {
    this.outgoing.broadcast(Extension.encode({
      iterator: {
        head,
        key,
        flags,
        checkpoint
      }
    }));
    return MAX_PASSIVE_BATCH;
  }

  oncache(message, from) {
    if (!message.blocks.length) return;
    if (message.blocks.length > MAX_ACTIVE_BATCH) message.blocks = message.blocks.slice(0, MAX_ACTIVE_BATCH);
    this.trie.feed.download(message);
  }

  oniterator(message, from) {
    if (message.key === null && !message.checkpoint) return;
    if (this.active >= MAX_ACTIVE) return;
    this.active++;
    this.trie.emit('extension-iterator', message.key);
    const self = this;
    let total = 0;
    const checkpointed = !!message.checkpoint;
    const b = new Batch(this.outgoing, from);
    const ite = message.key ? this.trie.checkout(message.head + 1).iterator(message.key, {
      extension: false,
      wait: false,
      onseq
    }) : this.trie.iterator({
      extension: false,
      wait: false,
      checkpoint: message.checkpoint,
      onseq
    });
    ite.next(onnext);

    function onseq(seq) {
      if (checkpointed && !ite.opened) return;
      total++;
      b.push(seq);
    }

    function onnext(err, node) {
      if (err || node === null || total >= MAX_ACTIVE_BATCH) {
        self.active--;
        b.send();
      } else {
        ite.next(onnext);
      }
    }
  }

  onget(message, from) {
    if (!message.key) return;
    if (this.active >= MAX_ACTIVE) return;
    this.active++;
    this.trie.emit('extension-get', message.key);
    const self = this;
    const b = new Batch(this.outgoing, from);
    this.trie.checkout(message.head + 1).get(message.key, {
      extension: false,
      wait: false,
      onseq
    }, ondone);

    function onseq(seq) {
      b.push(seq);
    }

    function ondone() {
      self.active--;
      b.send();
    }
  }

}

HypertrieExtension.BATCH_SIZE = MAX_PASSIVE_BATCH;
module.exports = HypertrieExtension;

function decode(buf) {
  try {
    return Extension.decode(buf);
  } catch (err) {
    return null;
  }
}

},{"./messages":273}],270:[function(require,module,exports){
const Node = require("./node");

module.exports = Get;

function Get(db, key, opts, cb) {
  this._db = db;
  this._node = new Node({
    key,
    flags: opts && opts.hidden ? Node.Flags.HIDDEN : 0
  }, 0, null, db.hash);
  this._callback = cb;
  this._prefix = !!(opts && opts.prefix);
  this._closest = !!(opts && opts.closest);
  this._length = this._node.length - (this._prefix ? 1 : 0);
  this._onseq = opts && opts.onseq || null;
  this._options = opts ? {
    wait: opts.wait,
    timeout: opts.timeout,
    onwait: null
  } : {
    onwait: null
  };
  this._extension = !opts || opts.extension !== false ? this._db._extension : null;
  this._extensionSent = !this._extension;
  this._head = 0;
  this._onheadseq = opts && opts.onheadseq || null;
  this._options.onwait = this._extension ? this._sendExt.bind(this) : opts && opts.onwait || null;

  this._start();
}

Get.prototype._start = function () {
  const self = this;

  this._db.headSeq(this._options, onheadseq);

  function onheadseq(err, seq) {
    if (err) return self._callback(err, null);
    if (!seq) return onhead(null, null);
    if (self._onheadseq) self._onheadseq(seq);
    self._head = seq;
    if (self._onseq) self._onseq(seq);

    self._db.getBySeq(seq, self._options, onhead);
  }

  function onhead(err, head) {
    if (err) return self._callback(err, null);

    self._update(0, head);
  }
};

Get.prototype._sendExt = function () {
  if (this._head && this._extension && !this._extensionSent) {
    this._options.onwait = null;
    this._extensionSent = true;

    this._extension.get(this._head, this._node.key);
  }
};

Get.prototype._update = function (i, head) {
  if (!head) return this._callback(null, null);
  const node = this._node;

  for (; i < this._length; i++) {
    const val = node.path(i);
    const checkCollision = Node.terminator(i);

    if (head.path(i) === val) {
      if (!checkCollision || !node.collides(head, i)) continue;
    }

    const bucket = head.trie[i] || [];
    if (checkCollision) return this._updateHeadCollides(i, bucket, val);
    const seq = bucket[val];
    if (!seq) return this._callback(null, this._closest ? head.final() : null);
    return this._updateHead(i, seq);
  }

  this._callback(null, head.final());
};

Get.prototype._updateHeadCollides = function (i, bucket, val) {
  const self = this;
  var missing = 1;
  var error = null;
  var node = null;

  for (var j = val; j < bucket.length; j += 5) {
    const seq = bucket[j];
    if (!seq) break;
    missing++;
    if (this._onseq) this._onseq(seq);

    this._db.getBySeq(seq, this._options, onnode);
  }

  onnode(null, null);

  function onnode(err, n) {
    if (err) error = err;else if (n && !n.collides(self._node, i)) node = n;
    if (--missing) return;
    if (!node || error) return self._callback(error, this._closest ? this._node : null);

    self._update(i + 1, node);
  }
};

Get.prototype._updateHead = function (i, seq) {
  const self = this;
  if (this._onseq) this._onseq(seq);

  this._db.getBySeq(seq, this._options, onnode);

  function onnode(err, node) {
    if (err) return self._callback(err, null);

    self._update(i + 1, node);
  }
};

},{"./node":274}],271:[function(require,module,exports){
const Nanoiterator = require('nanoiterator');

const inherits = require('inherits');

module.exports = History;

function History(db, opts) {
  if (!opts) opts = {};
  if (typeof opts.gt === 'number') opts.gte = opts.gt + 1;
  if (typeof opts.lt === 'number') opts.lte = opts.lt - 1;
  Nanoiterator.call(this);
  this._gte = ifNumber(opts.gte, 1);
  this._lte = ifNumber(opts.lte, -1);
  this._reverse = !!(opts && opts.reverse);
  this._db = db;
  this._live = !!(opts && opts.live);
}

inherits(History, Nanoiterator);

History.prototype._open = function (cb) {
  const self = this;

  if (this._live && !this._reverse) {
    this._lte = Infinity;
    return cb(null);
  }

  this._db.head(onhead);

  function onhead(err, head) {
    if (err) return cb(err);
    const headSeq = head ? head.seq : -1;
    self._lte = self._lte === -1 ? headSeq : Math.min(self._lte, headSeq);
    cb(null);
  }
};

History.prototype._next = function (cb) {
  if (this._gte > this._lte) return cb(null, null);

  this._db.getBySeq(this._reverse ? this._lte-- : this._gte++, done);

  function done(err, node) {
    if (err) return cb(err);
    cb(null, node.final());
  }
};

function ifNumber(n, def) {
  return typeof n === 'number' ? n : def;
}

},{"inherits":279,"nanoiterator":323}],272:[function(require,module,exports){
(function (Buffer){(function (){
const Nanoiterator = require('nanoiterator');

const inherits = require('inherits');

const varint = require('varint');

const Node = require("./node");

const {
  BATCH_SIZE
} = require("./extension");

const SORT_ORDER = [4, 0, 1, 2, 3].reverse();
const REVERSE_SORT_ORDER = SORT_ORDER.slice(0).reverse();
module.exports = Iterator;

function Iterator(db, prefix, opts) {
  Nanoiterator.call(this);

  if (opts && opts.flags) {
    opts.recursive = opts.flags & 1;
    opts.reverse = opts.flags & 2;
    opts.gt = opts.flags & 4;
    opts.hidden = opts.flags & 8;
  }

  this._checkpoint = opts && opts.checkpoint || null;
  this._prefix = Node.normalizeKey(prefix || '');
  this._recursive = !opts || opts.recursive !== false;
  this._order = opts && opts.reverse ? REVERSE_SORT_ORDER : SORT_ORDER;
  this._random = !!(opts && opts.random);
  this._extension = opts && opts.extension === false ? null : db._extension;
  this._extensionState = this._extension ? {
    missing: 0,
    head: 0,
    checkpoint: false
  } : null;
  this._onseq = opts && opts.onseq || null;
  this._start = 0;
  this._end = 0;
  this._db = db;
  this._stack = [];
  this._callback = null;
  this._pending = 0;
  this._error = null;
  this._gt = !!(opts && opts.gt);
  this._needsSort = [];
  this._options = opts ? {
    extension: opts.extension,
    wait: opts.wait,
    timeout: opts.timeout,
    hidden: !!opts.hidden,
    onseq: opts.onseq,
    onwait: null
  } : {
    onwait: null
  };
  this._flags = (this._recursive ? 1 : 0) | (this._order === REVERSE_SORT_ORDER ? 2 : 0) | (this._gt ? 4 : 0) | (this._options && this._options.hidden ? 8 : 0);
  if (this._extensionState) this._options.onwait = this._sendExt.bind(this);
}

inherits(Iterator, Nanoiterator);

Iterator.prototype._open = function (cb) {
  const self = this;
  const opts = Object.assign(this._options || {}, {
    prefix: true,
    extension: false,
    onheadseq
  });

  const prefix = this._db.get(this._prefix, opts, onnode);

  function onnode(err, node) {
    if (err) return cb(err);
    if (node && !self._checkpoint) self._stack.push({
      i: prefix._length,
      seq: node.seq,
      node
    });
    self._start = prefix._length;
    if (self._recursive) self._end = Infinity;else self._end = prefix._length + 32;
    if (self._extensionState) self._extensionState.checkpoint = true;
    if (self._checkpoint) self._openCheckpoint(cb);else cb(null);
  }

  function onheadseq(seq) {
    const ext = self._extensionState;
    if (ext && !ext.head) ext.head = seq;
  }
};

Iterator.prototype._sendExt = function () {
  if (this._extensionState.missing > 0 || !this._extensionState.head) return;
  this._extensionState.missing = BATCH_SIZE;

  this._extension.iterator(this._extensionState.head, this._prefix, this._flags, this._extensionState.checkpoint ? this.checkpoint() : null);
};

Iterator.prototype._openCheckpoint = function (cb) {
  var ptr = 0;
  this._callback = cb;

  while (ptr < this._checkpoint.length) {
    const i = varint.decode(this._checkpoint, ptr);
    ptr += varint.decode.bytes;
    const seq = varint.decode(this._checkpoint, ptr);
    ptr += varint.decode.bytes;

    this._push(i, seq);
  }

  if (!this._pending) {
    this._callback = null;
    cb(null);
  }
};

Iterator.prototype.checkpoint = function () {
  const buf = Buffer.alloc(this._stack.length * 8 * 2);
  var ptr = 0;

  for (var i = 0; i < this._stack.length; i++) {
    const s = this._stack[i];
    varint.encode(s.i, buf, ptr);
    ptr += varint.encode.bytes;
    varint.encode(s.seq, buf, ptr);
    ptr += varint.encode.bytes;
  }

  return buf.slice(0, ptr);
};

Iterator.prototype._next = function (cb) {
  var j;

  while (this._stack.length) {
    const top = this._stack.pop();

    const len = Math.min(top.node.length, this._end);
    const i = top.i++;
    if (i >= len) return cb(null, top.node.final());
    const bucket = top.node.trie[i] || [];
    const order = this._random ? randomOrder() : this._order;

    for (j = 0; j < order.length; j++) {
      var val = order[j];

      if (val !== 4 || !this._gt || i !== this._start) {
        const len = this._stack.length;
        if (top.node.path(i) === val) this._stack.push(top);

        for (; val < bucket.length; val += 5) {
          const seq = bucket[val];
          if (seq) this._push(i + 1, seq);
        }

        if (this._stack.length - len > 1) {
          this._needsSort.push(len, this._stack.length);
        }
      }
    }

    if (!this._pending) continue;
    this._callback = cb;
    return;
  }

  cb(null, null);
};

Iterator.prototype._push = function (i, seq) {
  const self = this;
  const top = {
    i,
    seq,
    node: null
  };
  this._pending++;

  this._stack.push(top);

  if (this._onseq) this._onseq(seq);
  if (this._extensionState && this._extensionState.missing > 0) this._extensionState.missing--;

  this._db.getBySeq(seq, this._options, onnode);

  function onnode(err, node) {
    if (node) top.node = node;else if (err) self._error = err;
    if (! --self._pending) self._continue();
  }
};

Iterator.prototype._sort = function () {
  // only ran when there are potential collisions to make sure
  // the iterator sorts consistently
  while (this._needsSort.length) {
    const end = this._needsSort.pop();

    const start = this._needsSort.pop();

    sort(this._stack, start, end);
  }
};

Iterator.prototype._continue = function () {
  const callback = this._callback;
  const err = this._error;
  this._callback = this._error = null;
  if (err) return callback(err);
  if (this._needsSort.length) this._sort();
  if (!this.opened) return callback(null);

  this._next(callback);
};

function sort(list, from, to) {
  // only ran on short lists so the simple o(n^2) algo is fine
  for (var i = from + 1; i < to; i++) {
    for (var j = i; j > from; j--) {
      const a = list[j];
      const b = list[j - 1];
      if (a.node.key <= b.node.key) break;
      list[j] = b;
      list[j - 1] = a;
    }
  }
}

function randomOrder() {
  const order = [0, 1, 2, 3, 4];

  for (let i = 0; i < order.length - 1; i++) {
    const n = i + Math.floor(Math.random() * (order.length - i));
    const tmp = order[i];
    order[i] = order[n];
    order[n] = tmp;
  }

  return order;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./extension":269,"./node":274,"buffer":97,"inherits":279,"nanoiterator":323,"varint":582}],273:[function(require,module,exports){
(function (Buffer){(function (){
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */

/* eslint-disable indent */

/* eslint-disable no-redeclare */

/* eslint-disable camelcase */
// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings');

var varint = encodings.varint;
var skip = encodings.skip;
var Header = exports.Header = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Node = exports.Node = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Extension = exports.Extension = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
defineHeader();
defineNode();
defineExtension();

function defineHeader() {
  Header.encodingLength = encodingLength;
  Header.encode = encode;
  Header.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.type)) throw new Error("type is required");
    var len = encodings.string.encodingLength(obj.type);
    length += 1 + len;

    if (defined(obj.metadata)) {
      var len = encodings.bytes.encodingLength(obj.metadata);
      length += 1 + len;
    }

    if (defined(obj.subtype)) {
      var len = encodings.string.encodingLength(obj.subtype);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.type)) throw new Error("type is required");
    buf[offset++] = 10;
    encodings.string.encode(obj.type, buf, offset);
    offset += encodings.string.encode.bytes;

    if (defined(obj.metadata)) {
      buf[offset++] = 18;
      encodings.bytes.encode(obj.metadata, buf, offset);
      offset += encodings.bytes.encode.bytes;
    }

    if (defined(obj.subtype)) {
      buf[offset++] = 26;
      encodings.string.encode(obj.subtype, buf, offset);
      offset += encodings.string.encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      type: "",
      metadata: null,
      subtype: ""
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.type = encodings.string.decode(buf, offset);
          offset += encodings.string.decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.metadata = encodings.bytes.decode(buf, offset);
          offset += encodings.bytes.decode.bytes;
          break;

        case 3:
          obj.subtype = encodings.string.decode(buf, offset);
          offset += encodings.string.decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineNode() {
  Node.encodingLength = encodingLength;
  Node.encode = encode;
  Node.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.key)) throw new Error("key is required");
    var len = encodings.string.encodingLength(obj.key);
    length += 1 + len;

    if (defined(obj.valueBuffer)) {
      var len = encodings.bytes.encodingLength(obj.valueBuffer);
      length += 1 + len;
    }

    if (defined(obj.trieBuffer)) {
      var len = encodings.bytes.encodingLength(obj.trieBuffer);
      length += 1 + len;
    }

    if (defined(obj.seq)) {
      var len = encodings.varint.encodingLength(obj.seq);
      length += 1 + len;
    }

    if (defined(obj.flags)) {
      var len = encodings.varint.encodingLength(obj.flags);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.key)) throw new Error("key is required");
    buf[offset++] = 10;
    encodings.string.encode(obj.key, buf, offset);
    offset += encodings.string.encode.bytes;

    if (defined(obj.valueBuffer)) {
      buf[offset++] = 18;
      encodings.bytes.encode(obj.valueBuffer, buf, offset);
      offset += encodings.bytes.encode.bytes;
    }

    if (defined(obj.trieBuffer)) {
      buf[offset++] = 26;
      encodings.bytes.encode(obj.trieBuffer, buf, offset);
      offset += encodings.bytes.encode.bytes;
    }

    if (defined(obj.seq)) {
      buf[offset++] = 32;
      encodings.varint.encode(obj.seq, buf, offset);
      offset += encodings.varint.encode.bytes;
    }

    if (defined(obj.flags)) {
      buf[offset++] = 40;
      encodings.varint.encode(obj.flags, buf, offset);
      offset += encodings.varint.encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      key: "",
      valueBuffer: null,
      trieBuffer: null,
      seq: 0,
      flags: 0
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.key = encodings.string.decode(buf, offset);
          offset += encodings.string.decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.valueBuffer = encodings.bytes.decode(buf, offset);
          offset += encodings.bytes.decode.bytes;
          break;

        case 3:
          obj.trieBuffer = encodings.bytes.decode(buf, offset);
          offset += encodings.bytes.decode.bytes;
          break;

        case 4:
          obj.seq = encodings.varint.decode(buf, offset);
          offset += encodings.varint.decode.bytes;
          break;

        case 5:
          obj.flags = encodings.varint.decode(buf, offset);
          offset += encodings.varint.decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineExtension() {
  var Get = Extension.Get = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  var Iterator = Extension.Iterator = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  var Cache = Extension.Cache = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  defineGet();
  defineIterator();
  defineCache();

  function defineGet() {
    Get.encodingLength = encodingLength;
    Get.encode = encode;
    Get.decode = decode;

    function encodingLength(obj) {
      var length = 0;

      if (defined(obj.head)) {
        var len = encodings.varint.encodingLength(obj.head);
        length += 1 + len;
      }

      if (defined(obj.key)) {
        var len = encodings.string.encodingLength(obj.key);
        length += 1 + len;
      }

      return length;
    }

    function encode(obj, buf, offset) {
      if (!offset) offset = 0;
      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;

      if (defined(obj.head)) {
        buf[offset++] = 8;
        encodings.varint.encode(obj.head, buf, offset);
        offset += encodings.varint.encode.bytes;
      }

      if (defined(obj.key)) {
        buf[offset++] = 18;
        encodings.string.encode(obj.key, buf, offset);
        offset += encodings.string.encode.bytes;
      }

      encode.bytes = offset - oldOffset;
      return buf;
    }

    function decode(buf, offset, end) {
      if (!offset) offset = 0;
      if (!end) end = buf.length;
      if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        head: 0,
        key: ""
      };

      while (true) {
        if (end <= offset) {
          decode.bytes = offset - oldOffset;
          return obj;
        }

        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;

        switch (tag) {
          case 1:
            obj.head = encodings.varint.decode(buf, offset);
            offset += encodings.varint.decode.bytes;
            break;

          case 2:
            obj.key = encodings.string.decode(buf, offset);
            offset += encodings.string.decode.bytes;
            break;

          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }

  function defineIterator() {
    Iterator.encodingLength = encodingLength;
    Iterator.encode = encode;
    Iterator.decode = decode;

    function encodingLength(obj) {
      var length = 0;

      if (defined(obj.head)) {
        var len = encodings.varint.encodingLength(obj.head);
        length += 1 + len;
      }

      if (defined(obj.key)) {
        var len = encodings.string.encodingLength(obj.key);
        length += 1 + len;
      }

      if (defined(obj.flags)) {
        var len = encodings.varint.encodingLength(obj.flags);
        length += 1 + len;
      }

      if (defined(obj.checkpoint)) {
        var len = encodings.bytes.encodingLength(obj.checkpoint);
        length += 1 + len;
      }

      return length;
    }

    function encode(obj, buf, offset) {
      if (!offset) offset = 0;
      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;

      if (defined(obj.head)) {
        buf[offset++] = 8;
        encodings.varint.encode(obj.head, buf, offset);
        offset += encodings.varint.encode.bytes;
      }

      if (defined(obj.key)) {
        buf[offset++] = 18;
        encodings.string.encode(obj.key, buf, offset);
        offset += encodings.string.encode.bytes;
      }

      if (defined(obj.flags)) {
        buf[offset++] = 24;
        encodings.varint.encode(obj.flags, buf, offset);
        offset += encodings.varint.encode.bytes;
      }

      if (defined(obj.checkpoint)) {
        buf[offset++] = 34;
        encodings.bytes.encode(obj.checkpoint, buf, offset);
        offset += encodings.bytes.encode.bytes;
      }

      encode.bytes = offset - oldOffset;
      return buf;
    }

    function decode(buf, offset, end) {
      if (!offset) offset = 0;
      if (!end) end = buf.length;
      if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        head: 0,
        key: "",
        flags: 0,
        checkpoint: null
      };

      while (true) {
        if (end <= offset) {
          decode.bytes = offset - oldOffset;
          return obj;
        }

        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;

        switch (tag) {
          case 1:
            obj.head = encodings.varint.decode(buf, offset);
            offset += encodings.varint.decode.bytes;
            break;

          case 2:
            obj.key = encodings.string.decode(buf, offset);
            offset += encodings.string.decode.bytes;
            break;

          case 3:
            obj.flags = encodings.varint.decode(buf, offset);
            offset += encodings.varint.decode.bytes;
            break;

          case 4:
            obj.checkpoint = encodings.bytes.decode(buf, offset);
            offset += encodings.bytes.decode.bytes;
            break;

          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }

  function defineCache() {
    Cache.encodingLength = encodingLength;
    Cache.encode = encode;
    Cache.decode = decode;

    function encodingLength(obj) {
      var length = 0;
      if (!defined(obj.start)) throw new Error("start is required");
      var len = encodings.varint.encodingLength(obj.start);
      length += 1 + len;
      if (!defined(obj.end)) throw new Error("end is required");
      var len = encodings.varint.encodingLength(obj.end);
      length += 1 + len;

      if (defined(obj.blocks)) {
        var packedLen = 0;

        for (var i = 0; i < obj.blocks.length; i++) {
          if (!defined(obj.blocks[i])) continue;
          var len = encodings.varint.encodingLength(obj.blocks[i]);
          packedLen += len;
        }

        if (packedLen) {
          length += 1 + packedLen + varint.encodingLength(packedLen);
        }
      }

      return length;
    }

    function encode(obj, buf, offset) {
      if (!offset) offset = 0;
      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (!defined(obj.start)) throw new Error("start is required");
      buf[offset++] = 8;
      encodings.varint.encode(obj.start, buf, offset);
      offset += encodings.varint.encode.bytes;
      if (!defined(obj.end)) throw new Error("end is required");
      buf[offset++] = 16;
      encodings.varint.encode(obj.end, buf, offset);
      offset += encodings.varint.encode.bytes;

      if (defined(obj.blocks)) {
        var packedLen = 0;

        for (var i = 0; i < obj.blocks.length; i++) {
          if (!defined(obj.blocks[i])) continue;
          packedLen += encodings.varint.encodingLength(obj.blocks[i]);
        }

        if (packedLen) {
          buf[offset++] = 26;
          varint.encode(packedLen, buf, offset);
          offset += varint.encode.bytes;
        }

        for (var i = 0; i < obj.blocks.length; i++) {
          if (!defined(obj.blocks[i])) continue;
          encodings.varint.encode(obj.blocks[i], buf, offset);
          offset += encodings.varint.encode.bytes;
        }
      }

      encode.bytes = offset - oldOffset;
      return buf;
    }

    function decode(buf, offset, end) {
      if (!offset) offset = 0;
      if (!end) end = buf.length;
      if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        start: 0,
        end: 0,
        blocks: []
      };
      var found0 = false;
      var found1 = false;

      while (true) {
        if (end <= offset) {
          if (!found0 || !found1) throw new Error("Decoded message is not valid");
          decode.bytes = offset - oldOffset;
          return obj;
        }

        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;

        switch (tag) {
          case 1:
            obj.start = encodings.varint.decode(buf, offset);
            offset += encodings.varint.decode.bytes;
            found0 = true;
            break;

          case 2:
            obj.end = encodings.varint.decode(buf, offset);
            offset += encodings.varint.decode.bytes;
            found1 = true;
            break;

          case 3:
            var packedEnd = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            packedEnd += offset;

            while (offset < packedEnd) {
              obj.blocks.push(encodings.varint.decode(buf, offset));
              offset += encodings.varint.decode.bytes;
            }

            break;

          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }

  Extension.encodingLength = encodingLength;
  Extension.encode = encode;
  Extension.decode = decode;

  function encodingLength(obj) {
    var length = 0;

    if (defined(obj.cache)) {
      var len = Cache.encodingLength(obj.cache);
      length += varint.encodingLength(len);
      length += 1 + len;
    }

    if (defined(obj.iterator)) {
      var len = Iterator.encodingLength(obj.iterator);
      length += varint.encodingLength(len);
      length += 1 + len;
    }

    if (defined(obj.get)) {
      var len = Get.encodingLength(obj.get);
      length += varint.encodingLength(len);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;

    if (defined(obj.cache)) {
      buf[offset++] = 10;
      varint.encode(Cache.encodingLength(obj.cache), buf, offset);
      offset += varint.encode.bytes;
      Cache.encode(obj.cache, buf, offset);
      offset += Cache.encode.bytes;
    }

    if (defined(obj.iterator)) {
      buf[offset++] = 18;
      varint.encode(Iterator.encodingLength(obj.iterator), buf, offset);
      offset += varint.encode.bytes;
      Iterator.encode(obj.iterator, buf, offset);
      offset += Iterator.encode.bytes;
    }

    if (defined(obj.get)) {
      buf[offset++] = 26;
      varint.encode(Get.encodingLength(obj.get), buf, offset);
      offset += varint.encode.bytes;
      Get.encode(obj.get, buf, offset);
      offset += Get.encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      cache: null,
      iterator: null,
      get: null
    };

    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.cache = Cache.decode(buf, offset, offset + len);
          offset += Cache.decode.bytes;
          break;

        case 2:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.iterator = Iterator.decode(buf, offset, offset + len);
          offset += Iterator.decode.bytes;
          break;

        case 3:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.get = Get.decode(buf, offset, offset + len);
          offset += Get.decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"protocol-buffers-encodings":382}],274:[function(require,module,exports){
(function (Buffer){(function (){
const siphash24 = require('siphash24-universal');

const inspect = require('inspect-custom-symbol');

const messages = require("./messages");

const trie = require("./trie");

const KEY = Buffer.alloc(16);
module.exports = Node;
const Flags = {
  HIDDEN: 1
};

function Node(data, seq, enc, userHash) {
  this.seq = seq || 0;
  this.key = normalizeKey(data.key);
  this.value = data.value !== undefined ? data.value : null;
  this.keySplit = split(this.key);
  this.hash = userHash ? userHash(this.key) : hash(this.keySplit);
  this.trie = data.trieBuffer ? trie.decode(data.trieBuffer) : data.trie || [];
  this.trieBuffer = null;
  this.valueBuffer = data.valueBuffer || null;
  this.length = this.hash.length * 4 + 1 + 1;
  this.valueEncoding = enc;
  this._finalized = false;
  this._flags = data.flags || 0;
  this.flags = this._flags;
}

Node.Flags = Flags;

Node.prototype[inspect] = function (depth, opts) {
  return (opts && opts.stylize || defaultStylize)({
    seq: this.seq,
    key: this.key,
    value: this.value
  }, 'object');
};

Object.defineProperty(Node.prototype, 'hidden', {
  enumerable: true,
  get: function () {
    return !!(this._flags & Flags.HIDDEN);
  }
});

Node.prototype.path = function (i) {
  if (!i) return this.hidden ? 1 : 0;
  i--;
  const hash = this.hash;
  const j = i >> 2;
  if (j >= hash.length) return 4;
  return hash[j] >> 2 * (i & 3) & 3;
};

Node.prototype.compare = function (other) {
  const min = Math.min(this.length, other.length);

  for (var i = 0; i < min; i++) {
    const diff = this.path(i) - other.path(i);
    if (diff !== 0) return diff;
  }

  return 0;
};

Node.prototype.final = function () {
  if (this._finalized) return this;
  if (this.valueBuffer === null) this.value = null;else this.value = this.valueEncoding ? this.valueEncoding.decode(this.valueBuffer) : this.valueBuffer; // The flags are shifted in order to both hide the internal flags and support user-defined flags.

  this.flags = this._flags >> 8;
  this._finalized = true;
  return this;
};

Node.prototype.preencode = function () {
  if (!this.trieBuffer) this.trieBuffer = trie.encode(this.trie);
  if (!this.valueBuffer) this.valueBuffer = this.value !== null && this.valueEncoding ? this.valueEncoding.encode(this.value) : this.value;
};

Node.prototype.encode = function () {
  this.preencode();
  return messages.Node.encode(this);
};

Node.prototype.collides = function (node, i) {
  if (!i) return false;
  if (i === this.length - 1) return this.key !== node.key;
  const j = Math.floor((i - 1) / 32);
  return this.keySplit[j] !== node.keySplit[j];
};

Node.decode = function (buf, seq, enc, hash) {
  return new Node(messages.Node.decode(buf), seq, enc, hash);
};

Node.terminator = function (i) {
  return i > 0 && (i & 31) === 0;
};

Node.normalizeKey = normalizeKey;

function hash(keys) {
  const buf = Buffer.allocUnsafe(8 * keys.length);

  for (var i = 0; i < keys.length; i++) {
    const key = Buffer.from(keys[i]);
    const j = i * 8;
    siphash24(buf.slice(j, j + 8), key, KEY);
  }

  return buf;
}

function split(key) {
  const list = key.split('/');
  if (list[0] === '') list.shift();
  if (list[list.length - 1] === '') list.pop();
  return list;
}

function normalizeKey(key) {
  if (!key.length) return '';
  return key[0] === '/' ? key.slice(1) : key;
}

function defaultStylize(val) {
  return val;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./messages":273,"./trie":276,"buffer":97,"inspect-custom-symbol":280,"siphash24-universal":506}],275:[function(require,module,exports){
(function (process){(function (){
const Node = require("./node");

module.exports = Put;

function putDefaultOptions(opts) {
  return Object.assign({}, {
    condition: null,
    closest: false,
    hidden: false,
    valueBuffer: null,
    flags: 0
  }, opts);
}

function Put(db, key, value, opts, cb) {
  let {
    hidden,
    condition,
    valueBuffer,
    flags,
    batch,
    del,
    closest
  } = putDefaultOptions(opts);
  this._db = db; // The flags are shifted in order to both hide the internal flags and support user-defined flags.

  flags = flags << 8 | (hidden ? Node.Flags.HIDDEN : 0);
  this._node = new Node({
    key,
    value,
    valueBuffer,
    flags
  }, 0, db.valueEncoding, db.hash);
  this._callback = cb;
  this._release = null;
  this._batch = batch;
  this._closest = closest;
  this._condition = condition;
  this._error = null;
  this._pending = 0;
  this._del = del;
  this._finalized = false;
  this._head = null;
  if (this._batch) this._update(0, this._batch.head());else if (this._del) this._start();else this._lock();
}

Put.prototype._lock = function () {
  const self = this;

  this._db._lock(function (release) {
    self._release = release;

    self._start();
  });
};

Put.prototype._start = function () {
  const self = this;

  this._db.head(onhead);

  function onhead(err, head) {
    if (err) return self._finalize(err);

    self._update(0, head);
  }
};

Put.prototype._finalize = function (err) {
  const self = this;
  this._finalized = true;

  if (this._pending) {
    if (err) this._error = err;
    return;
  }

  if (this._error) err = this._error;
  if (err) return done(err);
  const closest = this._head;
  if (this._head && this._head.key !== this._node.key) this._head = null;

  if (this._condition) {
    const conditionNode = this._closest ? closest && closest.final() : this._head && this._head.final();

    this._condition(conditionNode, this._node, oncondition);
  } else insert();

  function oncondition(err, proceed) {
    if (err) return done(err);
    if (!proceed) return done(null);
    return insert();
  }

  function insert() {
    if (self._batch) {
      self._batch.append(self._node);

      return done(null, self._node);
    }

    self._node.seq = self._db.feed.length;

    self._db.feed.append(self._node.encode(), done);
  }

  function done(err) {
    const node = err ? null : self._node;
    if (self._release) self._release(self._callback, err, node);else self._callback(err, node);
  }
};

Put.prototype._push = function (i, val, seq) {
  if (seq !== this._del) push(this._node.trie, i, val, seq);
};

Put.prototype._pushCollidable = function (i, val, seq) {
  if (seq === this._del) return;
  const self = this;
  this._pending++;

  this._get(seq, function (err, node) {
    if (err) this._error = err;else if (node.collides(self._node, i)) push(self._node.trie, i, val, seq);
    if (! --self._pending && self._finalized) self._finalize(null);
  });
};

Put.prototype._update = function (i, head) {
  if (!head) return this._finalize(null);
  const node = this._node;

  for (; i < node.length; i++) {
    // check for collision at the end (4) or if it's a prefix terminator
    const checkCollision = Node.terminator(i);
    const val = node.path(i);
    const bucket = head.trie[i] || [];
    const headVal = head.path(i);

    for (var j = 0; j < bucket.length; j++) {
      // if same hash prefix, if no collision check is needed just continue
      if (j === val && !checkCollision) continue;
      const seq = bucket[j];
      if (!seq) continue; // skip no-ops

      if (!checkCollision) {
        // TODO: can prob optimise this with a || j !== val
        this._push(i, j, seq);
      } else {
        this._pushCollidable(i, j, seq);
      }
    } // we copied the head bucket, if this is still the closest node, continue
    // if no collision is possible


    if (headVal === val && (!checkCollision || !node.collides(head, i))) continue;

    this._push(i, headVal, head.seq);

    if (checkCollision) return this._updateHeadCollidable(i, bucket, val);
    const seq = bucket[val];
    if (!seq) break;
    return this._updateHead(i, seq);
  }

  this._head = head;

  this._finalize(null);
};

Put.prototype._get = function (seq, cb) {
  const node = this._batch && this._batch.get(seq);

  if (node) return process.nextTick(cb, null, node);

  this._db.getBySeq(seq, cb);
};

Put.prototype._updateHeadCollidable = function (i, bucket, val) {
  const self = this;
  var missing = 1;
  var error = null;
  var node = null;

  for (var j = val; j < bucket.length; j += 5) {
    const seq = bucket[j];
    if (!seq) break;
    missing++;

    this._get(seq, onnode);
  }

  onnode(null, null);

  function onnode(err, n) {
    if (err) error = err;else if (n && !n.collides(self._node, i)) node = n;
    if (--missing) return;
    if (!node) return self._finalize(error);

    self._update(i + 1, node);
  }
};

Put.prototype._updateHead = function (i, seq) {
  const self = this;

  this._get(seq, onnode);

  function onnode(err, node) {
    if (err) return self._finalize(err);

    self._update(i + 1, node);
  }
};

function push(trie, i, val, seq) {
  while (val >= 5) val -= 5;

  const bucket = trie[i] || (trie[i] = []);

  while (bucket.length > val && bucket[val]) val += 5;

  if (bucket.indexOf(seq) === -1) bucket[val] = seq;
}

}).call(this)}).call(this,require('_process'))
},{"./node":274,"_process":380}],276:[function(require,module,exports){
(function (Buffer){(function (){
const varint = require('varint');

exports.encode = function (trie) {
  const buf = Buffer.alloc(65536);
  var i, j;
  var offset = 0;
  varint.encode(trie.length, buf, offset);
  offset += varint.encode.bytes;

  for (i = 0; i < trie.length; i++) {
    const bucket = trie[i];
    if (!bucket) continue;
    var bit = 1;
    var bitfield = 0;
    varint.encode(i, buf, offset);
    offset += varint.encode.bytes;

    for (j = 0; j < bucket.length; j++) {
      const seq = bucket[j];
      if (seq) bitfield |= bit;
      bit *= 2;
    }

    varint.encode(bitfield, buf, offset);
    offset += varint.encode.bytes;

    for (j = 0; j < bucket.length; j++) {
      const seq = bucket[j];

      if (seq) {
        varint.encode(seq, buf, offset);
        offset += varint.encode.bytes;
      }
    }
  }

  return buf.slice(0, offset);
};

exports.decode = function (buf) {
  var offset = 0;
  const len = varint.decode(buf, offset);
  offset += varint.decode.bytes;
  const trie = new Array(len);

  while (offset < buf.length) {
    const i = varint.decode(buf, offset);
    offset += varint.decode.bytes;
    var bitfield = varint.decode(buf, offset);
    var pos = 0;
    const bucket = trie[i] = new Array(32 - Math.clz32(bitfield));
    offset += varint.decode.bytes;

    while (bitfield) {
      const bit = bitfield & 1;

      if (bit) {
        bucket[pos] = varint.decode(buf, offset);
        offset += varint.decode.bytes;
      }

      bitfield = (bitfield - bit) / 2;
      pos++;
    }
  }

  return trie;
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"varint":582}],277:[function(require,module,exports){
const inherits = require('inherits');

const events = require('events');

module.exports = Watch;

function Watch(db, prefix, onchange) {
  events.EventEmitter.call(this);
  this._db = db;
  this._prefix = prefix;
  this._destroyed = false;
  this._closest = 0;
  this._updated = false;
  this._kicking = false;
  this._index = 0;
  if (onchange) this.on('change', onchange);

  this._db._addWatch(this);

  this.update();
}

inherits(Watch, events.EventEmitter);

Watch.prototype.destroy = function () {
  this._db._removeWatch(this);

  this._destroyed = true;
};

Watch.prototype.update = function () {
  if (this._destroyed) return;
  if (!this._kicking) this._kick();else this._updated = true;
};

Watch.prototype._done = function (closest) {
  this._kicking = false;

  if (closest > this._closest) {
    this._closest = closest;
    this._updated = false;
    this.emit('change');
    return;
  }

  if (this._updated) {
    this._updated = false;

    this._kick();
  }
};

Watch.prototype._kick = function () {
  const self = this;
  this._kicking = true;

  this._db.get(this._prefix, {
    prefix: true
  }, done);

  function done(_, node) {
    self._done(node ? node.seq : 0);
  }
};

},{"events":172,"inherits":279}],278:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],279:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

},{}],280:[function(require,module,exports){
module.exports = Symbol.for('nodejs.util.inspect.custom');

},{}],281:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }

  return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }

  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":111}],282:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],283:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;

var getGeneratorFunc = function () {
  // eslint-disable-line consistent-return
  if (!hasToStringTag) {
    return false;
  }

  try {
    return Function('return function*() {}')();
  } catch (e) {}
};

var generatorFunc = getGeneratorFunc();
var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

module.exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }

  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }

  if (!hasToStringTag) {
    var str = toStr.call(fn);
    return str === '[object GeneratorFunction]';
  }

  return getProto && getProto(fn) === GeneratorFunction;
};

},{}],284:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = isOptions;

function isOptions(opts) {
  return typeof opts === 'object' && opts && !Buffer.isBuffer(opts);
}

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":282}],285:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');

var availableTypedArrays = require('available-typed-arrays');

var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var hasSymbols = require('has-symbols')();

var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }

  return -1;
};

var $slice = callBound('String.prototype.slice');
var toStrTags = {};

var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');

var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    var arr = new global[typedArray]();

    if (!(Symbol.toStringTag in arr)) {
      throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
    }

    var proto = getPrototypeOf(arr);
    var descriptor = gOPD(proto, Symbol.toStringTag);

    if (!descriptor) {
      var superProto = getPrototypeOf(proto);
      descriptor = gOPD(superProto, Symbol.toStringTag);
    }

    toStrTags[typedArray] = descriptor.get;
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
        /**/
      }
    }
  });
  return anyTrue;
};

module.exports = function isTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }

  if (!hasToStringTag) {
    var tag = $slice($toString(value), 8, -1);
    return $indexOf(typedArrays, tag) > -1;
  }

  if (!gOPD) {
    return false;
  }

  return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":35,"call-bind/callBound":111,"es-abstract/helpers/getOwnPropertyDescriptor":170,"foreach":181,"has-symbols":186}],286:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],287:[function(require,module,exports){
(function (global){(function (){
// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js
var ws = null;

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket;
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket;
} else if (typeof global !== 'undefined') {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket;
}

module.exports = ws;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],288:[function(require,module,exports){
module.exports = function (work) {
  var pending = null;
  var callback = null;
  var callbacks = null;
  var next = null;
  return function (val, cb) {
    next = val;
    update(cb || noop);
  };

  function update(cb) {
    if (callback) {
      if (!pending) pending = [];
      pending.push(cb);
      return;
    }

    var val = next;
    next = null;
    callback = cb;
    work(val, done);
  }

  function done(err) {
    var cb = callback;
    var cbs = callbacks;
    callbacks = null;
    callback = null;

    if (pending) {
      callbacks = pending;
      pending = null;
      update(noop);
    }

    if (cbs) {
      for (var i = 0; i < cbs.length; i++) cbs[i](err);
    }

    cb(err);
  }
};

function noop(_) {}

},{}],289:[function(require,module,exports){
(function (Buffer){(function (){
var varint = require('varint');

var stream = require('readable-stream');

var inherits = require('inherits');

var Decoder = function (opts) {
  if (!(this instanceof Decoder)) return new Decoder(opts);
  stream.Transform.call(this);
  this._destroyed = false;
  this._missing = 0;
  this._message = null;
  this._limit = opts && opts.limit || 0;
  this._allowEmpty = !!(opts && opts.allowEmpty);
  this._prefix = Buffer.allocUnsafe(this._limit ? varint.encodingLength(this._limit) : 100);
  this._ptr = 0;

  if (this._allowEmpty) {
    this._readableState.highWaterMark = 16;
    this._readableState.objectMode = true;
  }
};

inherits(Decoder, stream.Transform);

Decoder.prototype._push = function (message) {
  this._ptr = 0;
  this._missing = 0;
  this._message = null;
  this.push(message);
};

Decoder.prototype._parseLength = function (data, offset) {
  for (offset; offset < data.length; offset++) {
    if (this._ptr >= this._prefix.length) return this._prefixError(data);
    this._prefix[this._ptr++] = data[offset];

    if (!(data[offset] & 0x80)) {
      this._missing = varint.decode(this._prefix);
      if (this._limit && this._missing > this._limit) return this._prefixError(data);
      if (!this._missing && this._allowEmpty) this._push(Buffer.alloc(0));
      this._ptr = 0;
      return offset + 1;
    }
  }

  return data.length;
};

Decoder.prototype._prefixError = function (data) {
  this.destroy(new Error('Message is larger than max length'));
  return data.length;
};

Decoder.prototype._parseMessage = function (data, offset) {
  var free = data.length - offset;
  var missing = this._missing;

  if (!this._message) {
    if (missing <= free) {
      // fast track - no copy
      this._push(data.slice(offset, offset + missing));

      return offset + missing;
    }

    this._message = Buffer.allocUnsafe(missing);
  } // TODO: add opt-in "partial mode" to completely avoid copys


  data.copy(this._message, this._ptr, offset, offset + missing);

  if (missing <= free) {
    this._push(this._message);

    return offset + missing;
  }

  this._missing -= free;
  this._ptr += free;
  return data.length;
};

Decoder.prototype._transform = function (data, enc, cb) {
  var offset = 0;

  while (!this._destroyed && offset < data.length) {
    if (this._missing) offset = this._parseMessage(data, offset);else offset = this._parseLength(data, offset);
  }

  cb();
};

Decoder.prototype.destroy = function (err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit('error', err);
  this.emit('close');
};

module.exports = Decoder;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"inherits":279,"readable-stream":306,"varint":582}],290:[function(require,module,exports){
(function (Buffer){(function (){
var varint = require('varint');

var stream = require('readable-stream');

var inherits = require('inherits');

var pool = Buffer.allocUnsafe(10 * 1024);
var used = 0;

var Encoder = function () {
  if (!(this instanceof Encoder)) return new Encoder();
  stream.Transform.call(this);
  this._destroyed = false;
};

inherits(Encoder, stream.Transform);

Encoder.prototype._transform = function (data, enc, cb) {
  if (this._destroyed) return cb();
  varint.encode(data.length, pool, used);
  used += varint.encode.bytes;
  this.push(pool.slice(used - varint.encode.bytes, used));
  this.push(data);

  if (pool.length - used < 100) {
    pool = Buffer.allocUnsafe(10 * 1024);
    used = 0;
  }

  cb();
};

Encoder.prototype.destroy = function (err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit('error', err);
  this.emit('close');
};

module.exports = Encoder;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"inherits":279,"readable-stream":306,"varint":582}],291:[function(require,module,exports){
exports.encode = require("./encode");
exports.decode = require("./decode");

},{"./decode":289,"./encode":290}],292:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],293:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":295,"./_stream_writable":297,"_process":380,"dup":77,"inherits":279}],294:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":296,"dup":78,"inherits":279}],295:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":292,"./_stream_duplex":293,"./internal/streams/async_iterator":298,"./internal/streams/buffer_list":299,"./internal/streams/destroy":300,"./internal/streams/from":302,"./internal/streams/state":304,"./internal/streams/stream":305,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],296:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":292,"./_stream_duplex":293,"dup":80,"inherits":279}],297:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":292,"./_stream_duplex":293,"./internal/streams/destroy":300,"./internal/streams/state":304,"./internal/streams/stream":305,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],298:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":301,"_process":380,"dup":82}],299:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],300:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],301:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":292,"dup":85}],302:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],303:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":292,"./end-of-stream":301,"dup":87}],304:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":292,"dup":88}],305:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],306:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":293,"./lib/_stream_passthrough.js":294,"./lib/_stream_readable.js":295,"./lib/_stream_transform.js":296,"./lib/_stream_writable.js":297,"./lib/internal/streams/end-of-stream.js":301,"./lib/internal/streams/pipeline.js":303,"dup":90}],307:[function(require,module,exports){
'use strict';

var inherits = require('inherits');

var HashBase = require('hash-base');

var Buffer = require('safe-buffer').Buffer;

var ARRAY16 = new Array(16);

function MD5() {
  HashBase.call(this, 64); // state

  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
}

inherits(MD5, HashBase);

MD5.prototype._update = function () {
  var M = ARRAY16;

  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  var buffer = Buffer.allocUnsafe(16);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  return buffer;
};

function rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function fnF(a, b, c, d, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}

function fnG(a, b, c, d, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}

function fnH(a, b, c, d, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}

function fnI(a, b, c, d, m, k, s) {
  return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}

module.exports = MD5;

},{"hash-base":189,"inherits":279,"safe-buffer":446}],308:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = Pager;

function Pager(pageSize, opts) {
  if (!(this instanceof Pager)) return new Pager(pageSize, opts);
  this.length = 0;
  this.updates = [];
  this.path = new Uint16Array(4);
  this.pages = new Array(32768);
  this.maxPages = this.pages.length;
  this.level = 0;
  this.pageSize = pageSize || 1024;
  this.deduplicate = opts ? opts.deduplicate : null;
  this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
}

Pager.prototype.updated = function (page) {
  while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
    page.deduplicate++;

    if (page.deduplicate === this.deduplicate.length) {
      page.deduplicate = 0;
      if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
      break;
    }
  }

  if (page.updated || !this.updates) return;
  page.updated = true;
  this.updates.push(page);
};

Pager.prototype.lastUpdate = function () {
  if (!this.updates || !this.updates.length) return null;
  var page = this.updates.pop();
  page.updated = false;
  return page;
};

Pager.prototype._array = function (i, noAllocate) {
  if (i >= this.maxPages) {
    if (noAllocate) return;
    grow(this, i);
  }

  factor(i, this.path);
  var arr = this.pages;

  for (var j = this.level; j > 0; j--) {
    var p = this.path[j];
    var next = arr[p];

    if (!next) {
      if (noAllocate) return;
      next = arr[p] = new Array(32768);
    }

    arr = next;
  }

  return arr;
};

Pager.prototype.get = function (i, noAllocate) {
  var arr = this._array(i, noAllocate);

  var first = this.path[0];
  var page = arr && arr[first];

  if (!page && !noAllocate) {
    page = arr[first] = new Page(i, alloc(this.pageSize));
    if (i >= this.length) this.length = i + 1;
  }

  if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
    page.buffer = copy(page.buffer);
    page.deduplicate = 0;
  }

  return page;
};

Pager.prototype.set = function (i, buf) {
  var arr = this._array(i, false);

  var first = this.path[0];
  if (i >= this.length) this.length = i + 1;

  if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
    arr[first] = undefined;
    return;
  }

  if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
    buf = this.deduplicate;
  }

  var page = arr[first];
  var b = truncate(buf, this.pageSize);
  if (page) page.buffer = b;else arr[first] = new Page(i, b);
};

Pager.prototype.toBuffer = function () {
  var list = new Array(this.length);
  var empty = alloc(this.pageSize);
  var ptr = 0;

  while (ptr < list.length) {
    var arr = this._array(ptr, true);

    for (var i = 0; i < 32768 && ptr < list.length; i++) {
      list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
    }
  }

  return Buffer.concat(list);
};

function grow(pager, index) {
  while (pager.maxPages < index) {
    var old = pager.pages;
    pager.pages = new Array(32768);
    pager.pages[0] = old;
    pager.level++;
    pager.maxPages *= 32768;
  }
}

function truncate(buf, len) {
  if (buf.length === len) return buf;
  if (buf.length > len) return buf.slice(0, len);
  var cpy = alloc(len);
  buf.copy(cpy);
  return cpy;
}

function alloc(size) {
  if (Buffer.alloc) return Buffer.alloc(size);
  var buf = new Buffer(size);
  buf.fill(0);
  return buf;
}

function copy(buf) {
  var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
  buf.copy(cpy);
  return cpy;
}

function Page(i, buf) {
  this.offset = i * buf.length;
  this.buffer = buf;
  this.updated = false;
  this.deduplicate = 0;
}

function factor(n, out) {
  n = (n - (out[0] = n & 32767)) / 32768;
  n = (n - (out[1] = n & 32767)) / 32768;
  out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],309:[function(require,module,exports){
(function (Buffer){(function (){
// a more low level interface to the merkle tree stream.
// useful for certain applications the require non-streamy access to the algos.
// versioned by the same semver as the stream interface.
const flat = require('flat-tree');

module.exports = class MerkleGenerator {
  constructor(opts, roots) {
    if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required');
    this.roots = roots || opts.roots || [];
    this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0;

    for (var i = 0; i < this.roots.length; i++) {
      var r = this.roots[i];
      if (r && !r.parent) r.parent = flat.parent(r.index);
    }

    this._leaf = opts.leaf;
    this._parent = opts.parent;
  }

  next(data, nodes) {
    if (!Buffer.isBuffer(data)) data = Buffer.from(data);
    if (!nodes) nodes = [];
    var index = 2 * this.blocks++;
    var leaf = {
      index: index,
      parent: flat.parent(index),
      hash: null,
      size: data.length,
      data: data
    };
    leaf.hash = this._leaf(leaf, this.roots);
    this.roots.push(leaf);
    nodes.push(leaf);

    while (this.roots.length > 1) {
      var left = this.roots[this.roots.length - 2];
      var right = this.roots[this.roots.length - 1];
      if (left.parent !== right.parent) break;
      this.roots.pop();
      this.roots[this.roots.length - 1] = leaf = {
        index: left.parent,
        parent: flat.parent(left.parent),
        hash: this._parent(left, right),
        size: left.size + right.size,
        data: null
      };
      nodes.push(leaf);
    }

    return nodes;
  }

};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"flat-tree":180}],310:[function(require,module,exports){
var bn = require('bn.js');

var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}

module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8); // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.

  do var a = new bn(this.rand.generate(min_bytes)); while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0); // Find d and s, (n - 1) = (2 ^ s) * d;

  var n1 = n.subn(1);

  for (var s = 0; !n1.testn(s); s++) {}

  var d = n.shrn(s);
  var rn1 = n1.toRed(red);
  var prime = true;

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    if (cb) cb(a);
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return false;
      if (x.cmp(rn1) === 0) break;
    }

    if (i === s) return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0); // Find d and s, (n - 1) = (2 ^ s) * d;

  var n1 = n.subn(1);

  for (var s = 0; !n1.testn(s); s++) {}

  var d = n.shrn(s);
  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0) return g;
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0) break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":311,"brorand":47}],311:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"buffer":48,"dup":32}],312:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

},{}],313:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;

    return res;
  }

  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0) msg = '0' + msg;

    for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi) res.push(hi, lo);else res.push(lo);
    }
  }

  return res;
}

utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

utils.zero2 = zero2;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

  return res;
}

utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex') return toHex(arr);else return arr;
};

},{}],314:[function(require,module,exports){
const delay = require('delay');

const eos = require('end-of-stream-promise');

const defer = require('promise-defer');

const randomize = require('randomize-array');

const distance = require('xor-distance');

const PQueue = require('p-queue').default;

const EventEmitter = require('events');

const DEFAULT_SAMPLE_SIZE = 10;
const DEFAULT_PERCENT_FAR = 0.33;
const DEFAULT_LOOKUP_TIMEOUT = 1000;
const DEFAULT_MAX_PEERS = 4;
module.exports = class MMST extends EventEmitter {
  constructor({
    // Own ID, should be a buffer
    // Other peers should see the same ID somehow
    // Might be good to calculate based on IP+port combo
    id,
    // Function to invoke in order to get a list of peers
    // Should return a stream that emits arrays IDs for potential peers
    // Peer IDs should be buffers, same as own ID
    lookup,
    // Function to invoke in order to establish a connection to a peer
    // Should take a peer ID from lookup
    // Should return a promise
    // Resolve to stream on successful connection
    // Reject on failed connection for whatever reason
    connect,
    // The higher the sample size, the more likely it'll connect to "close" peers
    // However, if the sample size is the number of peers, it can have supernodes
    sampleSize = DEFAULT_SAMPLE_SIZE,
    // The higher the percentage the more redundant connections will exist,
    // But the less likely it will be to have partitions
    percentFar = DEFAULT_PERCENT_FAR,
    // If we reach this many peers, start disconnecting new incoming connections
    maxPeers = DEFAULT_MAX_PEERS,
    // How long to lookup peers fore before giving up and using what you have
    lookupTimeout = DEFAULT_LOOKUP_TIMEOUT,
    // How long to wait for `run` to be finished
    queueTimeout = lookupTimeout + 2 * 1000
  }) {
    super();
    this.id = id;
    this._lookup = lookup;
    this._connect = connect;
    this.sampleSize = sampleSize;
    this.percentFar = percentFar;
    this.maxPeers = maxPeers;

    if (lookupTimeout > queueTimeout) {
      throw new Error('queueTimeout must be higher than lookupTimeout');
    }

    this.lookupTimeout = lookupTimeout;
    this.queue = new PQueue({
      concurrency: 1,
      timeout: queueTimeout
    });
    this.connectedPeers = new Set();
    this.hasConnectedFar = false;
    this.destroyed = false;
  }

  shouldHandleIncoming() {
    return this.connectedPeers.size < this.maxPeers;
  } // This should be invoked when there's an incoming connection


  handleIncoming(id, connection) {
    // If we reached our max number of connections disconnect new peers
    if (!this.shouldHandleIncoming()) {
      connection.close();
      return;
    }

    this.addConnection(id, connection);
  } // Used internally


  addConnection(id, connection, reconnect) {
    const stringId = id.toString('hex');
    this.connectedPeers.add(stringId);
    connection.once('close', () => {
      this.connectedPeers.delete(stringId);

      if (reconnect || this.connectedPeers.size === 0) {
        this.queue.add(() => this.run());
      }
    });
  } // Run the algorithm


  async run() {
    if (!this.shouldHandleIncoming()) return; // If `destroyed` return

    if (this.destroyed) return;
    const found = [];

    const stream = this._lookup();

    const gotEnough = defer();
    const finish = Promise.race([eos(stream), delay(this.lookupTimeout), gotEnough.promise]);
    stream.on('data', peers => {
      // Build up array of peers
      found.push(...peers); // Once the array has `sampleSize`, start connecting

      if (found.length >= this.sampleSize) gotEnough.resolve();
    }); // Start looking up peers, with timeout

    await finish;
    if (this.destroyed) return; // Prep the peer sample

    let sample = found.slice(); // If it's more than `sampleSize`, randomize the list and take sampleSize

    if (sample.length > this.sampleSize) {
      sample = randomize(found).slice(0, this.sampleSize);
    } // Sort by XOR distance, closest peers first


    sample.sort((a, b) => distance.gt(distance(this.id, a), distance(this.id, b)));
    let connected = false; // Connect to closest peer that isn't connected

    for (let peer of sample) {
      if (this.destroyed) return;
      const stringId = peer.toString('hex');
      if (this.connectedPeers.has(stringId)) continue;

      try {
        const connection = await this._connect(peer);
        connected = true;
        this.addConnection(peer, connection, true);
        break;
      } catch (e) {// Oh well
      }
    }

    if (!connected) {
      // Let the application know that we were unable to connect to any peer
      this.emit('nopeers');
      return;
    } // If `hasConnectedFar`, return


    if (this.hasConnectedFar) return; // If we're at the max connections we shouldn't try to reach out

    if (this.connectedPeers.size >= this.maxPeers) return; // Generate a random number [0, 1)

    const chanceFar = Math.random(); // If > `percentFar` return

    if (chanceFar > this.percentFar) return; // Order peers to have furthest first

    sample.reverse(); // Find furthest peer that isn't already connected

    for (let peer of sample) {
      if (this.destroyed) return;
      const stringId = peer.toString('hex');
      if (this.connectedPeers.has(stringId)) continue;

      try {
        // Connect to the peer and set `hasConnectedFar` true
        const connection = await this._connect(peer);
        this.addConnection(peer, connection, true);
        this.hasConnectedFar = true; // Listen on connection close and set `hasConnectedFar` false

        connection.once('close', () => {
          this.hasConnectedFar = false;
        });
        break;
      } catch (e) {// Oh well
      }
    }
  }

  async destroy() {
    // Set flag saying that this is destroyed to prevent looping
    this.destroyed = true;
  }

};

},{"delay":133,"end-of-stream-promise":167,"events":172,"p-queue":362,"promise-defer":381,"randomize-array":429,"xor-distance":589}],315:[function(require,module,exports){
(function (process,Buffer){(function (){
const p = require('path').posix;

const {
  EventEmitter
} = require('events');

const hypertrie = require('hypertrie');

const HypercoreProtocol = require('hypercore-protocol');

const hypercoreCrypto = require('hypercore-crypto');

const thunky = require('thunky');

const nanoiterator = require('nanoiterator');

const toStream = require('nanoiterator/to-stream');

const isOptions = require('is-options');

const unixify = require('unixify');

const Nanoresource = require('nanoresource/emitter');

const {
  Mount
} = require("./lib/messages");

const Flags = {
  MOUNT: 1
};
const MOUNT_PREFIX = '/mounts';
const OWNER = Symbol('mountable-hypertrie-owner');

class MountableHypertrie extends Nanoresource {
  constructor(corestore, key, opts = {}) {
    super();
    if (key && typeof key === 'string') key = Buffer.from(key, 'hex');
    this.corestore = corestore;
    this.key = key;
    this.discoveryKey = this.key ? hypercoreCrypto.discoveryKey(this.key) : null;
    this.opts = opts;
    this.sparse = opts.sparse !== false;
    this.subtype = opts.subtype || 'mountable-hypertrie';
    if (opts.valueEncoding) throw new Error('MountableHypertrie does not currently support a valueEncoding option.');
    var feed = this.opts.feed;
    if (!feed) feed = this.corestore.default({
      key,
      ...this.opts
    });

    if (feed[OWNER]) {
      this.trie = feed[OWNER];
    } else {
      this.trie = opts.trie || hypertrie(null, { ...opts,
        feed,
        version: null,
        alwaysUpdate: true,
        alwaysReconnect: true,
        subtype: this.subtype
      });
      this.trie.feed[OWNER] = this.trie;
    }

    if (opts.version) {
      this.trie = this.trie.checkout(opts.version);
    }

    this._unlisteners = [];
    this.feed = this.trie.feed;

    if (this.trie !== opts.trie) {
      const errorListener = err => this.emit('error', err);

      this.trie.on('error', errorListener);

      this._unlisteners.push(() => this.trie.removeListener('error', errorListener));
    } // TODO: Replace with a LRU cache.


    this._tries = new Map();
    this._checkouts = new Map();
    this.once('close', () => {
      for (const unlisten of this._unlisteners) {
        unlisten();
      }

      this._unlisteners = [];
    });
  }

  ready(cb) {
    return this.open(cb);
  }

  _open(cb) {
    this.corestore.ready(err => {
      if (err) return cb(err);
      this.trie.ready(err => {
        if (err) return cb(err);
        this.key = this.trie.key;
        this.discoveryKey = this.trie.discoveryKey;
        if (this.feed.writable) this.trie.alwaysUpdate = false;
        this.emit('feed', this.feed, {
          version: this.opts && this.opts.version
        });
        this.emit('hypertrie', this.trie);
        return cb(null);
      });
    });
  }

  _close(cb) {
    this.corestore.close(err => {
      this.emit('close');
      return cb(err);
    });
  }

  _createHypertrie(key, opts, cb) {
    const self = this;
    const keyString = key.toString('hex');
    var versionedTrie = opts && opts.version ? this._checkouts.get(`${keyString}:${opts.version}`) : null;
    if (versionedTrie) return process.nextTick(cb, null, versionedTrie);

    try {
      var subfeed = this.corestore.get({ ...opts,
        key,
        version: null
      });
    } catch (err) {
      err.badKey = true;
      return cb(err);
    }

    var trie = this._tries.get(keyString);

    if (opts && opts.cached) return cb(null, trie);
    var creating = !trie;
    trie = trie || new MountableHypertrie(this.corestore, key, { ...this.opts,
      feed: subfeed,
      sparse: this.sparse
    });

    self._tries.set(keyString, trie);

    if (creating) {
      const onfeed = (feed, opts) => this.emit('feed', feed, opts);

      const ontrie = trie => this.emit('hypertrie', trie);

      self._unlisteners.push(() => trie.removeListener('feed', onfeed));

      self._unlisteners.push(() => trie.removeListener('hypertrie', ontrie));

      trie.on('feed', onfeed);
      trie.on('hypertrie', ontrie);
    }

    if (!trie.opened) {
      trie.ready(err => {
        if (err) return cb(err);
        return onready();
      });
    } else process.nextTick(onready);

    function onready() {
      if (!opts || !opts.version) return ontrie(trie);
      versionedTrie = trie.checkout(opts.version);

      self._checkouts.set(`${keyString}:${opts.version}`, versionedTrie);

      return ontrie(versionedTrie);
    }

    function ontrie(trie) {
      trie.trie.ready(err => {
        if (err) return cb(err);
        return cb(null, trie);
      });
    }
  }

  _trieForMountNode(mountNode, opts, cb) {
    if (typeof opts === 'function') return this._trieForMountNode(mountNode, {}, opts);
    opts = opts || {};
    if (!mountNode) return cb(new Error(`Mount metadata not found`));

    try {
      var mountInfo = Mount.decode(mountNode.value);
    } catch (err) {
      return cb(err);
    }

    this._createHypertrie(mountInfo.key, { ...opts,
      version: mountInfo.version
    }, (err, trie) => {
      if (err) return cb(err);
      return cb(null, trie, mountInfo);
    });
  }

  _isNormalNode(node) {
    if (!node) return true;
    return node.flags ^ Flags.MOUNT;
  }

  _mountInfo() {
    return {
      key: this.key,
      version: this.opts.version ? this.opts.version : null,
      localPath: '',
      remotePath: ''
    };
  }

  _maybeSetSymbols(node, trie, mountInfo, innerPath) {
    if (trie && !node[MountableHypertrie.Symbols.TRIE]) node[MountableHypertrie.Symbols.TRIE] = trie;
    if (mountInfo && !node[MountableHypertrie.Symbols.MOUNT]) node[MountableHypertrie.Symbols.MOUNT] = mountInfo;
    if (mountInfo && !node[MountableHypertrie.Symbols.INNER_PATH]) node[MountableHypertrie.Symbols.INNER_PATH] = innerPath;
  }

  _getSymbols(node) {
    return {
      trie: node[MountableHypertrie.Symbols.TRIE],
      mount: node[MountableHypertrie.Symbols.MOUNT],
      innerPath: node[MountableHypertrie.Symbols.INNER_PATH]
    };
  }

  _getSubtrie(path, cb) {
    this.trie.get(p.join(MOUNT_PREFIX, path), {
      hidden: true,
      closest: true
    }, (err, mountNode) => {
      if (err) return cb(err);
      const mountPath = mountNode && mountNode.key.slice(7);

      if (this._isNormalNode(mountNode) || p.relative(mountPath, path).startsWith('..')) {
        return cb(null, this.trie, this._mountInfo());
      }

      return this._trieForMountNode(mountNode, cb);
    });
  }

  get version() {
    return this.trie.version;
  }

  static getMetadata(feed, cb) {
    return hypertrie.getMetadata(feed, cb);
  }

  getMetadata(cb) {
    return this.trie.getMetadata(cb);
  }

  setMetadata(metadata, cb) {
    return this.trie.setMetadata(metadata, cb);
  }

  getFeed() {
    if (!this.trie) return null;
    return this.trie.feed;
  }

  mount(path, key, opts, cb) {
    if (typeof opts === 'function') return this.mount(path, key, null, opts);
    path = normalize(path);

    if (key.length !== 32 && (!opts || !opts.skipValidation)) {
      const err = new Error('The mount key is not valid.');
      err.badKey = true;
      return cb(err);
    }

    const mountRecord = Mount.encode({
      key,
      localPath: path,
      remotePath: opts && opts.remotePath && normalize(opts.remotePath),
      version: opts && opts.version
    });

    this._getSubtrie(path, (err, trie, mountInfo) => {
      if (err) return cb(err);
      const innerPath = pathToMount(path, mountInfo);

      if (!mountInfo.localPath) {
        return trie.batch([{
          type: 'put',
          key: p.join(MOUNT_PREFIX, innerPath),
          flags: Flags.MOUNT,
          hidden: true,
          value: mountRecord
        }, // TODO: empty values going to cause harm here?
        {
          type: 'put',
          key: innerPath,
          flags: Flags.MOUNT,
          value: opts && opts.value || Buffer.alloc(0)
        }], err => {
          if (err) return cb(err);
          return this._getSubtrie(path, cb);
        });
      }

      return trie.mount(innerPath, key, opts, err => {
        if (err) return cb(err);
        return this._getSubtrie(innerPath, cb);
      });
    });
  }

  unmount(path, cb) {
    path = normalize(path);
    return this._getSubtrie(p.dirname(path), (err, trie, mountInfo) => {
      if (err) return cb(err);
      const innerPath = pathToMount(path, mountInfo);
      trie.get(innerPath, (err, node) => {
        // If the subtrie is a MountableHypertrie, use the internal hypertrie for the batch.
        if (trie.trie) trie = trie.trie;
        return trie.batch([{
          type: 'del',
          key: p.join(MOUNT_PREFIX, innerPath),
          hidden: true
        }, {
          type: 'del',
          key: innerPath
        }], cb);
      });
    });
  }

  loadMount(path, cb) {
    return this._getSubtrie(path, cb);
  }

  get(path, opts, cb) {
    if (typeof opts === 'function') return this.get(path, null, opts);
    path = normalize(path);
    const self = this;
    this.trie.get(path, { ...opts,
      closest: true
    }, (err, node) => {
      if (err) return cb(err);

      const mountInfo = this._mountInfo();

      if (!node) return cb(null, null, this, mountInfo, path);

      if (this._isNormalNode(node)) {
        this._maybeSetSymbols(node, this, mountInfo, path);

        if (node.key !== path && !(opts && opts.closest)) return cb(null, null, this, mountInfo, path);
        return cb(null, node, this, mountInfo, path);
      }

      if (node.key === path) return cb(null, node, this, mountInfo, path);
      return this._getSubtrie(path, getFromMount);
    });

    function getFromMount(err, trie, mountInfo) {
      if (err) return cb(err);
      const mountPath = pathToMount(path, mountInfo);
      return trie.get(mountPath, opts, (err, node, subTrie, subMountInfo, subMountPath) => {
        if (err) return cb(err);
        subTrie = subTrie || self;
        subMountInfo = subMountInfo || mountInfo;
        subMountPath = subMountPath || mountPath;
        if (!node) return cb(null, null, subTrie, subMountInfo, subMountPath);
        node.key = pathFromMount(node.key, mountInfo);
        if (node.key !== path) return cb(null, null, subTrie, subMountInfo, subMountPath);

        self._maybeSetSymbols(node, subTrie, subMountInfo, subMountPath);

        const {
          trie: innerTrie,
          mount: innerMount,
          innerPath
        } = self._getSymbols(node);

        return cb(null, node, innerTrie, innerMount, innerPath);
      });
    }
  }

  put(path, value, opts, cb) {
    if (typeof opts === 'function') return this.put(path, value, null, opts);
    path = normalize(path);
    const condition = putCondition(path, opts);
    this.trie.put(path, value, { ...opts,
      condition,
      closest: true
    }, (err, inserted) => {
      if (err && !err.mountpoint) return cb(err);else if (err) {
        return this._getSubtrie(path, putIntoMount);
      }
      return cb(null, inserted);
    });

    function putIntoMount(err, trie, mountInfo) {
      if (err) return cb(err);
      const mountPath = pathToMount(path, mountInfo);
      return trie.put(mountPath, value, opts, (err, node) => {
        if (err) return cb(err);
        if (!node) return cb(null, null); // TODO: do we need to copy the node here?

        node.key = pathFromMount(node.key, mountInfo);
        return cb(null, node);
      });
    }
  } // TODO: remove duplicate code


  del(path, opts, cb) {
    if (typeof opts === 'function') return this.del(path, null, opts);
    path = normalize(path);
    const condition = delCondition(path, opts && opts.condition);
    this.trie.del(path, { ...opts,
      condition,
      closest: true
    }, (err, deleted) => {
      if (err && !err.mountpoint) return cb(err);else if (err) {
        return this._getSubtrie(path, delFromMount);
      }
      return cb(null, deleted);
    });

    function delFromMount(err, trie, mountInfo) {
      if (err) return cb(err);
      const mountPath = pathToMount(path, mountInfo);
      return trie.del(mountPath, opts, (err, node) => {
        if (err) return cb(err);
        if (!node) return cb(null, null); // TODO: do we need to copy the node here?

        node.key = pathFromMount(node.key, mountInfo);
        return cb(null, node);
      });
    }
  }

  iterator(prefix, opts) {
    if (isOptions(prefix)) return this.iterator('', prefix);
    if (!prefix) prefix = '/';
    prefix = normalize(prefix);
    const self = this;
    const recursive = !!(opts && opts.recursive);
    const noMounts = !!(opts && opts.noMounts);
    const gt = !!(opts && opts.gt); // gt must always be false in the trie iteration in order to discover mountpoints.

    if (gt) opts = { ...opts,
      gt: false
    }; // Set in open.

    let root = null;
    let rootInfo = null; // If the iterator is currently iterating through a sub-trie, then these will be non-null.

    let subTrie = null;
    let sub = null;
    let subInfo = null;
    return nanoiterator({
      next,
      open
    });

    function open(cb) {
      self._getSubtrie(prefix, (err, trie, mountInfo) => {
        if (err) return cb(err);
        const subPrefix = pathToMount(prefix, mountInfo);
        root = trie.iterator(subPrefix, opts);
        rootInfo = mountInfo;
        return cb(null);
      });
    }

    function next(cb) {
      if (sub) {
        return sub.next((err, node) => {
          if (err) return cb(err);

          if (!node) {
            sub = subInfo = subTrie = null;
            return next(cb);
          }

          const innerPath = node.key;
          node.key = pathFromMount(node.key, subInfo);

          self._maybeSetSymbols(node, subTrie, subInfo, innerPath);

          return prereturn(node, cb);
        });
      }

      root.next((err, node) => {
        if (err) return cb(err);
        if (!node) return cb(null, null);

        self._maybeSetSymbols(node, self, rootInfo, node.key);

        if (self._isNormalNode(node) || noMounts) return prereturn(node, cb);else if (!recursive && node.key !== prefix) return prereturn(node, cb);

        self._getSubtrie(node.key, (err, trie, mountInfo) => {
          if (err) return cb(err);
          const subPrefix = pathToMount(node.key, mountInfo);
          sub = trie.iterator(subPrefix, opts);
          subInfo = mountInfo;
          subTrie = trie;
          return prereturn(node, cb);
        });
      });
    }

    function prereturn(node, cb) {
      if (gt && node.key === prefix) return next(cb);
      node.key = pathFromMount(node.key, rootInfo);
      return cb(null, node);
    }
  }

  list(prefix, opts, cb) {
    // Code duplicated from hypertrie.
    if (typeof prefix === 'function') return this.list('', null, prefix);
    if (typeof opts === 'function') return this.list(prefix, null, opts);
    const ite = this.iterator(prefix, opts);
    const res = [];
    ite.next(function loop(err, node) {
      if (err) return cb(err);
      if (!node) return cb(null, res);
      res.push(node);
      ite.next(loop);
    });
  }

  mountIterator(opts) {
    const memory = !!(opts && opts.memory);
    const recursive = !!(opts && opts.recursive);
    const ite = this.trie.iterator(MOUNT_PREFIX, {
      hidden: true
    });
    const stack = [{
      trie: this,
      ite,
      prefix: '/'
    }];
    return nanoiterator({
      next
    });

    function next(cb) {
      const {
        trie,
        ite,
        prefix
      } = stack[0];
      return ite.next((err, mountNode) => {
        if (err) return cb(err);
        if (!mountNode && stack.length === 1) return cb(null, null);

        if (!mountNode) {
          stack.shift();
          return next(cb);
        }

        trie._trieForMountNode(mountNode, {
          cached: memory
        }, (err, subTrie, mountInfo) => {
          if (err) return cb(err);
          if (!subTrie) return next(cb);
          const mountPath = p.join(prefix, mountInfo.localPath);

          if (recursive) {
            stack.unshift({
              prefix: p.join(mountPath, mountInfo.remotePath),
              ite: subTrie.iterator(MOUNT_PREFIX, {
                hidden: true
              }),
              trie: subTrie
            });
          }

          return cb(null, {
            path: mountPath,
            trie: subTrie
          });
        });
      });
    }
  }

  listMounts(opts, cb) {
    if (typeof opts === 'function') return this.listMounts(null, opts);
    const vals = [];
    const ite = this.mountIterator(opts);
    ite.next(function onnext(err, val) {
      if (err) return cb(err);
      if (!val) return cb(null, vals);
      vals.push(val);
      return ite.next(onnext);
    });
  }

  createReadStream(prefix, opts) {
    return toStream(this.iterator(prefix, opts));
  }

  batch(ops, cb) {// TODO: implement
  }

  checkout(version) {
    return new MountableHypertrie(this.corestore, null, { ...this.opts,
      trie: this.trie,
      feed: this.feed,
      version: version || 1
    });
  }

  history(opts) {
    const self = this;
    const ite = this.trie.history(opts);
    return nanoiterator({
      next
    });

    function next(cb) {
      ite.next((err, node) => {
        if (err) return cb(err);
        if (!node) return cb(null, null);
        if (self._isNormalNode(node)) return cb(null, {
          type: 'put',
          node
        });
        return self._getSubtrie(node.key, (err, trie, mountInfo) => {
          if (err) return cb(err);
          return cb(null, {
            type: 'mount',
            info: mountInfo
          });
        });
      });
    }
  }

  diff(other, prefix, opts) {
    if (typeof other === 'string') return this.diff(null, other, prefix);
    const checkout = typeof other === 'number' || !other ? this.checkout(other) : other;
    if (!prefix) prefix = '/';
    const self = this;
    var ite = null;
    return nanoiterator({
      next,
      open
    });

    function next(cb) {
      var remaining = 2;
      ite.next((err, keyDiff) => {
        if (err) return cb(err);
        if (!keyDiff) return cb(null, null);
        const {
          left: rawLeft,
          right: rawRight,
          key
        } = keyDiff;
        return updateIfMount(rawLeft, (err, left) => {
          if (err) return cb(err);
          return updateIfMount(rawRight, (err, right) => {
            if (err) return cb(err);
            return cb(null, createDiff(left, right, key));
          });
        });
      });
    }

    function open(cb) {
      self._getSubtrie(prefix, (err, trie, mountInfo) => {
        if (err) return cb(err);
        const subPrefix = pathToMount(prefix, mountInfo);
        ite = trie.diff(checkout.trie, pathToMount(prefix, mountInfo), opts);
        return cb(null);
      });
    }

    function updateIfMount(node, cb) {
      if (!node) return process.nextTick(cb, null);
      if (self._isNormalNode(node)) return process.nextTick(cb, null, node);
      if (opts && opts.noMounts) return process.nextTick(cb, null, {
        info: {}
      });
      return self._getSubtrie(node.key, (err, trie, mountInfo) => {
        if (err) return cb(err);
        return cb(null, {
          info: mountInfo
        });
      });
    }

    function createDiff(left, right, key) {
      const diff = {
        left,
        right,
        key
      };

      if (!left && right) {
        diff.type = !!right.info ? 'unmount' : 'del';
      } else {
        diff.type = !!left.info ? 'mount' : 'put';
      }

      return diff;
    }
  }

  createHistoryStream(opts) {
    return toStream(this.history(opts));
  }

  createDiffStream(other, prefix, opts) {
    return toStream(this.diff(other, prefix, opts));
  }

  watch(path, opts, onchange) {
    if (typeof opts === 'function') return this.watch(path, null, opts);
    const self = this;
    var destroyed = false;
    var rootWatcher = this.trie.watch(path, onchange);
    var watcherKeys = opts && opts._watcherKeys || new Set();
    var watchers = [];
    const destroy = rootWatcher.destroy.bind(rootWatcher);
    rootWatcher.watchers = watchers;

    rootWatcher.destroy = function () {
      if (destroyed) return;
      destroyed = true;
      destroy();

      for (let watcher of watchers) {
        watcher.destroy();
      }
    };

    createSubWatchers(err => {
      if (err) rootWatcher.emit('error', err);
      rootWatcher.emit('ready', watchers);
    });
    return rootWatcher;

    function createSubWatchers(cb) {
      self.trie.list(p.join(MOUNT_PREFIX, path), {
        hidden: true
      }, (err, mountNodes) => {
        if (err || destroyed) return cb(err);
        if (!mountNodes || !mountNodes.length) return cb(null);
        var readyWatchers = 0;

        for (let mountNode of mountNodes) {
          if (destroyed) return cb(null);

          self._trieForMountNode(mountNode, (err, trie, mountInfo) => {
            if (err || destroyed) return cb(err);
            const watcherKey = mountInfo.key.toString('hex');
            if (watcherKeys.has(watcherKey)) return subWatcherReady();
            watcherKeys.add(watcherKey);
            const subWatcher = trie.watch(pathToMount(path, mountInfo), {
              _watcherKeys: watcherKeys
            }, () => {
              onchange();
            });
            watchers.push(subWatcher);

            if (trie.trie) {
              subWatcher.once('ready', subsubWatchers => {
                watchers.push.apply(watchers, subsubWatchers);
                return subWatcherReady();
              });
            } else {
              return subWatcherReady();
            }
          });
        }

        function subWatcherReady() {
          if (++readyWatchers === mountNodes.length) return cb(null);
        }
      });
    }
  }

  replicate(isInitiator, opts) {
    const stream = new HypercoreProtocol(isInitiator, { ...opts
    });
    this.ready(err => {
      if (err) return stream.destroy(err);
      this.corestore.replicate(isInitiator, { ...opts,
        stream
      });
    });
    return stream;
  }

}

MountableHypertrie.Symbols = MountableHypertrie.prototype.Symbols = {
  TRIE: Symbol('trie'),
  MOUNT: Symbol('mount'),
  INNER_PATH: Symbol('inner-path')
};
module.exports = MountableHypertrie;

function putCondition(path, opts) {
  const userCondition = opts && opts.condition;
  const userClosest = opts && opts.closest;
  return (closest, newNode, cb) => {
    const isWithinMount = closest && newNode.key.startsWith(closest.key) && newNode.key !== closest.key;

    if (closest && closest.flags & Flags.MOUNT && isWithinMount) {
      const err = new Error('Operating on a mountpoint');
      err.mountpoint = true;
      return cb(err);
    }

    if (!userCondition) return cb(null, true);
    if (closest && closest.key !== newNode.key && !userClosest) closest = null;
    userCondition(closest, newNode, (err, shouldExecute) => {
      if (err) return cb(err);
      return cb(null, shouldExecute);
    });
  };
}

function delCondition(path, userCondition) {
  return (closest, cb) => {
    if (closest && closest.flags & Flags.MOUNT && closest.key !== path) {
      const err = new Error('Operating on a mountpoint');
      err.mountpoint = true;
      return cb(err);
    }

    if (!userCondition) return cb(null, true);
    userCondition(closest, (err, shouldExecute) => {
      if (err) return cb(err);
      return cb(null, shouldExecute);
    });
  };
}

function pathToMount(path, mountInfo) {
  if (path.length === mountInfo.localPath.length) return '';
  return p.join(path.slice(mountInfo.localPath.length), mountInfo.remotePath);
}

function pathFromMount(path, mountInfo) {
  const rel = mountInfo.remotePath ? path.slice(mountInfo.remotePath.length) : path;
  return p.join(mountInfo.localPath, rel);
}

function normalize(path) {
  path = unixify(path);
  return path.startsWith('/') ? path.slice(1) : path;
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./lib/messages":316,"_process":380,"buffer":97,"events":172,"hypercore-crypto":236,"hypercore-protocol":239,"hypertrie":265,"is-options":284,"nanoiterator":323,"nanoiterator/to-stream":324,"nanoresource/emitter":344,"path":371,"thunky":568,"unixify":573}],316:[function(require,module,exports){
(function (Buffer){(function (){
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */

/* eslint-disable indent */

/* eslint-disable no-redeclare */

/* eslint-disable camelcase */
// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings');

var varint = encodings.varint;
var skip = encodings.skip;
var Mount = exports.Mount = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
defineMount();

function defineMount() {
  var enc = [encodings.bytes, encodings.string, encodings.varint];
  Mount.encodingLength = encodingLength;
  Mount.encode = encode;
  Mount.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.key)) throw new Error("key is required");
    var len = enc[0].encodingLength(obj.key);
    length += 1 + len;
    if (!defined(obj.localPath)) throw new Error("localPath is required");
    var len = enc[1].encodingLength(obj.localPath);
    length += 1 + len;

    if (defined(obj.version)) {
      var len = enc[2].encodingLength(obj.version);
      length += 1 + len;
    }

    if (defined(obj.remotePath)) {
      var len = enc[1].encodingLength(obj.remotePath);
      length += 1 + len;
    }

    if (defined(obj.hash)) {
      var len = enc[0].encodingLength(obj.hash);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.key)) throw new Error("key is required");
    buf[offset++] = 10;
    enc[0].encode(obj.key, buf, offset);
    offset += enc[0].encode.bytes;
    if (!defined(obj.localPath)) throw new Error("localPath is required");
    buf[offset++] = 18;
    enc[1].encode(obj.localPath, buf, offset);
    offset += enc[1].encode.bytes;

    if (defined(obj.version)) {
      buf[offset++] = 24;
      enc[2].encode(obj.version, buf, offset);
      offset += enc[2].encode.bytes;
    }

    if (defined(obj.remotePath)) {
      buf[offset++] = 34;
      enc[1].encode(obj.remotePath, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.hash)) {
      buf[offset++] = 42;
      enc[0].encode(obj.hash, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      key: null,
      localPath: "",
      version: 0,
      remotePath: "",
      hash: null
    };
    var found0 = false;
    var found1 = false;

    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.key = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.localPath = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          found1 = true;
          break;

        case 3:
          obj.version = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;

        case 4:
          obj.remotePath = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 5:
          obj.hash = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"protocol-buffers-encodings":382}],317:[function(require,module,exports){
/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],318:[function(require,module,exports){
(function (process){(function (){
var mutexify = function () {
  var queue = [];
  var used = null;

  var call = function () {
    used(release);
  };

  var acquire = function (fn) {
    if (used) return queue.push(fn);
    used = fn;
    acquire.locked = true;
    process.nextTick(call);
    return 0;
  };

  acquire.locked = false;

  var release = function (fn, err, value) {
    used = null;
    acquire.locked = false;
    if (queue.length) acquire(queue.shift());
    if (fn) fn(err, value);
  };

  return acquire;
};

module.exports = mutexify;

}).call(this)}).call(this,require('_process'))
},{"_process":380}],319:[function(require,module,exports){
assert.notEqual = notEqual;
assert.notOk = notOk;
assert.equal = equal;
assert.ok = assert;
module.exports = assert;

function equal(a, b, m) {
  assert(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual(a, b, m) {
  assert(a != b, m); // eslint-disable-line eqeqeq
}

function notOk(t, m) {
  assert(!t, m);
}

function assert(t, m) {
  if (!t) throw new Error(m || 'AssertionError');
}

},{}],320:[function(require,module,exports){
module.exports = assert;

class AssertionError extends Error {}

AssertionError.prototype.name = 'AssertionError';
/**
 * Minimal assert function + custom errors
 * @param  {any} t Value to check if falsy
 * @param  {string|function} m Optional assertion error message or nanoerror constructor
 * @param  {string=} rest Optional error parameters for nanoerror message
 * @throws {AssertionError || nanoerror}
 */

function assert(t, m, ...rest) {
  if (!t) {
    var err;

    if (!m || typeof m === 'string') {
      err = new AssertionError(m);
    }

    if (typeof m === 'function') {
      // eslint-disable-next-line
      err = new m(...rest);
    }

    if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
    throw err;
  }
}

},{}],321:[function(require,module,exports){
const format = require('quick-format-unescaped');

class Nanoerror extends Error {
  /**
   * @readonly
   * @static
   * @returns {string}
   */
  static get code() {
    return this.name;
  }
  /**
   * @static
   * @param {Nanoerror} err
   * @returns {boolean}
   */


  static equals(err) {
    return err && typeof err === 'object' && err.isNanoerror && err.code === this.code;
  }
  /**
   * Creates a new Error
   * @param {...any} [args]
   */


  constructor(...args) {
    super();
    const code = this.constructor.code;
    const unformatMessage = this.constructor.message;
    /** @type {string} */

    this.message = format(unformatMessage, args);
    /** @type {string} */

    this.name = code;
    /** @type {string} */

    this.code = this.name;
    /** @type {Array<any>} */

    this.args = args;
    /** @type {string} */

    this.unformatMessage = unformatMessage;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(this.message).stack;
    }
  }
  /**
   * @readonly
   * @returns {boolean}
   */


  get isNanoerror() {
    return true;
  }

}
/**
 * @type {string}
 * @static
 * @memberof Nanoerror
 */


Nanoerror.message = '';
/**
 * Creates a new Error class
 *
 * @param {string} code
 * @param {string} message
 */

function createError(code, message = '%s') {
  const obj = {
    [code]: class extends Nanoerror {
      /**
       * @static
       * @param {Error} err
       * @returns {Nanoerror}
       */
      static from(err) {
        const newErr = new obj[code](`[${err.toString()}]`);
        newErr.stack = err.stack || newErr.stack;
        return newErr;
      }

    }
  };
  obj[code].message = message;
  return obj[code];
}

module.exports = createError;

},{"quick-format-unescaped":413}],322:[function(require,module,exports){
(function (process){(function (){
module.exports = class Nanoguard {
  constructor() {
    this._tick = 0;
    this._fns = [];
    this._dep = null;
  }

  get waiting() {
    return this._tick > 0;
  }

  depend(dep) {
    if (this._dep !== null) throw new Error('Can only depend on one other guard currently');
    this._dep = dep;
  }

  wait() {
    this._tick++;
  }

  continue(cb, err, val) {
    if (this._tick === 1) process.nextTick(continueNT, this);else this._tick--;
    if (cb) cb(err, val);
  }

  waitAndContinue() {
    let once = false;
    this.wait();
    return () => {
      if (once) return false;
      once = true;
      this.continue();
      return true;
    };
  }

  continueSync(cb, err, val) {
    if (--this._tick) return;

    while (this._fns !== null && this._fns.length) this._ready(this._fns.pop());

    if (cb) cb(err, val);
  }

  destroy() {
    const fns = this._fns;
    if (fns) return;
    this._fns = null;

    while (fns.length) fns.pop()();
  }

  ready(fn) {
    if (this._fns === null || this._tick === 0) this._ready(fn);else this._fns.push(fn);
  }

  _ready(fn) {
    if (this._dep === null) fn();else this._dep.ready(fn);
  }

};

function continueNT(guard) {
  guard.continueSync();
}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],323:[function(require,module,exports){
(function (process){(function (){
module.exports = NanoIterator;

function NanoIterator(opts) {
  if (!(this instanceof NanoIterator)) return new NanoIterator(opts);
  this.opened = false;
  this.closed = false;
  this.ended = false;
  this._nextSync = false;
  this._nextQueue = [];
  this._nextCallback = null;
  this._nextDone = nextDone.bind(null, this);
  this._openDone = openDone.bind(null, this);

  if (opts) {
    if (opts.open) this._open = opts.open;
    if (opts.next) this._next = opts.next;
    if (opts.destroy) this._destroy = opts.destroy;
  }
}

NanoIterator.prototype.next = function (cb) {
  if (this._nextCallback || this._nextQueue.length) {
    this._nextQueue.push(cb);

    return;
  }

  this._nextCallback = cb;
  this._nextSync = true;
  if (!this.opened) this._open(this._openDone);else update(this);
  this._nextSync = false;
};

NanoIterator.prototype.destroy = function (cb) {
  if (!cb) cb = noop;

  if (this.closed) {
    this.next(() => cb());
    return;
  }

  this.closed = true;
  if (!this._nextCallback) this.opened = true;
  this.next(() => this._destroy(cb));
};

NanoIterator.prototype._open = function (cb) {
  cb(null);
};

NanoIterator.prototype._destroy = function (cb) {
  cb(null);
};

NanoIterator.prototype._next = function (cb) {
  cb(new Error('_next is not implemented'));
};

if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {
  NanoIterator.prototype[Symbol.asyncIterator] = function () {
    var self = this;
    return {
      next: nextPromise,
      return: returnPromise
    };

    function returnPromise() {
      return new Promise(function (resolve, reject) {
        self.destroy(function (err) {
          if (err) return reject(err);
          resolve({
            value: null,
            done: true
          });
        });
      });
    }

    function nextPromise() {
      return new Promise(function (resolve, reject) {
        self.next(function (err, val) {
          if (err) return reject(err);
          resolve({
            value: val,
            done: val === null
          });
        });
      });
    }
  };
}

function noop() {}

function openDone(self, err) {
  if (err) return nextDone(self, err, null);
  self.opened = true;
  update(self);
}

function nextDone(self, err, value) {
  if (self._nextSync) return nextDoneNT(self, err, value);

  if (self.closed) {
    err = new Error('Iterator is destroyed');
    value = null;
  }

  var cb = self._nextCallback;
  self._nextCallback = null;
  if (!err && value === null) self.ended = true;
  cb(err, value);
  if (self._nextCallback || !self._nextQueue.length) return;
  self._nextCallback = self._nextQueue.shift();
  update(self);
}

function update(self) {
  if (self.ended || self.closed) nextDoneNT(self, null, null);else self._next(self._nextDone);
}

function nextDoneNT(self, err, val) {
  process.nextTick(nextDone, self, err, val);
}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],324:[function(require,module,exports){
var stream = require('readable-stream');

var inherits = require('inherits');

module.exports = IteratorStream;

function IteratorStream(ite) {
  if (!(this instanceof IteratorStream)) return new IteratorStream(ite);
  stream.Readable.call(this, {
    objectMode: true
  });
  this.iterator = ite;
  this.onread = onread.bind(null, this);
  this.destroyed = false;
}

inherits(IteratorStream, stream.Readable);

IteratorStream.prototype._read = function () {
  this.iterator.next(this.onread);
};

IteratorStream.prototype.destroy = function (err) {
  if (this.destroyed) return;
  this.destroyed = true;
  var self = this;
  this.iterator.destroy(function (error) {
    if (!err) err = error;
    if (err) self.emit('error', err);
    self.emit('close');
  });
};

function onread(self, err, value) {
  if (err) self.destroy(err);else self.push(value);
}

},{"inherits":279,"readable-stream":440}],325:[function(require,module,exports){
const NanomessageRPC = require("./src/nanomessage-rpc");

module.exports = (...args) => new NanomessageRPC(...args);

module.exports.NanomessageRPC = NanomessageRPC;
module.exports.useSocket = require("./src/use-socket");
module.exports.errors = require("./src/errors");

},{"./src/errors":329,"./src/nanomessage-rpc":330,"./src/use-socket":331}],326:[function(require,module,exports){
const nanoresource = require("./nanoresource-cb");

function callbackPromise() {
  let callback;
  const promise = new Promise((resolve, reject) => {
    callback = (err, value) => {
      if (err) reject(err);else resolve(value);
    };
  });
  callback.promise = promise;
  return callback;
}

const kNanoresource = Symbol('nanoresource');
const kProcessPromise = Symbol('processpromise');

class NanoresourcePromise {
  constructor(opts = {}) {
    const open = opts.open || this._open.bind(this);

    const close = opts.close || this._close.bind(this);

    this[kNanoresource] = nanoresource({
      open: cb => this[kProcessPromise](open, cb),
      close: cb => this[kProcessPromise](close, cb),
      reopen: opts.reopen
    });
  }

  get opened() {
    return this[kNanoresource].opened;
  }

  get opening() {
    return this[kNanoresource].opening;
  }

  get closed() {
    return this[kNanoresource].closed;
  }

  get closing() {
    return this[kNanoresource].closing;
  }

  get actives() {
    return this[kNanoresource].actives;
  }
  /**
   * @returns {Promise}
   */


  open() {
    const callback = callbackPromise();
    this[kNanoresource].open(callback);
    return callback.promise;
  }
  /**
   * @returns {Promise}
   */


  close(allowActive = false) {
    const callback = callbackPromise();
    this[kNanoresource].close(allowActive, callback);
    return callback.promise;
  }
  /**
   * @returns {boolean}
   */


  active(cb) {
    return this[kNanoresource].active(cb);
  }
  /**
   * @returns {boolean}
   */


  inactive(cb, err, value) {
    return this[kNanoresource].inactive(cb, err, value);
  }
  /**
   * @abstract
   */


  async _open() {}
  /**
   * @abstract
   */


  async _close() {}

  async [kProcessPromise](fnPromise, cb) {
    try {
      await fnPromise();
      cb();
    } catch (err) {
      cb(err);
    }
  }

}

module.exports = opts => new NanoresourcePromise(opts);

module.exports.NanoresourcePromise = NanoresourcePromise;

},{"./nanoresource-cb":327}],327:[function(require,module,exports){
(function (process){(function (){
/**
 *
 * This code is based on the @mafintosh work.
 * https://github.com/mafintosh/nanoresource
 */
const preopening = Symbol('opening when closing');
const opening = Symbol('opening queue');
const preclosing = Symbol('closing when inactive');
const closing = Symbol('closing queue');
const sync = Symbol('sync');
const fastClose = Symbol('fast close');
const reopen = Symbol('allow reopen');
const init = Symbol('init state');

class Nanoresource {
  constructor(opts) {
    if (!opts) opts = {};
    if (opts.open) this._open = opts.open;
    if (opts.close) this._close = opts.close;
    this[init]();
    this[reopen] = opts.reopen || false;
    this[preopening] = null;
    this[opening] = null;
    this[preclosing] = null;
    this[closing] = null;
    this[sync] = false;
    this[fastClose] = true;
  }

  [init]() {
    this.opening = false;
    this.opened = false;
    this.closing = false;
    this.closed = false;
    this.actives = 0;
  }

  _open(cb) {
    cb(null);
  }

  _close(cb) {
    cb(null);
  }

  open(cb) {
    if (!cb) cb = noop;

    if (this.closing || this.closed) {
      if (!this[reopen]) {
        return process.nextTick(cb, new Error('Resource is closed'));
      }

      if (this.closing) {
        if (!this[preopening]) this[preopening] = [];
        this[preopening].push(cb);
        return;
      }

      this[init]();
    }

    if (this.opened) return process.nextTick(cb);

    if (this[opening]) {
      this[opening].push(cb);
      return;
    }

    this.opening = true;
    this[opening] = [cb];
    this[sync] = true;

    this._open(onopen.bind(this));

    this[sync] = false;
  }

  active(cb) {
    if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
      if (cb) process.nextTick(cb, new Error('Resource is closed'));
      return false;
    }

    this.actives++;
    return true;
  }

  inactive(cb, err, val) {
    if (! --this.actives) {
      const queue = this[preclosing];

      if (queue) {
        this[preclosing] = null;

        while (queue.length) this.close(queue.shift());
      }
    }

    if (cb) cb(err, val);
  }

  close(allowActive, cb) {
    if (typeof allowActive === 'function') return this.close(false, allowActive);
    if (!cb) cb = noop;
    if (allowActive) this[fastClose] = false;
    if (this.closed) return process.nextTick(cb);

    if (this.actives || this[opening]) {
      if (!this[preclosing]) this[preclosing] = [];
      this[preclosing].push(cb);
      return;
    }

    if (!this.opened) {
      this.closed = true;
      process.nextTick(cb);
      return;
    }

    if (this[closing]) {
      this[closing].push(cb);
      return;
    }

    this.closing = true;
    this[closing] = [cb];
    this[sync] = true;

    this._close(onclose.bind(this));

    this[sync] = false;
  }

}

function onopen(err) {
  if (this[sync]) return process.nextTick(onopen.bind(this), err);
  const oqueue = this[opening];
  this[opening] = null;
  this.opening = false;
  this.opened = !err;

  while (oqueue.length) oqueue.shift()(err);

  const cqueue = this[preclosing];

  if (cqueue && !this.actives) {
    this[preclosing] = null;

    while (cqueue.length) this.close(cqueue.shift());
  }
}

function onclose(err) {
  if (this[sync]) return process.nextTick(onclose.bind(this), err);
  const queue = this[closing];
  this.closing = false;
  this[closing] = null;
  this.closed = !err;

  while (queue.length) queue.shift()(err);

  const cqueue = this[preopening];

  if (cqueue) {
    this[preopening] = null;

    while (cqueue.length) this.open(cqueue.shift());
  }
}

function noop() {}

module.exports = opts => new Nanoresource(opts);

module.exports.Nanoresource = Nanoresource;

}).call(this)}).call(this,require('_process'))
},{"_process":380}],328:[function(require,module,exports){
(function (Buffer){(function (){
const varint = require('varint');

const {
  BJSON
} = require('nanomessage');

const {
  NRPC_ERR_ENCODE,
  NRPC_ERR_DECODE
} = require("./errors");

function writeNumber(value, dest) {
  varint.encode(value, dest.buf, dest.offset);
  dest.offset += varint.encode.bytes;
}

function writeCodec(enc, length, value, dest) {
  writeNumber(length, dest);
  enc.encode(value, dest.buf, dest.offset);
  dest.offset += length;
}

function writeString(value, length, dest) {
  writeNumber(length, dest);
  dest.buf.write(value, dest.offset, length, 'utf8');
  dest.offset += length;
}

function readNumber(source) {
  const num = varint.decode(source.buf, source.offset);
  source.offset += varint.decode.bytes;
  return num;
}

function readCodec(enc, source) {
  const length = readNumber(source);
  const buf = enc.decode(source.buf, source.offset, source.offset + length);
  source.offset += length;
  return buf;
}

function readBuffer(source) {
  const length = readNumber(source);
  const buf = source.buf.slice(source.offset, source.offset + length);
  source.offset += length;
  return buf;
}

const ATTR_RESPONSE = 1;
const ATTR_EVENT = 1 << 1;
const ATTR_ERROR = 1 << 2;

class Codec {
  constructor(valueEncoding = BJSON) {
    this._valueEncoding = valueEncoding;
    this._lastHeader = null;
    this._lastDataLength = null;
    this._lastNameLength = null;
  }

  encode(obj, buf, offset = 0) {
    try {
      if (obj.name) {
        return this._encodeRequest(obj, buf, offset);
      }

      return this._encodeResponse(obj, buf, offset);
    } catch (_err) {
      const err = new NRPC_ERR_ENCODE(_err.message);
      err.stack = _err.stack || err.stack;
      throw _err;
    }
  }

  decode(buf, offset = 0) {
    try {
      const header = varint.decode(buf, offset);
      offset += varint.decode.bytes;

      if (header & ATTR_RESPONSE) {
        return this._decodeResponse(header, buf, offset);
      }

      return this._decodeRequest(header, buf, offset);
    } catch (_err) {
      const err = new NRPC_ERR_DECODE(_err.message);
      err.stack = _err.stack || err.stack;
      throw _err;
    }
  }

  encodingLength(obj) {
    if (obj.name) {
      return this._encodingLengthRequest(obj);
    }

    return this._encodingLengthResponse(obj);
  }

  _headerRequest(obj) {
    let header = 0;
    if (obj.event) header = header | ATTR_EVENT;
    this._lastHeader = header;
    return header;
  }

  _headerResponse(obj) {
    let header = 0;
    header = header | ATTR_RESPONSE;
    if (obj.error) header = header | ATTR_ERROR;
    this._lastHeader = header;
    return header;
  }

  _encodeRequest(obj, buf, offset) {
    const result = {
      buf,
      offset
    };
    writeNumber(this._lastHeader, result);
    writeString(obj.name, this._lastNameLength, result);
    writeCodec(this._valueEncoding, this._lastDataLength, obj.data, result);
    return result.buf;
  }

  _decodeRequest(header, buf, offset) {
    const obj = {};
    const result = {
      buf,
      offset
    };
    obj.event = !!(header & ATTR_EVENT);
    obj.name = readBuffer(result).toString();
    obj.data = readCodec(this._valueEncoding, result);
    return obj;
  }

  _encodingLengthRequest(obj) {
    const header = this._headerRequest(obj);

    this._lastDataLength = this._valueEncoding.encodingLength(obj.data);
    this._lastNameLength = Buffer.byteLength(obj.name, 'utf8');
    return varint.encodingLength(header) + varint.encodingLength(this._lastDataLength) + this._lastDataLength + varint.encodingLength(this._lastNameLength) + this._lastNameLength;
  }

  _encodingLengthResponse(obj) {
    const header = this._headerResponse(obj);

    let codec = this._valueEncoding;
    if (obj.error) codec = BJSON;
    const dataLength = codec.encodingLength(obj.data);
    return varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength;
  }

  _encodeResponse(obj, buf, offset) {
    let codec = this._valueEncoding;
    if (obj.error) codec = BJSON;
    const dataLength = codec.encodingLength(obj.data);
    const result = {
      buf,
      offset
    };
    writeNumber(this._lastHeader, result);
    writeCodec(codec, dataLength, obj.data, result);
    return result.buf;
  }

  _decodeResponse(header, buf, offset) {
    const obj = {};
    const result = {
      buf,
      offset
    };
    obj.error = !!(header & ATTR_ERROR);
    let codec = this._valueEncoding;
    if (obj.error) codec = BJSON;
    obj.data = readCodec(codec, result);
    return obj;
  }

}

module.exports = Codec;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./errors":329,"buffer":97,"nanomessage":332,"varint":582}],329:[function(require,module,exports){
const nanoerror = require('nanoerror');

exports.encodeError = encodeError;
exports.decodeError = decodeError;
const errors = new Map();

function createError(code, message) {
  exports[code] = nanoerror(code, message);
}

function encodeError(err) {
  return {
    error: true,
    data: {
      code: err.code,
      unformatMessage: err.unformatMessage,
      args: err.args,
      stack: err.stack
    }
  };
}

function decodeError(code, message) {
  if (exports[code]) return exports[code];
  if (errors.has(code)) return errors.get(code);
  const error = nanoerror(code, message);
  errors.set(code, error);
  return error;
}

createError('NRPC_ERR_NAME_MISSING', 'missing action handler for: %s');
createError('NRPC_ERR_RESPONSE_ERROR', '%s');
createError('NRPC_ERR_REQUEST_CANCELED', '%s');
createError('NRPC_ERR_CLOSE', 'nanomessage-rpc was closed');
createError('NRPC_ERR_NOT_OPEN', 'nanomessage-rpc is not open');
createError('NRPC_ERR_ENCODE', 'error encoding the request: %s');
createError('NRPC_ERR_DECODE', 'error decoding the request: %s');

},{"nanoerror":321}],330:[function(require,module,exports){
(function (process){(function (){
const {
  EventEmitter
} = require('events');

const Emittery = require('emittery');

const nanomessage = require('nanomessage');

const assert = require('nanocustomassert');

const {
  NanoresourcePromise
} = require('nanoresource-promise');

const Codec = require("./codec");

const {
  encodeError,
  decodeError,
  NRPC_ERR_NAME_MISSING,
  NRPC_ERR_RESPONSE_ERROR,
  NRPC_ERR_CLOSE,
  NRPC_ERR_NOT_OPEN,
  NRPC_ERR_REQUEST_CANCELED
} = require("./errors");

const kNanomessage = Symbol('nrpc.nanomessage');
const kOnmessage = Symbol('nrpc.onmessage');
const kSubscribe = Symbol('nrpc.subscribe');
const kActions = Symbol('nrpc.actions');
const kEmittery = Symbol('nrpc.emittery');
const kFastCheckOpen = Symbol('nrpc.fastcheckopen');
const kCreateRequest = Symbol('nrpc.createrequest');

const noop = () => {};

class NanomessageRPC extends NanoresourcePromise {
  constructor(opts = {}) {
    super();
    const {
      onError = () => {},
      valueEncoding,
      send,
      subscribe,
      open = noop,
      close = noop,
      ...nanomessageOpts
    } = opts;
    assert(send, 'send is required');
    assert(subscribe, 'subscribe is required');
    this.ee = new EventEmitter();
    this[kNanomessage] = nanomessage({ ...nanomessageOpts,
      send: send.bind(this),
      open: open.bind(this),
      close: close.bind(this),
      onMessage: this[kOnmessage].bind(this),
      subscribe: this[kSubscribe](subscribe),
      valueEncoding: new Codec(valueEncoding)
    });
    this[kEmittery] = new Emittery();
    this[kActions] = new Map();
    this._onError = onError;
    this.ee.on('error', err => {
      this._onError(err);
    });
  }

  get requests() {
    return this[kNanomessage].requests;
  }

  get inflightRequests() {
    return this[kNanomessage].inflightRequests;
  }

  get requestTimeout() {
    return this[kNanomessage].timeout;
  }

  get concurrency() {
    return this[kNanomessage].concurrency;
  }

  setRequestsTimeout(timeout) {
    this[kNanomessage].setRequestsTimeout(timeout);
  }

  setConcurrency(concurrency) {
    this[kNanomessage].setConcurrency(concurrency);
  }

  onError(cb) {
    this._onError = cb;
  }

  action(name, handler) {
    this[kActions].set(name, handler);
    return this;
  }

  actions(actions) {
    Object.keys(actions).forEach(name => this.action(name, actions[name]));
    return this;
  }

  call(name, data, opts = {}) {
    return this[kCreateRequest]({
      name,
      data
    }, opts);
  }

  emit(name, data, opts = {}) {
    return this[kCreateRequest]({
      name,
      data,
      event: true
    }, opts);
  }

  on(...args) {
    return this[kEmittery].on(...args);
  }

  once(...args) {
    return this[kEmittery].once(...args);
  }

  off(...args) {
    return this[kEmittery].off(...args);
  }

  events(name) {
    return this[kEmittery].events(name);
  }

  async _open() {
    await this[kNanomessage].open();
    this.ee.emit('opened');
  }

  async _close() {
    await this[kNanomessage].close();
    this.ee.emit('closed');
  }

  async [kFastCheckOpen]() {
    if (this.closed || this.closing) throw new NRPC_ERR_CLOSE();
    if (this.opening) return this.open();
    if (!this.opened) throw new NRPC_ERR_NOT_OPEN();
  }

  [kSubscribe](subscribe) {
    return next => {
      subscribe(data => {
        try {
          next(data);
        } catch (err) {
          process.nextTick(() => this.ee.emit('error', err));
        }
      });
    };
  }

  [kCreateRequest](packet, {
    timeout,
    signal,
    wait = true
  }) {
    assert(packet.name && typeof packet.name === 'string', 'name is required');

    if (packet.event && !wait) {
      return this[kFastCheckOpen]().then(() => this[kNanomessage].send(packet));
    }

    let errCanceled;
    let request;
    const promise = this[kFastCheckOpen]().then(() => {
      if (errCanceled) throw errCanceled;
      request = this[kNanomessage].request(packet, {
        timeout,
        signal
      });
      this.ee.emit('request-created', request, packet);
      return request;
    }).then(result => {
      if (result.error) {
        const {
          code,
          unformatMessage,
          args,
          stack
        } = result.data;
        const ErrorDecoded = decodeError(code, unformatMessage);
        const err = new ErrorDecoded(...args);
        err.stack = stack || err.stack;
        throw err;
      } else {
        return result.data;
      }
    });

    promise.cancel = err => {
      if (!err) {
        errCanceled = new NRPC_ERR_REQUEST_CANCELED('request canceled');
      } else if (typeof err === 'string') {
        errCanceled = new NRPC_ERR_REQUEST_CANCELED(err);
      }

      if (request) return request.cancel(errCanceled);
      errCanceled = err;
    };

    return promise;
  }

  async [kOnmessage](message) {
    this.ee.emit('message', message);

    try {
      if (message.event) {
        await this[kEmittery].emit(message.name, message.data);
        return {
          data: null
        };
      }

      const action = this[kActions].get(message.name);

      if (!action) {
        return encodeError(new NRPC_ERR_NAME_MISSING(message.name));
      }

      const result = await action(message.data);
      return {
        data: result
      };
    } catch (err) {
      if (err.isNanoerror) {
        return encodeError(err);
      }

      const rErr = new NRPC_ERR_RESPONSE_ERROR(err.message);
      rErr.stack = err.stack || rErr.stack;
      return encodeError(rErr);
    }
  }

}

module.exports = NanomessageRPC;

}).call(this)}).call(this,require('_process'))
},{"./codec":328,"./errors":329,"_process":380,"emittery":166,"events":172,"nanocustomassert":320,"nanomessage":332,"nanoresource-promise":326}],331:[function(require,module,exports){
(function (process){(function (){
const eos = require('end-of-stream');

function useSocket(socket, onCloseDestroyStream = true) {
  return {
    send(buf) {
      if (socket.destroyed) return;
      socket.write(buf);
    },

    subscribe(next) {
      socket.on('data', next);
      return () => socket.removeListener('data', next);
    },

    open() {
      eos(socket, () => {
        this.close().catch(err => process.nextTick(() => this.ee.emit('error', err)));
      });
    },

    close() {
      return new Promise(resolve => {
        if (socket.destroyed || !onCloseDestroyStream) return resolve();
        eos(socket, () => resolve());
        socket.destroy();
      });
    }

  };
}

module.exports = useSocket;

}).call(this)}).call(this,require('_process'))
},{"_process":380,"end-of-stream":168}],332:[function(require,module,exports){
const Nanomessage = require("./src/nanomessage");

const nanomessage = opts => new Nanomessage(opts);

nanomessage.Nanomessage = Nanomessage;
nanomessage.errors = require("./src/errors");
nanomessage.BJSON = require("./src/buffer-json");
module.exports = nanomessage;

},{"./src/buffer-json":336,"./src/errors":338,"./src/nanomessage":340}],333:[function(require,module,exports){
const {
  EventEmitter
} = require('events');

const nanoresource = require('.');

const kNanoresource = Symbol('nanoresource');

class NanoresourcePromise extends EventEmitter {
  constructor(opts = {}) {
    super();
    this[kNanoresource] = nanoresource({
      open: opts.open || this._open.bind(this),
      close: opts.close || this._close.bind(this),
      reopen: opts.reopen
    });
  }

  get opened() {
    return this[kNanoresource].opened;
  }

  get opening() {
    return this[kNanoresource].opening;
  }

  get closed() {
    return this[kNanoresource].closed;
  }

  get closing() {
    return this[kNanoresource].closing;
  }

  get actives() {
    return this[kNanoresource].actives;
  }
  /**
   * @returns {Promise}
   */


  async open() {
    await this[kNanoresource].open();
    this.emit('opened');
  }
  /**
   * @returns {Promise}
   */


  async close(allowActive) {
    await this[kNanoresource].close(allowActive);
    this.emit('closed');
  }
  /**
   * @returns {boolean}
   */


  active(cb) {
    return this[kNanoresource].active(cb);
  }
  /**
   * @returns {boolean}
   */


  inactive(cb, err, value) {
    return this[kNanoresource].inactive(cb, err, value);
  }
  /**
   * @abstract
   */


  async _open() {}
  /**
   * @abstract
   */


  async _close() {}

}

module.exports = opts => new NanoresourcePromise(opts);

module.exports.NanoresourcePromise = NanoresourcePromise;

},{".":334,"events":172}],334:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"./nanoresource-cb":335,"dup":326}],335:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"_process":380,"dup":327}],336:[function(require,module,exports){
(function (Buffer){(function (){
function iterate(x, decode) {
  if (typeof x !== 'object') {
    if (decode && Object.prototype.toString.call(x) === '[object String]' && x.startsWith('base64:')) {
      return Buffer.from(x.slice('base64:'.length), 'base64');
    }

    return x;
  }

  let k;
  let tmp;
  const type = Object.prototype.toString.call(x);

  if (!decode && type === '[object Uint8Array]' && Buffer.isBuffer(x)) {
    return 'base64:' + Buffer.from(x).toString('base64');
  }

  if (type === '[object Object]') {
    tmp = {};

    for (k in x) {
      tmp[k] = iterate(x[k], decode);
    }

    return tmp;
  }

  if (type === '[object Array]') {
    k = x.length;

    for (tmp = Array(k); k--;) {
      tmp[k] = iterate(x[k], decode);
    }

    return tmp;
  }

  return x;
}

module.exports = {
  _lastObj: null,
  _lastStr: null,
  _lastLength: null,

  encode(obj, buf, offset) {
    let str;
    let length;

    if (this._lastObj === obj) {
      str = this._lastStr;
      length = this._lastLength;
    } else {
      str = JSON.stringify(iterate({
        data: obj
      }));
      length = Buffer.byteLength(str, 'utf8');
    }

    buf.write(str, offset, length, 'utf8');
    this._lastObj = null;
    this._lastStr = null;
    this._lastLength = null;
    return buf.slice(offset, offset + length);
  },

  decode(buf, start, end) {
    start = start || 0;
    end = end || buf.length;
    return iterate(JSON.parse(buf.slice(start, end)), true).data;
  },

  encodingLength(obj) {
    this._lastObj = obj;
    this._lastStr = JSON.stringify(iterate({
      data: obj
    }));
    this._lastLength = Buffer.byteLength(this._lastStr, 'utf8');
    return this._lastLength;
  }

};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],337:[function(require,module,exports){
(function (Buffer){(function (){
const varint = require('varint');

const BJSON = require("./buffer-json");

const {
  NMSG_ERR_ENCODE,
  NMSG_ERR_DECODE
} = require("./errors");

const ATTR_RESPONSE = 1;

module.exports = function createCodec(valueEncoding = BJSON) {
  return {
    encode(info) {
      try {
        let header = info.id << 1;
        if (info.response) header = header | ATTR_RESPONSE;
        const dataLength = valueEncoding.encodingLength(info.data);
        const buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength);
        let offset = 0;
        varint.encode(header, buf, offset);
        offset += varint.encode.bytes;
        varint.encode(dataLength, buf, offset);
        offset += varint.encode.bytes;
        valueEncoding.encode(info.data, buf, offset);
        return buf;
      } catch (err) {
        throw new NMSG_ERR_ENCODE(err.message);
      }
    },

    decode(buf) {
      try {
        const request = {};
        let offset = 0;
        const header = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        const dataLength = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        request.data = valueEncoding.decode(buf, offset, offset + dataLength);
        request.response = !!(header & ATTR_RESPONSE);
        request.id = header >> 1;
        return request;
      } catch (err) {
        throw new NMSG_ERR_DECODE(err.message);
      }
    }

  };
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./buffer-json":336,"./errors":338,"buffer":97,"varint":582}],338:[function(require,module,exports){
const nanoerror = require('nanoerror');

const errors = {};

function createError(code, message) {
  errors[code] = nanoerror(code, message);
}

createError('NMSG_ERR_TIMEOUT', 'timeout on request: %s');
createError('NMSG_ERR_ENCODE', 'error encoding the request: %s');
createError('NMSG_ERR_DECODE', 'error decoding the request: %s');
createError('NMSG_ERR_RESPONSE', 'response error on request: %s');
createError('NMSG_ERR_CLOSE', 'nanomessage was closed');
createError('NMSG_ERR_NOT_OPEN', 'nanomessage is not open');
createError('NMSG_ERR_CANCEL', 'request canceled: %s');
module.exports = errors;

},{"nanoerror":321}],339:[function(require,module,exports){
module.exports = class IdGenerator {
  constructor(generate) {
    this._generate = generate;
    this._free = [];
  }

  get() {
    if (!this._free.length) {
      return this._generate();
    }

    return this._free.pop();
  }

  release(id) {
    this._free.push(id);
  }

};

},{}],340:[function(require,module,exports){
const assert = require('nanocustomassert');

const {
  NanoresourcePromise
} = require('nanoresource-promise/emitter');

const fastq = require('fastq');

const Request = require("./request");

const createCodec = require("./codec");

const {
  NMSG_ERR_CLOSE,
  NMSG_ERR_NOT_OPEN,
  NMSG_ERR_RESPONSE
} = require("./errors");

const IdGenerator = require("./id-generator");

const kRequests = Symbol('nanomessage.requests');
const kInQueue = Symbol('nanomessage.inqueue');
const kOutQueue = Symbol('nanomessage.outqueue');
const kUnsubscribe = Symbol('nanomessage.unsubscribe');
const kMessageHandler = Symbol('nanomessage.messagehandler');
const kOpen = Symbol('nanomessage.open');
const kClose = Symbol('nanomessage.close');
const kFastCheckOpen = Symbol('nanomessage.fastcheckopen');
const kTimeout = Symbol('nanomessage.timeout');
const kIdGenerator = Symbol('nanomessage.idgenerator');
const kCodec = Symbol('nanomessage.codec');

function inWorker(info, done) {
  this[kFastCheckOpen]().then(() => this._onMessage(info.data, info)).then(data => {
    if (this.closed || this.closing) return done();
    info.responseData = data;
    return this._send(this[kCodec].encode({
      id: info.id,
      response: info.response,
      data
    }), info);
  }).then(() => done()).catch(err => done(err));
}

function outWorker(request, done) {
  const info = request.info();
  this[kFastCheckOpen]().then(() => {
    if (request.finished) return;
    request.start();
    return this._send(this[kCodec].encode(info), info);
  }).then(() => {
    if (request.finished) return;
    return request.promise;
  }).then(data => done(null, data)).catch(err => done(err));
}

class Nanomessage extends NanoresourcePromise {
  /**
   * Creates an instance of Nanomessage.
   * @param {Object} [opts={}]
   * @param {(buf: Buffer, info: Object) => Promise|undefined} [opts.send]
   * @param {function} [opts.subscribe]
   * @param {(data: Object, info: Object) => Promise<*>} [opts.onMessage]
   * @param {function} [opts.open]
   * @param {function} [opts.close]
   * @param {number} [opts.timeout]
   * @param {Object} [opts.valueEncoding]
   * @param {({ incoming: number, outgoing: number }|number)} [opts.concurrency]
   * @memberof Nanomessage
   */
  constructor(opts = {}) {
    super();
    const {
      send,
      subscribe,
      onMessage,
      open,
      close,
      timeout,
      valueEncoding,
      concurrency = 256
    } = opts;
    if (send) this._send = send;
    if (subscribe) this._subscribe = subscribe;
    if (onMessage) this.setMessageHandler(onMessage);
    if (open) this[kOpen] = open;
    if (close) this[kClose] = close;
    this.setRequestTimeout(timeout);
    this[kCodec] = createCodec(valueEncoding);
    this[kInQueue] = fastq(this, inWorker, 1);
    this[kOutQueue] = fastq(this, outWorker, 1);
    this.setConcurrency(concurrency);
    this[kRequests] = new Map();
    this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1);
  }
  /**
   * @readonly
   * @type {Object}
   */


  get codec() {
    return this[kCodec];
  }
  /**
   * @readonly
   * @type {Array<Request>}
   */


  get requests() {
    return Array.from(this[kRequests].values());
  }
  /**
   * @readonly
   * @type {number}
   */


  get inflightRequests() {
    return this[kOutQueue].running();
  }
  /**
   * @readonly
   * @type {number}
   */


  get requestTimeout() {
    return this[kTimeout];
  }
  /**
   * @readonly
   * @type {Object}
   */


  get concurrency() {
    return {
      incoming: this[kInQueue].concurrency,
      outgoing: this[kOutQueue].concurrency
    };
  }
  /**
   * @param {number} timeout
   * @returns {Nanomessage}
   */


  setRequestTimeout(timeout) {
    this[kTimeout] = timeout;
    return this;
  }
  /**
   * @param {({ incoming: number, outgoing: number }|number)} value
   * @returns {Nanomessage}
   */


  setConcurrency(value) {
    if (typeof value === 'number') {
      this[kInQueue].concurrency = value;
      this[kOutQueue].concurrency = value;
    } else {
      this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency;
      this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency;
    }

    return this;
  }
  /**
   * Send a request and wait for the response.
   *
   * @param {*} data
   * @param {Object} [opts]
   * @param {number} [opts.timeout]
   * @param {AbortSignal} [opts.signal]
   * @returns {Promise<*>}
   */


  request(data, opts = {}) {
    const request = new Request({
      id: this[kIdGenerator].get(),
      data,
      timeout: opts.timeout || this[kTimeout],
      signal: opts.signal
    });
    const info = request.info();
    this[kRequests].set(request.id, request);
    request.onFinish(() => {
      this[kRequests].delete(request.id);
      this[kIdGenerator].release(request.id);
    });
    this.emit('request-created', info);
    this[kOutQueue].push(request, (err, data) => {
      info.response = true;
      info.responseData = data;
      this.emit('request-ended', err, info);
    });
    return request.promise;
  }
  /**
   * Send a ephemeral message.
   *
   * @param {*} data
   * @returns {Promise}
   */


  send(data) {
    return this[kFastCheckOpen]().then(() => {
      const info = Request.info({
        id: 0,
        data
      });
      return this._send(this[kCodec].encode(info), info);
    });
  }
  /**
   * @param {(data: Object, info: Object) => Promise<*>} onMessage
   * @returns {Nanomessage}
   */


  setMessageHandler(onMessage) {
    this._onMessage = onMessage;
    return this;
  }
  /**
   * @abstract
   * @param {Buffer} buf
   * @param {Object} info
   * @returns {Promise|undefined}
   */


  async _send(buf, info) {
    throw new Error('_send not implemented');
  }
  /**
   * @abstract
   * @param {Object} data
   * @param {Object} info
   * @returns {Promise<*>}
   */


  async _onMessage(data, info) {
    throw new Error('_onMessage not implemented');
  }

  async _open() {
    assert(!!this._subscribe, 'subscribe is required');
    await (this[kOpen] && this[kOpen]());
    this[kUnsubscribe] = this._subscribe(this[kMessageHandler].bind(this));
  }

  async _close() {
    if (this[kUnsubscribe]) this[kUnsubscribe]();
    const requestsToClose = [];
    this[kRequests].forEach(request => request.reject(new NMSG_ERR_CLOSE()));
    this[kRequests].clear();
    this[kInQueue] && this[kInQueue].kill();
    this[kOutQueue] && this[kOutQueue].kill();
    await (this[kClose] && this[kClose]());
    await Promise.all(requestsToClose);
  }

  async [kFastCheckOpen]() {
    if (this.closed || this.closing) throw new NMSG_ERR_CLOSE();
    if (this.opening) return this.open();
    if (!this.opened) throw new NMSG_ERR_NOT_OPEN();
  }

  [kMessageHandler](message) {
    if (this.closed || this.closing) return;
    const info = Request.info(this[kCodec].decode(message)); // resolve response

    if (info.response) {
      const request = this[kRequests].get(info.id);
      if (request) request.resolve(info.data);
      return;
    }

    if (info.ephemeral) {
      this.emit('request-received', info);
      this[kFastCheckOpen]().then(() => this._onMessage(info.data, info)).catch(err => {
        const rErr = new NMSG_ERR_RESPONSE(err.message);
        rErr.stack = err.stack || rErr.stack;
        this.emit('response-error', rErr, info);
      });
      return;
    }

    info.response = true;
    this.emit('request-received', info);
    this[kInQueue].push(info, err => {
      if (err) {
        const rErr = new NMSG_ERR_RESPONSE(err.message);
        rErr.stack = err.stack || rErr.stack;
        this.emit('response-error', rErr, info);
      }
    });
  }

}

module.exports = Nanomessage;

},{"./codec":337,"./errors":338,"./id-generator":339,"./request":341,"fastq":177,"nanocustomassert":320,"nanoresource-promise/emitter":333}],341:[function(require,module,exports){
(function (process){(function (){
const {
  NMSG_ERR_CANCEL,
  NMSG_ERR_TIMEOUT
} = require("./errors");

class Request {
  static info(obj = {}) {
    return {
      id: obj.id,
      data: obj.data,
      response: obj.response || false,
      ephemeral: obj.id === 0
    };
  }

  constructor(info) {
    const {
      id,
      data,
      response = false,
      timeout,
      signal
    } = info;
    this.id = id;
    this.data = data;
    this.response = response;
    this.finished = false;
    this.timeout = timeout;
    this.timer = null;

    let _resolve, _reject;

    this.promise = new Promise((resolve, reject) => {
      _resolve = resolve;
      _reject = reject;
    });
    this.promise.cancel = this.cancel.bind(this);

    const onAbort = () => this.cancel();

    if (signal) {
      if (signal.aborted) {
        process.nextTick(onAbort);
      } else {
        signal.addEventListener('abort', onAbort);
      }
    }

    this.resolve = data => {
      if (!this.finished) {
        this.timer && clearTimeout(this.timer);
        signal && signal.removeEventListener('abort', onAbort);
        this.finished = true;

        this._onFinish();

        _resolve(data);
      }
    };

    this.reject = err => {
      if (!this.finished) {
        this.timer && clearTimeout(this.timer);
        signal && signal.removeEventListener('abort', onAbort);
        this.finished = true;

        this._onFinish(err);

        _reject(err);
      }
    };
  }

  start() {
    if (this.timeout) {
      this.timer = setTimeout(() => {
        this.reject(new NMSG_ERR_TIMEOUT(this.id));
      }, this.timeout);
    }
  }

  onFinish(cb) {
    this._onFinish = cb;
  }

  cancel(err) {
    if (!err) {
      err = new NMSG_ERR_CANCEL(this.id);
    } else if (typeof err === 'string') {
      err = new NMSG_ERR_CANCEL(this.id, err);
    }

    this.reject(err);
  }

  info() {
    return Request.info(this);
  }

}

module.exports = Request;

}).call(this)}).call(this,require('_process'))
},{"./errors":338,"_process":380}],342:[function(require,module,exports){
const {
  EventEmitter
} = require('events');

const nanoresource = require('.');

const kNanoresource = Symbol('nanosignal.nanoresource');

class NanoresourcePromise extends EventEmitter {
  constructor(opts = {}) {
    super();
    this[kNanoresource] = nanoresource({
      open: opts.open || this._open.bind(this),
      close: opts.close || this._close.bind(this)
    });
  }

  get opened() {
    return this[kNanoresource].opened;
  }

  get opening() {
    return this[kNanoresource].opening;
  }

  get closed() {
    return this[kNanoresource].closed;
  }

  get closing() {
    return this[kNanoresource].closing;
  }

  get actives() {
    return this[kNanoresource].actives;
  }
  /**
   * @returns {Promise}
   */


  async open() {
    await this[kNanoresource].open();
    this.emit('opened');
  }
  /**
   * @returns {Promise}
   */


  async close(allowActive) {
    await this[kNanoresource].close(allowActive);
    this.emit('closed');
  }
  /**
   * @returns {Promise}
   */


  active() {
    return this[kNanoresource].active();
  }
  /**
   * @returns {Promise}
   */


  inactive(err, value) {
    return this[kNanoresource].inactive(err, value);
  }
  /**
   * @abstract
   */


  async _open() {}
  /**
   * @abstract
   */


  async _close() {}

}

module.exports = opts => new NanoresourcePromise(opts);

module.exports.NanoresourcePromise = NanoresourcePromise;

},{".":343,"events":172}],343:[function(require,module,exports){
const nanoresource = require('nanoresource');

function callbackPromise() {
  let callback;
  const promise = new Promise((resolve, reject) => {
    callback = (err, value) => {
      if (err) reject(err);else resolve(value);
    };
  });
  callback.promise = promise;
  return callback;
}

const kProcessPromise = Symbol('processpromise');

class NanoresourcePromise extends nanoresource {
  constructor(opts) {
    super(opts);

    const prevOpen = this._open.bind(this);

    const prevClose = this._close.bind(this);

    this._open = cb => this[kProcessPromise](prevOpen, cb);

    this._close = cb => this[kProcessPromise](prevClose, cb);
  }
  /**
   * @returns {Promise}
   */


  open() {
    const callback = callbackPromise();
    super.open(callback);
    return callback.promise;
  }
  /**
   * @returns {Promise}
   */


  close(allowActive = false) {
    let callback;

    if (typeof allowActive === 'function') {
      callback = allowActive;
      allowActive = false;
    } else {
      callback = callbackPromise();
    }

    super.close(allowActive, callback);
    return callback.promise;
  }
  /**
   * @returns {Promise}
   */


  active() {
    const callback = nanoresource.callbackPromise();
    super.active(callback);
    return callback.promise;
  }
  /**
   * @returns {Promise}
   */


  inactive(err, val) {
    const callback = nanoresource.callbackPromise();
    super.inactive(callback, err, val);
    return callback.promise;
  }

  async _open() {}

  async _close() {}

  async [kProcessPromise](fnPromise, cb) {
    try {
      await fnPromise();
      cb();
    } catch (err) {
      cb(err);
    }
  }

}

module.exports = opts => new NanoresourcePromise(opts);

module.exports.NanoresourcePromise = NanoresourcePromise;

},{"nanoresource":345}],344:[function(require,module,exports){
(function (process){(function (){
// Copy of index.js that extends from EventEmitter
const events = require('events');

const inherits = require('inherits');

const opening = Symbol('opening queue');
const preclosing = Symbol('closing when inactive');
const closing = Symbol('closing queue');
const sync = Symbol('sync');
const fastClose = Symbol('fast close');
module.exports = Nanoresource;

function Nanoresource(opts) {
  if (!(this instanceof Nanoresource)) return new Nanoresource(opts);
  events.EventEmitter.call(this);
  if (!opts) opts = {};
  if (opts.open) this._open = opts.open;
  if (opts.close) this._close = opts.close;
  this.opening = false;
  this.opened = false;
  this.closing = false;
  this.closed = false;
  this.actives = 0;
  this[opening] = null;
  this[preclosing] = null;
  this[closing] = null;
  this[sync] = false;
  this[fastClose] = true;
}

inherits(Nanoresource, events.EventEmitter);

Nanoresource.prototype._open = function (cb) {
  cb(null);
};

Nanoresource.prototype._close = function (cb) {
  cb(null);
};

Nanoresource.prototype.open = function (cb) {
  if (!cb) cb = noop;
  if (this[closing] || this.closed) return process.nextTick(cb, new Error('Resource is closed'));
  if (this.opened) return process.nextTick(cb);

  if (this[opening]) {
    this[opening].push(cb);
    return;
  }

  this.opening = true;
  this[opening] = [cb];
  this[sync] = true;

  this._open(onopen.bind(this));

  this[sync] = false;
};

Nanoresource.prototype.active = function (cb) {
  if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
    if (cb) process.nextTick(cb, new Error('Resource is closed'));
    return false;
  }

  this.actives++;
  return true;
};

Nanoresource.prototype.inactive = function (cb, err, val) {
  if (! --this.actives) {
    const queue = this[preclosing];

    if (queue) {
      this[preclosing] = null;

      while (queue.length) this.close(queue.shift());
    }
  }

  if (cb) cb(err, val);
};

Nanoresource.prototype.close = function (allowActive, cb) {
  if (typeof allowActive === 'function') return this.close(false, allowActive);
  if (!cb) cb = noop;
  if (allowActive) this[fastClose] = false;
  if (this.closed) return process.nextTick(cb);

  if (this.actives || this[opening]) {
    if (!this[preclosing]) this[preclosing] = [];
    this[preclosing].push(cb);
    return;
  }

  if (!this.opened) {
    this.closed = true;
    process.nextTick(cb);
    return;
  }

  if (this[closing]) {
    this[closing].push(cb);
    return;
  }

  this.closing = true;
  this[closing] = [cb];
  this[sync] = true;

  this._close(onclose.bind(this));

  this[sync] = false;
};

function onopen(err) {
  if (this[sync]) return process.nextTick(onopen.bind(this), err);
  const oqueue = this[opening];
  this[opening] = null;
  this.opening = false;
  this.opened = !err;

  while (oqueue.length) oqueue.shift()(err);

  const cqueue = this[preclosing];

  if (cqueue && !this.actives) {
    this[preclosing] = null;

    while (cqueue.length) this.close(cqueue.shift());
  }
}

function onclose(err) {
  if (this[sync]) return process.nextTick(onclose.bind(this), err);
  const queue = this[closing];
  this.closing = false;
  this[closing] = null;
  this.closed = !err;

  while (queue.length) queue.shift()(err);
}

function noop() {}

}).call(this)}).call(this,require('_process'))
},{"_process":380,"events":172,"inherits":279}],345:[function(require,module,exports){
(function (process){(function (){
const opening = Symbol('opening queue');
const preclosing = Symbol('closing when inactive');
const closing = Symbol('closing queue');
const sync = Symbol('sync');
const fastClose = Symbol('fast close');
module.exports = Nanoresource;

function Nanoresource(opts) {
  if (!(this instanceof Nanoresource)) return new Nanoresource(opts);
  if (!opts) opts = {};
  if (opts.open) this._open = opts.open;
  if (opts.close) this._close = opts.close;
  this.opening = false;
  this.opened = false;
  this.closing = false;
  this.closed = false;
  this.actives = 0;
  this[opening] = null;
  this[preclosing] = null;
  this[closing] = null;
  this[sync] = false;
  this[fastClose] = true;
}

Nanoresource.prototype._open = function (cb) {
  cb(null);
};

Nanoresource.prototype._close = function (cb) {
  cb(null);
};

Nanoresource.prototype.open = function (cb) {
  if (!cb) cb = noop;
  if (this[closing] || this.closed) return process.nextTick(cb, new Error('Resource is closed'));
  if (this.opened) return process.nextTick(cb);

  if (this[opening]) {
    this[opening].push(cb);
    return;
  }

  this.opening = true;
  this[opening] = [cb];
  this[sync] = true;

  this._open(onopen.bind(this));

  this[sync] = false;
};

Nanoresource.prototype.active = function (cb) {
  if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
    if (cb) process.nextTick(cb, new Error('Resource is closed'));
    return false;
  }

  this.actives++;
  return true;
};

Nanoresource.prototype.inactive = function (cb, err, val) {
  if (! --this.actives) {
    const queue = this[preclosing];

    if (queue) {
      this[preclosing] = null;

      while (queue.length) this.close(queue.shift());
    }
  }

  if (cb) cb(err, val);
};

Nanoresource.prototype.close = function (allowActive, cb) {
  if (typeof allowActive === 'function') return this.close(false, allowActive);
  if (!cb) cb = noop;
  if (allowActive) this[fastClose] = false;
  if (this.closed) return process.nextTick(cb);

  if (this.actives || this[opening]) {
    if (!this[preclosing]) this[preclosing] = [];
    this[preclosing].push(cb);
    return;
  }

  if (!this.opened) {
    this.closed = true;
    process.nextTick(cb);
    return;
  }

  if (this[closing]) {
    this[closing].push(cb);
    return;
  }

  this.closing = true;
  this[closing] = [cb];
  this[sync] = true;

  this._close(onclose.bind(this));

  this[sync] = false;
};

function onopen(err) {
  if (this[sync]) return process.nextTick(onopen.bind(this), err);
  const oqueue = this[opening];
  this[opening] = null;
  this.opening = false;
  this.opened = !err;

  while (oqueue.length) oqueue.shift()(err);

  const cqueue = this[preclosing];

  if (cqueue && !this.actives) {
    this[preclosing] = null;

    while (cqueue.length) this.close(cqueue.shift());
  }
}

function onclose(err) {
  if (this[sync]) return process.nextTick(onclose.bind(this), err);
  const queue = this[closing];
  this.closing = false;
  this[closing] = null;
  this.closed = !err;

  while (queue.length) queue.shift()(err);
}

function noop() {}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],346:[function(require,module,exports){
(function (process,setImmediate){(function (){
'use strict';

var ensureCallable = function (fn) {
  if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
  return fn;
};

var byObserver = function (Observer) {
  var node = document.createTextNode(''),
      queue,
      currentQueue,
      i = 0;
  new Observer(function () {
    var callback;

    if (!queue) {
      if (!currentQueue) return;
      queue = currentQueue;
    } else if (currentQueue) {
      queue = currentQueue.concat(queue);
    }

    currentQueue = queue;
    queue = null;

    if (typeof currentQueue === 'function') {
      callback = currentQueue;
      currentQueue = null;
      callback();
      return;
    }

    node.data = i = ++i % 2; // Invoke other batch, to handle leftover callbacks in case of crash

    while (currentQueue) {
      callback = currentQueue.shift();
      if (!currentQueue.length) currentQueue = null;
      callback();
    }
  }).observe(node, {
    characterData: true
  });
  return function (fn) {
    ensureCallable(fn);

    if (queue) {
      if (typeof queue === 'function') queue = [queue, fn];else queue.push(fn);
      return;
    }

    queue = fn;
    node.data = i = ++i % 2;
  };
};

module.exports = function () {
  // Node.js
  if (typeof process === 'object' && process && typeof process.nextTick === 'function') {
    return process.nextTick;
  } // queueMicrotask


  if (typeof queueMicrotask === "function") {
    return function (cb) {
      queueMicrotask(ensureCallable(cb));
    };
  } // MutationObserver


  if (typeof document === 'object' && document) {
    if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
    if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
  } // W3C Draft
  // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html


  if (typeof setImmediate === 'function') {
    return function (cb) {
      setImmediate(ensureCallable(cb));
    };
  } // Wide available standard


  if (typeof setTimeout === 'function' || typeof setTimeout === 'object') {
    return function (cb) {
      setTimeout(ensureCallable(cb), 0);
    };
  }

  return null;
}();

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":380,"timers":571}],347:[function(require,module,exports){
(function (process){(function (){
var fs = require('fs');

var path = require('path');

var os = require('os'); // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'


var runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require; // eslint-disable-line

var vars = process.config && process.config.variables || {};
var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
var abi = process.versions.modules; // TODO: support old node where this is undef

var runtime = isElectron() ? 'electron' : 'node';
var arch = os.arch();
var platform = os.platform();
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
var uv = (process.versions.uv || '').split('.')[0];
module.exports = load;

function load(dir) {
  return runtimeRequire(load.path(dir));
}

load.path = function (dir) {
  dir = path.resolve(dir || '.');

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
    if (release) return release;
    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
    if (debug) return debug;
  }

  var prebuild = resolve(dir);
  if (prebuild) return prebuild;
  var nearby = resolve(path.dirname(process.execPath));
  if (nearby) return nearby;
  var target = ['platform=' + platform, 'arch=' + arch, 'runtime=' + runtime, 'abi=' + abi, 'uv=' + uv, armv ? 'armv=' + armv : '', 'libc=' + libc, 'node=' + process.versions.node, process.versions && process.versions.electron ? 'electron=' + process.versions.electron : '', typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line
  ].filter(Boolean).join(' ');
  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');

  function resolve(dir) {
    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', platform + '-' + arch);
    var parsed = readdirSync(prebuilds).map(parseTags);
    var candidates = parsed.filter(matchTags(runtime, abi));
    var winner = candidates.sort(compareTags(runtime))[0];
    if (winner) return path.join(prebuilds, winner.file);
  }
};

function readdirSync(dir) {
  try {
    return fs.readdirSync(dir);
  } catch (err) {
    return [];
  }
}

function getFirst(dir, filter) {
  var files = readdirSync(dir).filter(filter);
  return files[0] && path.join(dir, files[0]);
}

function matchBuild(name) {
  return /\.node$/.test(name);
}

function parseTags(file) {
  var arr = file.split('.');
  var extension = arr.pop();
  var tags = {
    file: file,
    specificity: 0
  };
  if (extension !== 'node') return;

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i];

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag;
    } else if (tag === 'napi') {
      tags.napi = true;
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3);
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2);
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4);
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag;
    } else {
      continue;
    }

    tags.specificity++;
  }

  return tags;
}

function matchTags(runtime, abi) {
  return function (tags) {
    if (tags == null) return false;
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
    if (tags.abi !== abi && !tags.napi) return false;
    if (tags.uv && tags.uv !== uv) return false;
    if (tags.armv && tags.armv !== armv) return false;
    if (tags.libc && tags.libc !== libc) return false;
    return true;
  };
}

function runtimeAgnostic(tags) {
  return tags.runtime === 'node' && tags.napi;
}

function compareTags(runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1;
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1;
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1;
    } else {
      return 0;
    }
  };
}

function isElectron() {
  if (process.versions && process.versions.electron) return true;
  if (process.env.ELECTRON_RUN_AS_NODE) return true;
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
}

function isAlpine(platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release');
} // Exposed for unit tests
// TODO: move to lib


load.parseTags = parseTags;
load.matchTags = matchTags;
load.compareTags = compareTags;

}).call(this)}).call(this,require('_process'))
},{"_process":380,"fs":91,"os":359,"path":371}],348:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  sodium_memzero
} = require('sodium-universal/memory');

const {
  sodium_increment,
  sodium_memcmp,
  sodium_is_zero
} = require('sodium-universal/helpers');

var assert = require('nanoassert');

var cipher = require("./cipher");

var STATELEN = cipher.KEYLEN + cipher.NONCELEN;
var NONCELEN = cipher.NONCELEN;
var MACLEN = cipher.MACLEN;
module.exports = {
  STATELEN,
  NONCELEN,
  MACLEN,
  initializeKey,
  hasKey,
  setNonce,
  encryptWithAd,
  decryptWithAd,
  rekey
};
var KEY_BEGIN = 0;
var KEY_END = cipher.KEYLEN;
var NONCE_BEGIN = KEY_END;
var NONCE_END = NONCE_BEGIN + cipher.NONCELEN;

function initializeKey(state, key) {
  assert(state.byteLength === STATELEN);
  assert(key == null ? true : key.byteLength === cipher.KEYLEN);

  if (key == null) {
    sodium_memzero(state.subarray(KEY_BEGIN, KEY_END));
    return;
  }

  state.set(key);
  sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END));
}

function hasKey(state) {
  assert(state.byteLength === STATELEN);
  var k = state.subarray(KEY_BEGIN, KEY_END);
  return sodium_is_zero(k) === false;
}

function setNonce(state, nonce) {
  assert(state.byteLength === STATELEN);
  assert(nonce.byteLength === NONCELEN);
  state.set(nonce, NONCE_BEGIN);
}

var maxnonce = new Uint8Array(8).fill(0xff);

function encryptWithAd(state, out, ad, plaintext) {
  assert(state.byteLength === STATELEN);
  assert(out.byteLength != null);
  assert(plaintext.byteLength != null);
  var n = state.subarray(NONCE_BEGIN, NONCE_END);
  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow');

  if (hasKey(state) === false) {
    out.set(plaintext);
    encryptWithAd.bytesRead = plaintext.byteLength;
    encryptWithAd.bytesWritten = encryptWithAd.bytesRead;
    return;
  }

  var k = state.subarray(KEY_BEGIN, KEY_END);
  cipher.encrypt(out, k, n, ad, plaintext);
  encryptWithAd.bytesRead = cipher.encrypt.bytesRead;
  encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten;
  sodium_increment(n);
}

encryptWithAd.bytesRead = 0;
encryptWithAd.bytesWritten = 0;

function decryptWithAd(state, out, ad, ciphertext) {
  assert(state.byteLength === STATELEN);
  assert(out.byteLength != null);
  assert(ciphertext.byteLength != null);
  var n = state.subarray(NONCE_BEGIN, NONCE_END);
  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow');

  if (hasKey(state) === false) {
    out.set(ciphertext);
    decryptWithAd.bytesRead = ciphertext.byteLength;
    decryptWithAd.bytesWritten = decryptWithAd.bytesRead;
    return;
  }

  var k = state.subarray(KEY_BEGIN, KEY_END);
  cipher.decrypt(out, k, n, ad, ciphertext);
  decryptWithAd.bytesRead = cipher.decrypt.bytesRead;
  decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten;
  sodium_increment(n);
}

decryptWithAd.bytesRead = 0;
decryptWithAd.bytesWritten = 0;

function rekey(state) {
  assert(state.byteLength === STATELEN);
  var k = state.subarray(KEY_BEGIN, KEY_END);
  cipher.rekey(k, k);
  rekey.bytesRead = cipher.rekey.bytesRead;
  rekey.bytesWritten = cipher.rekey.bytesWritten;
}

rekey.bytesRead = 0;
rekey.bytesWritten = 0;

},{"./cipher":349,"nanoassert":354,"sodium-universal/helpers":540,"sodium-universal/memory":544}],349:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  sodium_malloc,
  sodium_memzero
} = require('sodium-universal/memory');

const {
  crypto_aead_chacha20poly1305_ietf_KEYBYTES,
  crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
  crypto_aead_chacha20poly1305_ietf_ABYTES,
  crypto_aead_chacha20poly1305_ietf_encrypt,
  crypto_aead_chacha20poly1305_ietf_decrypt
} = require('sodium-universal/crypto_aead');

var assert = require('nanoassert');

var KEYLEN = 32;
var NONCELEN = 8;
var MACLEN = 16;
assert(crypto_aead_chacha20poly1305_ietf_KEYBYTES === KEYLEN); // 16 bytes are cut off in the following functions

assert(crypto_aead_chacha20poly1305_ietf_NPUBBYTES === 4 + NONCELEN);
assert(crypto_aead_chacha20poly1305_ietf_ABYTES === MACLEN);
module.exports = {
  KEYLEN,
  NONCELEN,
  MACLEN,
  encrypt,
  decrypt,
  rekey
};
var ElongatedNonce = sodium_malloc(crypto_aead_chacha20poly1305_ietf_NPUBBYTES);

function encrypt(out, k, n, ad, plaintext) {
  assert(out.byteLength >= plaintext.byteLength + MACLEN, 'output buffer must be at least plaintext plus MACLEN bytes long');
  assert(k.byteLength === KEYLEN);
  assert(n.byteLength === NONCELEN);
  assert(ad == null ? true : ad.byteLength != null);
  sodium_memzero(ElongatedNonce);
  ElongatedNonce.set(n, 4);
  encrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_encrypt(out.subarray(0, plaintext.byteLength + MACLEN), plaintext, ad, null, ElongatedNonce, k);
  encrypt.bytesRead = encrypt.bytesWritten - MACLEN;
  sodium_memzero(ElongatedNonce);
}

encrypt.bytesWritten = 0;
encrypt.bytesRead = 0;

function decrypt(out, k, n, ad, ciphertext) {
  assert(out.byteLength >= ciphertext.byteLength - MACLEN);
  assert(k.byteLength === KEYLEN);
  assert(n.byteLength === NONCELEN);
  assert(ad == null ? true : ad.byteLength != null);
  sodium_memzero(ElongatedNonce);
  ElongatedNonce.set(n, 4);
  decrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_decrypt(out.subarray(0, ciphertext.byteLength - MACLEN), null, ciphertext, ad, ElongatedNonce, k);
  decrypt.bytesRead = decrypt.bytesWritten + MACLEN;
  sodium_memzero(ElongatedNonce);
}

decrypt.bytesWritten = 0;
decrypt.bytesRead = 0;
var maxnonce = new Uint8Array(8).fill(0xff);
var zerolen = new Uint8Array(0);
var zeros = new Uint8Array(32);
var IntermediateKey = sodium_malloc(KEYLEN + MACLEN);
sodium_memzero(IntermediateKey);

function rekey(out, k) {
  assert(out.byteLength === KEYLEN);
  assert(k.byteLength === KEYLEN);
  sodium_memzero(IntermediateKey);
  IntermediateKey.set(k);
  encrypt(IntermediateKey, k, maxnonce, zerolen, zeros);
  rekey.bytesWritten = encrypt.bytesWritten;
  rekey.bytesRead = encrypt.bytesRead;
  out.set(IntermediateKey.subarray(0, KEYLEN));
  sodium_memzero(IntermediateKey);
}

rekey.bytesWritten = 0;
rekey.bytesRead = 0;

},{"nanoassert":354,"sodium-universal/crypto_aead":524,"sodium-universal/memory":544}],350:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  crypto_kx_SEEDBYTES,
  crypto_kx_keypair,
  crypto_kx_seed_keypair
} = require('sodium-universal/crypto_kx');

const {
  crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES,
  crypto_scalarmult
} = require('sodium-universal/crypto_scalarmult');

var assert = require('nanoassert');

var DHLEN = crypto_scalarmult_BYTES;
var PKLEN = crypto_scalarmult_BYTES;
var SKLEN = crypto_scalarmult_SCALARBYTES;
var SEEDLEN = crypto_kx_SEEDBYTES;
module.exports = {
  DHLEN,
  PKLEN,
  SKLEN,
  SEEDLEN,
  generateKeypair,
  generateSeedKeypair,
  dh
};

function generateKeypair(pk, sk) {
  assert(pk.byteLength === PKLEN);
  assert(sk.byteLength === SKLEN);
  crypto_kx_keypair(pk, sk);
}

function generateSeedKeypair(pk, sk, seed) {
  assert(pk.byteLength === PKLEN);
  assert(sk.byteLength === SKLEN);
  assert(seed.byteLength === SKLEN);
  crypto_kx_seed_keypair(pk, sk, seed);
}

function dh(output, lsk, pk) {
  assert(output.byteLength === DHLEN);
  assert(lsk.byteLength === SKLEN);
  assert(pk.byteLength === PKLEN);
  crypto_scalarmult(output, lsk, pk);
}

},{"nanoassert":354,"sodium-universal/crypto_kx":531,"sodium-universal/crypto_scalarmult":533}],351:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  sodium_malloc,
  sodium_memzero,
  sodium_free
} = require('sodium-universal/memory');

const assert = require('nanoassert');

const clone = require('clone');

const symmetricState = require("./symmetric-state");

const cipherState = require("./cipher-state");

const dh = require("./dh");

const PKLEN = dh.PKLEN;
const SKLEN = dh.SKLEN;
module.exports = Object.freeze({
  initialize,
  writeMessage,
  readMessage,
  destroy,
  keygen,
  seedKeygen,
  SKLEN,
  PKLEN
});

function HandshakeState() {
  this.symmetricState = sodium_malloc(symmetricState.STATELEN);
  this.initiator = null;
  this.spk = null;
  this.ssk = null;
  this.epk = null;
  this.esk = null;
  this.rs = null;
  this.re = null;
  this.messagePatterns = null;
}

const INITIATOR = Symbol('initiator');
const RESPONDER = Symbol('responder');
const TOK_S = Symbol('s');
const TOK_E = Symbol('e');
const TOK_ES = Symbol('es');
const TOK_SE = Symbol('se');
const TOK_EE = Symbol('ee');
const TOK_SS = Symbol('es'); // initiator, ->
// responder, <-

var PATTERNS = Object.freeze({
  N: {
    premessages: [[RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES]]
  },
  K: {
    premessages: [[INITIATOR, TOK_S], [RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_SS]]
  },
  X: {
    premessages: [[RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS]]
  },
  NN: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE]]
  },
  KN: {
    premessages: [[INITIATOR, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
  },
  NK: {
    premessages: [[RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES], [RESPONDER, TOK_E, TOK_EE]]
  },
  KK: {
    premessages: [[INITIATOR, TOK_S], [RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_SS], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
  },
  NX: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES]]
  },
  KX: {
    premessages: [[INITIATOR, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]]
  },
  XN: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE], [INITIATOR, TOK_S, TOK_SE]]
  },
  IN: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E, TOK_S], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
  },
  XK: {
    premessages: [[RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES], [RESPONDER, TOK_E, TOK_EE], [INITIATOR, TOK_S, TOK_SE]]
  },
  IK: {
    premessages: [[RESPONDER, TOK_S]],
    messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
  },
  XX: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES], [INITIATOR, TOK_S, TOK_SE]]
  },
  IX: {
    premessages: [],
    messagePatterns: [[INITIATOR, TOK_E, TOK_S], [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]]
  }
});

function sodiumBufferCopy(src) {
  var buf = sodium_malloc(src.byteLength);
  buf.set(src);
  return buf;
}

function initialize(handshakePattern, initiator, prologue, s, e, rs, re) {
  assert(Object.keys(PATTERNS).includes(handshakePattern), 'Unsupported handshake pattern');
  assert(typeof initiator === 'boolean', 'Initiator must be a boolean');
  assert(prologue.byteLength != null, 'prolouge must be a Buffer');
  assert(e == null ? true : e.publicKey.byteLength === dh.PKLEN, `e.publicKey must be ${dh.PKLEN} bytes`);
  assert(e == null ? true : e.secretKey.byteLength === dh.SKLEN, `e.secretKey must be ${dh.SKLEN} bytes`);
  assert(rs == null ? true : rs.byteLength === dh.PKLEN, `rs must be ${dh.PKLEN} bytes`);
  assert(re == null ? true : re.byteLength === dh.PKLEN, `re must be ${dh.PKLEN} bytes`);
  var state = new HandshakeState();
  var protocolName = Uint8Array.from(`Noise_${handshakePattern}_25519_ChaChaPoly_BLAKE2b`, toCharCode);
  symmetricState.initializeSymmetric(state.symmetricState, protocolName);
  symmetricState.mixHash(state.symmetricState, prologue);
  state.role = initiator === true ? INITIATOR : RESPONDER;

  if (s != null) {
    assert(s.publicKey.byteLength === dh.PKLEN, `s.publicKey must be ${dh.PKLEN} bytes`);
    assert(s.secretKey.byteLength === dh.SKLEN, `s.secretKey must be ${dh.SKLEN} bytes`);
    state.spk = sodiumBufferCopy(s.publicKey);
    state.ssk = sodiumBufferCopy(s.secretKey);
  }

  if (e != null) {
    assert(e.publicKey.byteLength === dh.PKLEN);
    assert(e.secretKey.byteLength === dh.SKLEN);
    state.epk = sodiumBufferCopy(e.publicKey);
    state.esk = sodiumBufferCopy(e.secretKey);
  }

  if (rs != null) {
    assert(rs.byteLength === dh.PKLEN);
    state.rs = sodiumBufferCopy(rs);
  }

  if (re != null) {
    assert(re.byteLength === dh.PKLEN);
    state.re = sodiumBufferCopy(re);
  } // hashing


  var pat = PATTERNS[handshakePattern];

  for (var pattern of clone(pat.premessages)) {
    var patternRole = pattern.shift();

    for (var token of pattern) {
      switch (token) {
        case TOK_E:
          assert(state.role === patternRole ? state.epk.byteLength != null : state.re.byteLength != null);
          symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.epk : state.re);
          break;

        case TOK_S:
          assert(state.role === patternRole ? state.spk.byteLength != null : state.rs.byteLength != null);
          symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.spk : state.rs);
          break;

        default:
          throw new Error('Invalid premessage pattern');
      }
    }
  }

  state.messagePatterns = clone(pat.messagePatterns);
  assert(state.messagePatterns.filter(p => p[0] === INITIATOR).some(p => p.includes(TOK_S)) ? state.spk !== null && state.ssk !== null : true, // Default if none is found
  'This handshake pattern requires a static keypair');
  return state;
}

var DhResult = sodium_malloc(dh.DHLEN);

function writeMessage(state, payload, messageBuffer) {
  assert(state instanceof HandshakeState);
  assert(payload.byteLength != null);
  assert(messageBuffer.byteLength != null);
  var mpat = state.messagePatterns.shift();
  var moffset = 0;
  assert(mpat != null);
  assert(state.role === mpat.shift());

  for (var token of mpat) {
    switch (token) {
      case TOK_E:
        assert(state.epk == null);
        assert(state.esk == null);
        state.epk = sodium_malloc(dh.PKLEN);
        state.esk = sodium_malloc(dh.SKLEN);
        dh.generateKeypair(state.epk, state.esk);
        messageBuffer.set(state.epk, moffset);
        moffset += state.epk.byteLength;
        symmetricState.mixHash(state.symmetricState, state.epk);
        break;

      case TOK_S:
        assert(state.spk.byteLength === dh.PKLEN);
        symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), state.spk);
        moffset += symmetricState.encryptAndHash.bytesWritten;
        break;

      case TOK_EE:
        dh.dh(DhResult, state.esk, state.re);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_ES:
        if (state.role === INITIATOR) dh.dh(DhResult, state.esk, state.rs);else dh.dh(DhResult, state.ssk, state.re);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_SE:
        if (state.role === INITIATOR) dh.dh(DhResult, state.ssk, state.re);else dh.dh(DhResult, state.esk, state.rs);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_SS:
        dh.dh(DhResult, state.ssk, state.rs);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      default:
        throw new Error('Invalid message pattern');
    }
  }

  symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), payload);
  moffset += symmetricState.encryptAndHash.bytesWritten;
  writeMessage.bytes = moffset;

  if (state.messagePatterns.length === 0) {
    var tx = sodium_malloc(cipherState.STATELEN);
    var rx = sodium_malloc(cipherState.STATELEN);
    symmetricState.split(state.symmetricState, tx, rx);
    return {
      tx,
      rx
    };
  }
}

writeMessage.bytes = 0;

function readMessage(state, message, payloadBuffer) {
  assert(state instanceof HandshakeState);
  assert(message.byteLength != null);
  assert(payloadBuffer.byteLength != null);
  var mpat = state.messagePatterns.shift();
  var moffset = 0;
  assert(mpat != null);
  assert(mpat.shift() !== state.role);

  for (var token of mpat) {
    switch (token) {
      case TOK_E:
        assert(state.re == null);
        assert(message.byteLength - moffset >= dh.PKLEN); // PKLEN instead of DHLEN since they are different in out case

        state.re = sodium_malloc(dh.PKLEN);
        state.re.set(message.subarray(moffset, moffset + dh.PKLEN));
        moffset += dh.PKLEN;
        symmetricState.mixHash(state.symmetricState, state.re);
        break;

      case TOK_S:
        assert(state.rs == null);
        state.rs = sodium_malloc(dh.PKLEN);
        var bytes = 0;

        if (symmetricState._hasKey(state.symmetricState)) {
          bytes = dh.PKLEN + 16;
        } else {
          bytes = dh.PKLEN;
        }

        assert(message.byteLength - moffset >= bytes);
        symmetricState.decryptAndHash(state.symmetricState, state.rs, message.subarray(moffset, moffset + bytes) // <- called temp in noise spec
        );
        moffset += symmetricState.decryptAndHash.bytesRead;
        break;

      case TOK_EE:
        dh.dh(DhResult, state.esk, state.re);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_ES:
        if (state.role === INITIATOR) dh.dh(DhResult, state.esk, state.rs);else dh.dh(DhResult, state.ssk, state.re);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_SE:
        if (state.role === INITIATOR) dh.dh(DhResult, state.ssk, state.re);else dh.dh(DhResult, state.esk, state.rs);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      case TOK_SS:
        dh.dh(DhResult, state.ssk, state.rs);
        symmetricState.mixKey(state.symmetricState, DhResult);
        sodium_memzero(DhResult);
        break;

      default:
        throw new Error('Invalid message pattern');
    }
  }

  symmetricState.decryptAndHash(state.symmetricState, payloadBuffer, message.subarray(moffset)); // How many bytes were written to payload (minus the TAG/MAC)

  readMessage.bytes = symmetricState.decryptAndHash.bytesWritten;

  if (state.messagePatterns.length === 0) {
    var tx = sodium_malloc(cipherState.STATELEN);
    var rx = sodium_malloc(cipherState.STATELEN);
    symmetricState.split(state.symmetricState, rx, tx);
    return {
      tx,
      rx
    };
  }
}

readMessage.bytes = 0;

function destroy(state) {
  if (state.symmetricState != null) {
    sodium_free(state.symmetricState);
    state.symmetricState = null;
  }

  state.role = null;

  if (state.spk != null) {
    sodium_free(state.spk);
    state.spk = null;
  }

  if (state.ssk != null) {
    sodium_free(state.ssk);
    state.ssk = null;
  }

  if (state.epk != null) {
    sodium_free(state.epk);
    state.epk = null;
  }

  if (state.esk != null) {
    sodium_free(state.esk);
    state.esk = null;
  }

  if (state.rs != null) {
    sodium_free(state.rs);
    state.rs = null;
  }

  if (state.re != null) {
    sodium_free(state.re);
    state.re = null;
  }

  state.messagePatterns = null;
}

function keygen(obj, sk) {
  if (!obj) {
    obj = {
      publicKey: sodium_malloc(PKLEN),
      secretKey: sodium_malloc(SKLEN)
    };
    return keygen(obj);
  }

  if (obj.publicKey) {
    dh.generateKeypair(obj.publicKey, obj.secretKey);
    return obj;
  }

  if (obj.byteLength != null) dh.generateKeypair(null, obj);
}

function seedKeygen(seed) {
  var obj = {
    publicKey: sodium_malloc(PKLEN),
    secretKey: sodium_malloc(SKLEN)
  };
  dh.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);
  return obj;
}

function toCharCode(s) {
  return s.charCodeAt(0);
}

},{"./cipher-state":348,"./dh":350,"./symmetric-state":355,"clone":117,"nanoassert":354,"sodium-universal/memory":544}],352:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  sodium_malloc,
  sodium_memzero
} = require('sodium-universal/memory');

const {
  crypto_generichash_batch
} = require('sodium-universal/crypto_generichash');

const assert = require('nanoassert');

const hmacBlake2b = require('hmac-blake2b');

const dh = require("./dh");

const HASHLEN = 64;
const BLOCKLEN = 128;
assert(hmacBlake2b.KEYBYTES === BLOCKLEN, 'mismatching hmac BLOCKLEN');
assert(hmacBlake2b.BYTES === HASHLEN, 'mismatching hmac HASHLEN');
module.exports = {
  HASHLEN,
  BLOCKLEN,
  hash,
  hkdf
};

function hash(out, data) {
  assert(out.byteLength === HASHLEN);
  assert(Array.isArray(data));
  crypto_generichash_batch(out, data);
}

function hmac(out, key, data) {
  return hmacBlake2b(out, data, key);
}

const TempKey = sodium_malloc(HASHLEN);
const Byte0x01 = new Uint8Array([0x01]);
const Byte0x02 = new Uint8Array([0x02]);
const Byte0x03 = new Uint8Array([0x03]);

function hkdf(out1, out2, out3, chainingKey, inputKeyMaterial) {
  assert(out1.byteLength === HASHLEN);
  assert(out2.byteLength === HASHLEN);
  assert(out3 == null ? true : out3.byteLength === HASHLEN);
  assert(chainingKey.byteLength === HASHLEN);
  assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength));
  sodium_memzero(TempKey);
  hmac(TempKey, chainingKey, [inputKeyMaterial]);
  hmac(out1, TempKey, [Byte0x01]);
  hmac(out2, TempKey, [out1, Byte0x02]);

  if (out3 != null) {
    hmac(out3, TempKey, [out2, Byte0x03]);
  }

  sodium_memzero(TempKey);
}

},{"./dh":350,"hmac-blake2b":217,"nanoassert":354,"sodium-universal/crypto_generichash":527,"sodium-universal/memory":544}],353:[function(require,module,exports){
module.exports = require("./handshake-state");

},{"./handshake-state":351}],354:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],355:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  sodium_malloc,
  sodium_memzero
} = require('sodium-universal/memory');

var assert = require('nanoassert');

var cipherState = require("./cipher-state");

var hash = require("./hash");

var STATELEN = hash.HASHLEN + hash.HASHLEN + cipherState.STATELEN;
var HASHLEN = hash.HASHLEN;
module.exports = {
  STATELEN,
  initializeSymmetric,
  mixKey,
  mixHash,
  mixKeyAndHash,
  getHandshakeHash,
  encryptAndHash,
  decryptAndHash,
  split,
  _hasKey
};
var CHAINING_KEY_BEGIN = 0;
var CHAINING_KEY_END = hash.HASHLEN;
var HASH_BEGIN = CHAINING_KEY_END;
var HASH_END = HASH_BEGIN + hash.HASHLEN;
var CIPHER_BEGIN = HASH_END;
var CIPHER_END = CIPHER_BEGIN + cipherState.STATELEN;

function initializeSymmetric(state, protocolName) {
  assert(state.byteLength === STATELEN);
  assert(protocolName.byteLength != null);
  sodium_memzero(state);
  if (protocolName.byteLength <= HASHLEN) state.set(protocolName, HASH_BEGIN);else hash.hash(state.subarray(HASH_BEGIN, HASH_END), [protocolName]);
  state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END).set(state.subarray(HASH_BEGIN, HASH_END));
  cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), null);
}

var TempKey = sodium_malloc(HASHLEN);

function mixKey(state, inputKeyMaterial) {
  assert(state.byteLength === STATELEN);
  assert(inputKeyMaterial.byteLength != null);
  hash.hkdf(state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), TempKey, null, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), inputKeyMaterial); // HASHLEN is always 64 here, so we truncate to 32 bytes per the spec

  cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
  sodium_memzero(TempKey);
}

function mixHash(state, data) {
  assert(state.byteLength === STATELEN);
  var h = state.subarray(HASH_BEGIN, HASH_END);
  hash.hash(h, [h, data]);
}

var TempHash = sodium_malloc(HASHLEN);

function mixKeyAndHash(state, inputKeyMaterial) {
  assert(state.byteLength === STATELEN);
  assert(inputKeyMaterial.byteLength != null);
  hash.hkdf(state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), TempHash, TempKey, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), inputKeyMaterial);
  mixHash(state, TempHash);
  sodium_memzero(TempHash); // HASHLEN is always 64 here, so we truncate to 32 bytes per the spec

  cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
  sodium_memzero(TempKey);
}

function getHandshakeHash(state, out) {
  assert(state.byteLength === STATELEN);
  assert(out.byteLength === HASHLEN);
  out.set(state.subarray(HASH_BEGIN, HASH_END));
} // ciphertext is the output here


function encryptAndHash(state, ciphertext, plaintext) {
  assert(state.byteLength === STATELEN);
  assert(ciphertext.byteLength != null);
  assert(plaintext.byteLength != null);
  var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
  var h = state.subarray(HASH_BEGIN, HASH_END);
  cipherState.encryptWithAd(cstate, ciphertext, h, plaintext);
  encryptAndHash.bytesRead = cipherState.encryptWithAd.bytesRead;
  encryptAndHash.bytesWritten = cipherState.encryptWithAd.bytesWritten;
  mixHash(state, ciphertext.subarray(0, encryptAndHash.bytesWritten));
}

encryptAndHash.bytesRead = 0;
encryptAndHash.bytesWritten = 0; // plaintext is the output here

function decryptAndHash(state, plaintext, ciphertext) {
  assert(state.byteLength === STATELEN);
  assert(plaintext.byteLength != null);
  assert(ciphertext.byteLength != null);
  var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
  var h = state.subarray(HASH_BEGIN, HASH_END);
  cipherState.decryptWithAd(cstate, plaintext, h, ciphertext);
  decryptAndHash.bytesRead = cipherState.decryptWithAd.bytesRead;
  decryptAndHash.bytesWritten = cipherState.decryptWithAd.bytesWritten;
  mixHash(state, ciphertext.subarray(0, decryptAndHash.bytesRead));
}

decryptAndHash.bytesRead = 0;
decryptAndHash.bytesWritten = 0;
var TempKey1 = sodium_malloc(HASHLEN);
var TempKey2 = sodium_malloc(HASHLEN);
var zerolen = new Uint8Array(0);

function split(state, cipherstate1, cipherstate2) {
  assert(state.byteLength === STATELEN);
  assert(cipherstate1.byteLength === cipherState.STATELEN);
  assert(cipherstate2.byteLength === cipherState.STATELEN);
  hash.hkdf(TempKey1, TempKey2, null, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), zerolen); // HASHLEN is always 64 here, so we truncate to 32 bytes per the spec

  cipherState.initializeKey(cipherstate1, TempKey1.subarray(0, 32));
  cipherState.initializeKey(cipherstate2, TempKey2.subarray(0, 32));
  sodium_memzero(TempKey1);
  sodium_memzero(TempKey2);
}

function _hasKey(state) {
  return cipherState.hasKey(state.subarray(CIPHER_BEGIN, CIPHER_END));
}

},{"./cipher-state":348,"./hash":352,"nanoassert":354,"sodium-universal/memory":544}],356:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var removeTrailingSeparator = require('remove-trailing-separator');

module.exports = function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  str = str.replace(/[\\\/]+/g, '/');

  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }

  return str;
};

},{"remove-trailing-separator":443}],357:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

},{}],358:[function(require,module,exports){
var wrappy = require('wrappy');

module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this);
    },
    configurable: true
  });
});

function once(fn) {
  var f = function () {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  f.called = false;
  return f;
}

function onceStrict(fn) {
  var f = function () {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}

},{"wrappy":588}],359:[function(require,module,exports){
exports.endianness = function () {
  return 'LE';
};

exports.hostname = function () {
  if (typeof location !== 'undefined') {
    return location.hostname;
  } else return '';
};

exports.loadavg = function () {
  return [];
};

exports.uptime = function () {
  return 0;
};

exports.freemem = function () {
  return Number.MAX_VALUE;
};

exports.totalmem = function () {
  return Number.MAX_VALUE;
};

exports.cpus = function () {
  return [];
};

exports.type = function () {
  return 'Browser';
};

exports.release = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.appVersion;
  }

  return '';
};

exports.networkInterfaces = exports.getNetworkInterfaces = function () {
  return {};
};

exports.arch = function () {
  return 'javascript';
};

exports.platform = function () {
  return 'browser';
};

exports.tmpdir = exports.tmpDir = function () {
  return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
  return '/';
};

},{}],360:[function(require,module,exports){
'use strict';

const pTimeout = require('p-timeout');

const symbolAsyncIterator = Symbol.asyncIterator || '@@asyncIterator';

const normalizeEmitter = emitter => {
  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;

  if (!addListener || !removeListener) {
    throw new TypeError('Emitter is not compatible');
  }

  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};

const toArray = value => Array.isArray(value) ? value : [value];

const multiple = (emitter, event, options) => {
  let cancel;
  const ret = new Promise((resolve, reject) => {
    options = {
      rejectionEvents: ['error'],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };

    if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {
      throw new TypeError('The `count` option should be at least 0 or more');
    } // Allow multiple events


    const events = toArray(event);
    const items = [];
    const {
      addListener,
      removeListener
    } = normalizeEmitter(emitter);

    const onItem = (...args) => {
      const value = options.multiArgs ? args : args[0];

      if (options.filter && !options.filter(value)) {
        return;
      }

      items.push(value);

      if (options.count === items.length) {
        cancel();
        resolve(items);
      }
    };

    const rejectHandler = error => {
      cancel();
      reject(error);
    };

    cancel = () => {
      for (const event of events) {
        removeListener(event, onItem);
      }

      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };

    for (const event of events) {
      addListener(event, onItem);
    }

    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }

    if (options.resolveImmediately) {
      resolve(items);
    }
  });
  ret.cancel = cancel;

  if (typeof options.timeout === 'number') {
    const timeout = pTimeout(ret, options.timeout);
    timeout.cancel = cancel;
    return timeout;
  }

  return ret;
};

const pEvent = (emitter, event, options) => {
  if (typeof options === 'function') {
    options = {
      filter: options
    };
  }

  options = { ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = multiple(emitter, event, options);
  const promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then

  promise.cancel = arrayPromise.cancel;
  return promise;
};

module.exports = pEvent; // TODO: Remove this for the next major release

module.exports.default = pEvent;
module.exports.multiple = multiple;

module.exports.iterator = (emitter, event, options) => {
  if (typeof options === 'function') {
    options = {
      filter: options
    };
  } // Allow multiple events


  const events = toArray(event);
  options = {
    rejectionEvents: ['error'],
    resolutionEvents: [],
    limit: Infinity,
    multiArgs: false,
    ...options
  };
  const {
    limit
  } = options;
  const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));

  if (!isValidLimit) {
    throw new TypeError('The `limit` option should be a non-negative integer or Infinity');
  }

  if (limit === 0) {
    // Return an empty async iterator to avoid any further cost
    return {
      [Symbol.asyncIterator]() {
        return this;
      },

      async next() {
        return {
          done: true,
          value: undefined
        };
      }

    };
  }

  const {
    addListener,
    removeListener
  } = normalizeEmitter(emitter);
  let isDone = false;
  let error;
  let hasPendingError = false;
  const nextQueue = [];
  const valueQueue = [];
  let eventCount = 0;
  let isLimitReached = false;

  const valueHandler = (...args) => {
    eventCount++;
    isLimitReached = eventCount === limit;
    const value = options.multiArgs ? args : args[0];

    if (nextQueue.length > 0) {
      const {
        resolve
      } = nextQueue.shift();
      resolve({
        done: false,
        value
      });

      if (isLimitReached) {
        cancel();
      }

      return;
    }

    valueQueue.push(value);

    if (isLimitReached) {
      cancel();
    }
  };

  const cancel = () => {
    isDone = true;

    for (const event of events) {
      removeListener(event, valueHandler);
    }

    for (const rejectionEvent of options.rejectionEvents) {
      removeListener(rejectionEvent, rejectHandler);
    }

    for (const resolutionEvent of options.resolutionEvents) {
      removeListener(resolutionEvent, resolveHandler);
    }

    while (nextQueue.length > 0) {
      const {
        resolve
      } = nextQueue.shift();
      resolve({
        done: true,
        value: undefined
      });
    }
  };

  const rejectHandler = (...args) => {
    error = options.multiArgs ? args : args[0];

    if (nextQueue.length > 0) {
      const {
        reject
      } = nextQueue.shift();
      reject(error);
    } else {
      hasPendingError = true;
    }

    cancel();
  };

  const resolveHandler = (...args) => {
    const value = options.multiArgs ? args : args[0];

    if (options.filter && !options.filter(value)) {
      return;
    }

    if (nextQueue.length > 0) {
      const {
        resolve
      } = nextQueue.shift();
      resolve({
        done: true,
        value
      });
    } else {
      valueQueue.push(value);
    }

    cancel();
  };

  for (const event of events) {
    addListener(event, valueHandler);
  }

  for (const rejectionEvent of options.rejectionEvents) {
    addListener(rejectionEvent, rejectHandler);
  }

  for (const resolutionEvent of options.resolutionEvents) {
    addListener(resolutionEvent, resolveHandler);
  }

  return {
    [symbolAsyncIterator]() {
      return this;
    },

    async next() {
      if (valueQueue.length > 0) {
        const value = valueQueue.shift();
        return {
          done: isDone && valueQueue.length === 0 && !isLimitReached,
          value
        };
      }

      if (hasPendingError) {
        hasPendingError = false;
        throw error;
      }

      if (isDone) {
        return {
          done: true,
          value: undefined
        };
      }

      return new Promise((resolve, reject) => nextQueue.push({
        resolve,
        reject
      }));
    },

    async return(value) {
      cancel();
      return {
        done: isDone,
        value
      };
    }

  };
};

module.exports.TimeoutError = pTimeout.TimeoutError;

},{"p-timeout":365}],361:[function(require,module,exports){
'use strict';

module.exports = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};

},{}],362:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventEmitter = require("eventemitter3");

const p_timeout_1 = require("p-timeout");

const priority_queue_1 = require("./priority-queue"); // eslint-disable-next-line @typescript-eslint/no-empty-function


const empty = () => {};

const timeoutError = new p_timeout_1.TimeoutError();
/**
Promise queue with concurrency control.
*/

class PQueue extends EventEmitter {
  constructor(options) {
    var _a, _b, _c, _d;

    super();
    this._intervalCount = 0;
    this._intervalEnd = 0;
    this._pendingCount = 0;
    this._resolveEmpty = empty;
    this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions

    options = Object.assign({
      carryoverConcurrencyCount: false,
      intervalCap: Infinity,
      interval: 0,
      concurrency: Infinity,
      autoStart: true,
      queueClass: priority_queue_1.default
    }, options);

    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\` (${typeof options.intervalCap})`);
    }

    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\` (${typeof options.interval})`);
    }

    this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
    this._intervalCap = options.intervalCap;
    this._interval = options.interval;
    this._queue = new options.queueClass();
    this._queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    this._timeout = options.timeout;
    this._throwOnTimeout = options.throwOnTimeout === true;
    this._isPaused = options.autoStart === false;
  }

  get _doesIntervalAllowAnother() {
    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
  }

  get _doesConcurrentAllowAnother() {
    return this._pendingCount < this._concurrency;
  }

  _next() {
    this._pendingCount--;

    this._tryToStartAnother();

    this.emit('next');
  }

  _resolvePromises() {
    this._resolveEmpty();

    this._resolveEmpty = empty;

    if (this._pendingCount === 0) {
      this._resolveIdle();

      this._resolveIdle = empty;
      this.emit('idle');
    }
  }

  _onResumeInterval() {
    this._onInterval();

    this._initializeIntervalIfNeeded();

    this._timeoutId = undefined;
  }

  _isIntervalPaused() {
    const now = Date.now();

    if (this._intervalId === undefined) {
      const delay = this._intervalEnd - now;

      if (delay < 0) {
        // Act as the interval was done
        // We don't need to resume it here because it will be resumed on line 160
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      } else {
        // Act as the interval is pending
        if (this._timeoutId === undefined) {
          this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, delay);
        }

        return true;
      }
    }

    return false;
  }

  _tryToStartAnother() {
    if (this._queue.size === 0) {
      // We can clear the interval ("pause")
      // Because we can redo it later ("resume")
      if (this._intervalId) {
        clearInterval(this._intervalId);
      }

      this._intervalId = undefined;

      this._resolvePromises();

      return false;
    }

    if (!this._isPaused) {
      const canInitializeInterval = !this._isIntervalPaused();

      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
        const job = this._queue.dequeue();

        if (!job) {
          return false;
        }

        this.emit('active');
        job();

        if (canInitializeInterval) {
          this._initializeIntervalIfNeeded();
        }

        return true;
      }
    }

    return false;
  }

  _initializeIntervalIfNeeded() {
    if (this._isIntervalIgnored || this._intervalId !== undefined) {
      return;
    }

    this._intervalId = setInterval(() => {
      this._onInterval();
    }, this._interval);
    this._intervalEnd = Date.now() + this._interval;
  }

  _onInterval() {
    if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = undefined;
    }

    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;

    this._processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */


  _processQueue() {
    // eslint-disable-next-line no-empty
    while (this._tryToStartAnother()) {}
  }

  get concurrency() {
    return this._concurrency;
  }

  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }

    this._concurrency = newConcurrency;

    this._processQueue();
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */


  async add(fn, options = {}) {
    return new Promise((resolve, reject) => {
      const run = async () => {
        this._pendingCount++;
        this._intervalCount++;

        try {
          const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {
            if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {
              reject(timeoutError);
            }

            return undefined;
          });
          resolve(await operation);
        } catch (error) {
          reject(error);
        }

        this._next();
      };

      this._queue.enqueue(run, options);

      this._tryToStartAnother();

      this.emit('add');
    });
  }
  /**
  Same as `.add()`, but accepts an array of sync or async functions.
   @returns A promise that resolves when all functions are resolved.
  */


  async addAll(functions, options) {
    return Promise.all(functions.map(async function_ => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */


  start() {
    if (!this._isPaused) {
      return this;
    }

    this._isPaused = false;

    this._processQueue();

    return this;
  }
  /**
  Put queue execution on hold.
  */


  pause() {
    this._isPaused = true;
  }
  /**
  Clear the queue.
  */


  clear() {
    this._queue = new this._queueClass();
  }
  /**
  Can be called multiple times. Useful if you for example add additional items at a later time.
   @returns A promise that settles when the queue becomes empty.
  */


  async onEmpty() {
    // Instantly resolve if the queue is empty
    if (this._queue.size === 0) {
      return;
    }

    return new Promise(resolve => {
      const existingResolve = this._resolveEmpty;

      this._resolveEmpty = () => {
        existingResolve();
        resolve();
      };
    });
  }
  /**
  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
  */


  async onIdle() {
    // Instantly resolve if none pending and if nothing else is queued
    if (this._pendingCount === 0 && this._queue.size === 0) {
      return;
    }

    return new Promise(resolve => {
      const existingResolve = this._resolveIdle;

      this._resolveIdle = () => {
        existingResolve();
        resolve();
      };
    });
  }
  /**
  Size of the queue.
  */


  get size() {
    return this._queue.size;
  }
  /**
  Size of the queue, filtered by the given options.
   For example, this can be used to find the number of items remaining in the queue with a specific priority level.
  */


  sizeBy(options) {
    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
    return this._queue.filter(options).length;
  }
  /**
  Number of pending promises.
  */


  get pending() {
    return this._pendingCount;
  }
  /**
  Whether the queue is currently paused.
  */


  get isPaused() {
    return this._isPaused;
  }

  get timeout() {
    return this._timeout;
  }
  /**
  Set the timeout for future operations.
  */


  set timeout(milliseconds) {
    this._timeout = milliseconds;
  }

}

exports.default = PQueue;

},{"./priority-queue":364,"eventemitter3":171,"p-timeout":365}],363:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion

function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;

  while (count > 0) {
    const step = count / 2 | 0;
    let it = first + step;

    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }

  return first;
}

exports.default = lowerBound;

},{}],364:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const lower_bound_1 = require("./lower-bound");

class PriorityQueue {
  constructor() {
    this._queue = [];
  }

  enqueue(run, options) {
    options = Object.assign({
      priority: 0
    }, options);
    const element = {
      priority: options.priority,
      run
    };

    if (this.size && this._queue[this.size - 1].priority >= options.priority) {
      this._queue.push(element);

      return;
    }

    const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);

    this._queue.splice(index, 0, element);
  }

  dequeue() {
    const item = this._queue.shift();

    return item === null || item === void 0 ? void 0 : item.run;
  }

  filter(options) {
    return this._queue.filter(element => element.priority === options.priority).map(element => element.run);
  }

  get size() {
    return this._queue.length;
  }

}

exports.default = PriorityQueue;

},{"./lower-bound":363}],365:[function(require,module,exports){
'use strict';

const pFinally = require('p-finally');

class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }

}

const pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
  if (typeof milliseconds !== 'number' || milliseconds < 0) {
    throw new TypeError('Expected `milliseconds` to be a positive number');
  }

  if (milliseconds === Infinity) {
    resolve(promise);
    return;
  }

  const timer = setTimeout(() => {
    if (typeof fallback === 'function') {
      try {
        resolve(fallback());
      } catch (error) {
        reject(error);
      }

      return;
    }

    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
    const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);

    if (typeof promise.cancel === 'function') {
      promise.cancel();
    }

    reject(timeoutError);
  }, milliseconds); // TODO: Use native `finally` keyword when targeting Node.js 10

  pFinally( // eslint-disable-next-line promise/prefer-await-to-then
  promise.then(resolve, reject), () => {
    clearTimeout(timer);
  });
});

module.exports = pTimeout; // TODO: Remove this for the next major release

module.exports.default = pTimeout;
module.exports.TimeoutError = TimeoutError;

},{"p-finally":361}],366:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],367:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict';

var asn1 = require('asn1.js');

exports.certificate = require("./certificate");
var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('modulus').int(), this.key('publicExponent').int(), this.key('privateExponent').int(), this.key('prime1').int(), this.key('prime2').int(), this.key('exponent1').int(), this.key('exponent2').int(), this.key('coefficient').int());
});
exports.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
});
exports.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
exports.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p').int(), this.key('q').int(), this.key('g').int()).optional());
});
var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(this.key('version').int(), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters').int())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
});
exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('p').int(), this.key('q').int(), this.key('g').int(), this.key('pub_key').int(), this.key('priv_key').int());
});
exports.DSAPrivateKey = DSAPrivateKey;
exports.DSAparam = asn1.define('DSAparam', function () {
  this.int();
});
var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
});
exports.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  });
});
exports.signature = asn1.define('signature', function () {
  this.seq().obj(this.key('r').int(), this.key('s').int());
});

},{"./certificate":368,"asn1.js":18}],368:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen
'use strict';

var asn = require('asn1.js');

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(this.key('type').objid(), this.key('value').any());
});
var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('parameters').optional(), this.key('curve').objid().optional());
});
var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue);
});
var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName);
});
var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = asn.define('Validity', function () {
  this.seq().obj(this.key('notBefore').use(Time), this.key('notAfter').use(Time));
});
var Extension = asn.define('Extension', function () {
  this.seq().obj(this.key('extnID').objid(), this.key('critical').bool().def(false), this.key('extnValue').octstr());
});
var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(this.key('version').explicit(0).int().optional(), this.key('serialNumber').int(), this.key('signature').use(AlgorithmIdentifier), this.key('issuer').use(Name), this.key('validity').use(Validity), this.key('subject').use(Name), this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo), this.key('issuerUniqueID').implicit(1).bitstr().optional(), this.key('subjectUniqueID').implicit(2).bitstr().optional(), this.key('extensions').explicit(3).seqof(Extension).optional());
});
var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(this.key('tbsCertificate').use(TBSCertificate), this.key('signatureAlgorithm').use(AlgorithmIdentifier), this.key('signatureValue').bitstr());
});
module.exports = X509Certificate;

},{"asn1.js":18}],369:[function(require,module,exports){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;

var evp = require('evp_bytestokey');

var ciphers = require('browserify-aes');

var Buffer = require('safe-buffer').Buffer;

module.exports = function (okey, password) {
  var key = okey.toString();
  var match = key.match(findProc);
  var decrypted;

  if (!match) {
    var match2 = key.match(fullRegex);
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
  } else {
    var suite = 'aes' + match[1];
    var iv = Buffer.from(match[2], 'hex');
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    var out = [];
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer.concat(out);
  }

  var tag = key.match(startRegex)[1];
  return {
    tag: tag,
    data: decrypted
  };
};

},{"browserify-aes":51,"evp_bytestokey":173,"safe-buffer":446}],370:[function(require,module,exports){
var asn1 = require("./asn1");

var aesid = require("./aesid.json");

var fixProc = require("./fixProc");

var ciphers = require('browserify-aes');

var compat = require('pbkdf2');

var Buffer = require('safe-buffer').Buffer;

module.exports = parseKeys;

function parseKeys(buffer) {
  var password;

  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }

  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer);
  }

  var stripped = fixProc(buffer, password);
  var type = stripped.tag;
  var data = stripped.data;
  var subtype, ndata;

  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
    // falls through

    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der');
      }

      subtype = ndata.algorithm.algorithm.join('.');

      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');

        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: 'ec',
            data: ndata
          };

        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          };

        default:
          throw new Error('unknown key id ' + subtype);
      }

    // throw new Error('unknown key type ' + type)

    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(data, password);
    // falls through

    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');

      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');

        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };

        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          };

        default:
          throw new Error('unknown key id ' + subtype);
      }

    // throw new Error('unknown key type ' + type)

    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');

    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');

    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };

    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };

    default:
      throw new Error('unknown key type ' + type);
  }
}

parseKeys.signature = asn1.signature;

function decrypt(data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10) / 8;
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
  var cipher = ciphers.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer.concat(out);
}

},{"./aesid.json":366,"./asn1":367,"./fixProc":369,"browserify-aes":51,"pbkdf2":372,"safe-buffer":446}],371:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
} // Resolves . and .. elements in a path with directory names


function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;

  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length) code = path.charCodeAt(i);else if (code === 47
    /*/*/
    ) break;else code = 47
    /*/*/
    ;

    if (code === 47
    /*/*/
    ) {
        if (lastSlash === i - 1 || dots === 1) {// NOOP
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
          /*.*/
          || res.charCodeAt(res.length - 2) !== 46
          /*.*/
          ) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf('/');

                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = '';
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                  }

                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = '';
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }

          if (allowAboveRoot) {
            if (res.length > 0) res += '/..';else res = '..';
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
    /*.*/
    && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }

  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');

  if (!dir) {
    return base;
  }

  if (dir === pathObject.root) {
    return dir + base;
  }

  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0) path = arguments[i];else {
        if (cwd === undefined) cwd = process.cwd();
        path = cwd;
      }
      assertPath(path); // Skip empty entries

      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47
      /*/*/
      ;
    } // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path


    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },
  normalize: function normalize(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var isAbsolute = path.charCodeAt(0) === 47
    /*/*/
    ;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47
    /*/*/
    ; // Normalize the path

    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';
    if (isAbsolute) return '/' + path;
    return path;
  },
  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47
    /*/*/
    ;
  },
  join: function join() {
    if (arguments.length === 0) return '.';
    var joined;

    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);

      if (arg.length > 0) {
        if (joined === undefined) joined = arg;else joined += '/' + arg;
      }
    }

    if (joined === undefined) return '.';
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return '';
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) return ''; // Trim any leading backslashes

    var fromStart = 1;

    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47
      /*/*/
      ) break;
    }

    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart; // Trim any leading backslashes

    var toStart = 1;

    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47
      /*/*/
      ) break;
    }

    var toEnd = to.length;
    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;

    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47
          /*/*/
          ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47
          /*/*/
          ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }

        break;
      }

      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) break;else if (fromCode === 47
      /*/*/
      ) lastCommonSep = i;
    }

    var out = ''; // Generate the relative path based on the path difference between `to`
    // and `from`

    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47
      /*/*/
      ) {
          if (out.length === 0) out += '..';else out += '/..';
        }
    } // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts


    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47
      /*/*/
      ) ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path) {
    return path;
  },
  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47
    /*/*/
    ;
    var end = -1;
    var matchedSlash = true;

    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },
  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;

      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }

          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47
        /*/*/
        ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },
  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    var preDotState = 0;

    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === 46
      /*.*/
      ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }

    return path.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }

    return _format('/', pathObject);
  },
  parse: function parse(path) {
    assertPath(path);
    var ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47
    /*/*/
    ;
    var start;

    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }

    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    var preDotState = 0; // Get non-dir info

    for (; i >= start; --i) {
      code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === 46
      /*.*/
      ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }

      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
    return ret;
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};
posix.posix = posix;
module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":380}],372:[function(require,module,exports){
exports.pbkdf2 = require("./lib/async");
exports.pbkdf2Sync = require("./lib/sync");

},{"./lib/async":373,"./lib/sync":376}],373:[function(require,module,exports){
(function (global){(function (){
var Buffer = require('safe-buffer').Buffer;

var checkParameters = require("./precondition");

var defaultEncoding = require("./default-encoding");

var sync = require("./sync");

var toBuffer = require("./to-buffer");

var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
};
var checks = [];

function checkNative(algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false);
  }

  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false);
  }

  if (checks[algo] !== undefined) {
    return checks[algo];
  }

  ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
    return true;
  }).catch(function () {
    return false;
  });
  checks[algo] = prom;
  return prom;
}

var nextTick;

function getNextTick() {
  if (nextTick) {
    return nextTick;
  }

  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick;
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask;
  } else if (global.setImmediate) {
    nextTick = global.setImmediate;
  } else {
    nextTick = global.setTimeout;
  }

  return nextTick;
}

function browserPbkdf2(password, salt, iterations, length, algo) {
  return subtle.importKey('raw', password, {
    name: 'PBKDF2'
  }, false, ['deriveBits']).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3);
  }).then(function (res) {
    return Buffer.from(res);
  });
}

function resolvePromise(promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out);
    });
  }, function (e) {
    getNextTick()(function () {
      callback(e);
    });
  });
}

module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }

  digest = digest || 'sha1';
  var algo = toBrowser[digest.toLowerCase()];

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out;

      try {
        out = sync(password, salt, iterations, keylen, digest);
      } catch (e) {
        return callback(e);
      }

      callback(null, out);
    });
    return;
  }

  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
    return sync(password, salt, iterations, keylen, digest);
  }), callback);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":374,"./precondition":375,"./sync":376,"./to-buffer":377,"safe-buffer":446}],374:[function(require,module,exports){
(function (process,global){(function (){
var defaultEncoding;
/* istanbul ignore next */

if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8';
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
} else {
  defaultEncoding = 'utf-8';
}

module.exports = defaultEncoding;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":380}],375:[function(require,module,exports){
var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number');
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations');
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number');
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
    /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length');
  }
};

},{}],376:[function(require,module,exports){
var md5 = require('create-hash/md5');

var RIPEMD160 = require('ripemd160');

var sha = require('sha.js');

var Buffer = require('safe-buffer').Buffer;

var checkParameters = require("./precondition");

var defaultEncoding = require("./default-encoding");

var toBuffer = require("./to-buffer");

var ZEROS = Buffer.alloc(128);
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};

function Hmac(alg, key, saltLen) {
  var hash = getDigest(alg);
  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

  if (key.length > blocksize) {
    key = hash(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
  ipad.copy(ipad1, 0, 0, blocksize);
  this.ipad1 = ipad1;
  this.ipad2 = ipad;
  this.opad = opad;
  this.alg = alg;
  this.blocksize = blocksize;
  this.hash = hash;
  this.size = sizes[alg];
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize);
  var h = this.hash(ipad);
  h.copy(this.opad, this.blocksize);
  return this.hash(this.opad);
};

function getDigest(alg) {
  function shaFunc(data) {
    return sha(alg).update(data).digest();
  }

  function rmd160Func(data) {
    return new RIPEMD160().update(data).digest();
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
  if (alg === 'md5') return md5;
  return shaFunc;
}

function pbkdf2(password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');
  digest = digest || 'sha1';
  var hmac = new Hmac(digest, password, salt.length);
  var DK = Buffer.allocUnsafe(keylen);
  var block1 = Buffer.allocUnsafe(salt.length + 4);
  salt.copy(block1, 0, 0, salt.length);
  var destPos = 0;
  var hLen = sizes[digest];
  var l = Math.ceil(keylen / hLen);

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length);
    var T = hmac.run(block1, hmac.ipad1);
    var U = T;

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2);

      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
    }

    T.copy(DK, destPos);
    destPos += hLen;
  }

  return DK;
}

module.exports = pbkdf2;

},{"./default-encoding":374,"./precondition":375,"./to-buffer":377,"create-hash/md5":125,"ripemd160":445,"safe-buffer":446,"sha.js":449}],377:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer;

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing;
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding);
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer);
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView');
  }
};

},{"safe-buffer":446}],378:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function prettyHash(buf) {
  if (Buffer.isBuffer(buf)) buf = buf.toString('hex');

  if (typeof buf === 'string' && buf.length > 8) {
    return buf.slice(0, 6) + '..' + buf.slice(-2);
  }

  return buf;
};

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":282}],379:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],380:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

},{}],381:[function(require,module,exports){
(function (global){(function (){
module.exports = Deferred;
Deferred.defer = defer;

function Deferred(Promise) {
  if (Promise == null) Promise = global.Promise;
  if (this instanceof Deferred) return defer(Promise, this);else return defer(Promise, Object.create(Deferred.prototype));
}

function defer(Promise, deferred) {
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],382:[function(require,module,exports){
(function (Buffer){(function (){
var varint = require('varint');

var svarint = require('signed-varint');

exports.make = encoder;

exports.name = function (enc) {
  var keys = Object.keys(exports);

  for (var i = 0; i < keys.length; i++) {
    if (exports[keys[i]] === enc) return keys[i];
  }

  return null;
};

exports.skip = function (type, buffer, offset) {
  switch (type) {
    case 0:
      varint.decode(buffer, offset);
      return offset + varint.decode.bytes;

    case 1:
      return offset + 8;

    case 2:
      var len = varint.decode(buffer, offset);
      return offset + varint.decode.bytes + len;

    case 3:
    case 4:
      throw new Error('Groups are not supported');

    case 5:
      return offset + 4;
  }

  throw new Error('Unknown wire type: ' + type);
};

exports.bytes = encoder(2, function encode(val, buffer, offset) {
  var oldOffset = offset;
  var len = bufferLength(val);
  varint.encode(len, buffer, offset);
  offset += varint.encode.bytes;
  if (Buffer.isBuffer(val)) val.copy(buffer, offset);else buffer.write(val, offset, len);
  offset += len;
  encode.bytes = offset - oldOffset;
  return buffer;
}, function decode(buffer, offset) {
  var oldOffset = offset;
  var len = varint.decode(buffer, offset);
  offset += varint.decode.bytes;
  var val = buffer.slice(offset, offset + len);
  offset += val.length;
  decode.bytes = offset - oldOffset;
  return val;
}, function encodingLength(val) {
  var len = bufferLength(val);
  return varint.encodingLength(len) + len;
});
exports.string = encoder(2, function encode(val, buffer, offset) {
  var oldOffset = offset;
  var len = Buffer.byteLength(val);
  varint.encode(len, buffer, offset, 'utf-8');
  offset += varint.encode.bytes;
  buffer.write(val, offset, len);
  offset += len;
  encode.bytes = offset - oldOffset;
  return buffer;
}, function decode(buffer, offset) {
  var oldOffset = offset;
  var len = varint.decode(buffer, offset);
  offset += varint.decode.bytes;
  var val = buffer.toString('utf-8', offset, offset + len);
  offset += len;
  decode.bytes = offset - oldOffset;
  return val;
}, function encodingLength(val) {
  var len = Buffer.byteLength(val);
  return varint.encodingLength(len) + len;
});
exports.bool = encoder(0, function encode(val, buffer, offset) {
  buffer[offset] = val ? 1 : 0;
  encode.bytes = 1;
  return buffer;
}, function decode(buffer, offset) {
  var bool = buffer[offset] > 0;
  decode.bytes = 1;
  return bool;
}, function encodingLength() {
  return 1;
});
exports.int32 = encoder(0, function encode(val, buffer, offset) {
  varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset);
  encode.bytes = varint.encode.bytes;
  return buffer;
}, function decode(buffer, offset) {
  var val = varint.decode(buffer, offset);
  decode.bytes = varint.decode.bytes;
  return val > 2147483647 ? val - 4294967296 : val;
}, function encodingLength(val) {
  return varint.encodingLength(val < 0 ? val + 4294967296 : val);
});
exports.int64 = encoder(0, function encode(val, buffer, offset) {
  if (val < 0) {
    var last = offset + 9;
    varint.encode(val * -1, buffer, offset);
    offset += varint.encode.bytes - 1;
    buffer[offset] = buffer[offset] | 0x80;

    while (offset < last - 1) {
      offset++;
      buffer[offset] = 0xff;
    }

    buffer[last] = 0x01;
    encode.bytes = 10;
  } else {
    varint.encode(val, buffer, offset);
    encode.bytes = varint.encode.bytes;
  }

  return buffer;
}, function decode(buffer, offset) {
  var val = varint.decode(buffer, offset);

  if (val >= Math.pow(2, 63)) {
    var limit = 9;

    while (buffer[offset + limit - 1] === 0xff) limit--;

    limit = limit || 9;
    var subset = Buffer.allocUnsafe(limit);
    buffer.copy(subset, 0, offset, offset + limit);
    subset[limit - 1] = subset[limit - 1] & 0x7f;
    val = -1 * varint.decode(subset, 0);
    decode.bytes = 10;
  } else {
    decode.bytes = varint.decode.bytes;
  }

  return val;
}, function encodingLength(val) {
  return val < 0 ? 10 : varint.encodingLength(val);
});
exports.sint32 = exports.sint64 = encoder(0, svarint.encode, svarint.decode, svarint.encodingLength);
exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(0, varint.encode, varint.decode, varint.encodingLength); // we cannot represent these in javascript so we just use buffers

exports.fixed64 = exports.sfixed64 = encoder(1, function encode(val, buffer, offset) {
  val.copy(buffer, offset);
  encode.bytes = 8;
  return buffer;
}, function decode(buffer, offset) {
  var val = buffer.slice(offset, offset + 8);
  decode.bytes = 8;
  return val;
}, function encodingLength() {
  return 8;
});
exports.double = encoder(1, function encode(val, buffer, offset) {
  buffer.writeDoubleLE(val, offset);
  encode.bytes = 8;
  return buffer;
}, function decode(buffer, offset) {
  var val = buffer.readDoubleLE(offset);
  decode.bytes = 8;
  return val;
}, function encodingLength() {
  return 8;
});
exports.fixed32 = encoder(5, function encode(val, buffer, offset) {
  buffer.writeUInt32LE(val, offset);
  encode.bytes = 4;
  return buffer;
}, function decode(buffer, offset) {
  var val = buffer.readUInt32LE(offset);
  decode.bytes = 4;
  return val;
}, function encodingLength() {
  return 4;
});
exports.sfixed32 = encoder(5, function encode(val, buffer, offset) {
  buffer.writeInt32LE(val, offset);
  encode.bytes = 4;
  return buffer;
}, function decode(buffer, offset) {
  var val = buffer.readInt32LE(offset);
  decode.bytes = 4;
  return val;
}, function encodingLength() {
  return 4;
});
exports.float = encoder(5, function encode(val, buffer, offset) {
  buffer.writeFloatLE(val, offset);
  encode.bytes = 4;
  return buffer;
}, function decode(buffer, offset) {
  var val = buffer.readFloatLE(offset);
  decode.bytes = 4;
  return val;
}, function encodingLength() {
  return 4;
});

function encoder(type, encode, decode, encodingLength) {
  encode.bytes = decode.bytes = 0;
  return {
    type: type,
    encode: encode,
    decode: decode,
    encodingLength: encodingLength
  };
}

function bufferLength(val) {
  return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"signed-varint":466,"varint":385}],383:[function(require,module,exports){
module.exports = read;
var MSB = 0x80,
    REST = 0x7F;

function read(buf, offset) {
  var res = 0,
      offset = offset || 0,
      shift = 0,
      counter = offset,
      b,
      l = buf.length;

  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }

    b = buf[counter++];
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);

  read.bytes = counter - offset;
  return res;
}

},{}],384:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],385:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./decode.js":383,"./encode.js":384,"./length.js":386,"dup":40}],386:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],387:[function(require,module,exports){
exports.publicEncrypt = require("./publicEncrypt");
exports.privateDecrypt = require("./privateDecrypt");

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

},{"./privateDecrypt":390,"./publicEncrypt":391}],388:[function(require,module,exports){
var createHash = require('create-hash');

var Buffer = require('safe-buffer').Buffer;

module.exports = function (seed, len) {
  var t = Buffer.alloc(0);
  var i = 0;
  var c;

  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }

  return t.slice(0, len);
};

function i2ops(c) {
  var out = Buffer.allocUnsafe(4);
  out.writeUInt32BE(c, 0);
  return out;
}

},{"create-hash":124,"safe-buffer":446}],389:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"buffer":48,"dup":32}],390:[function(require,module,exports){
var parseKeys = require('parse-asn1');

var mgf = require("./mgf");

var xor = require("./xor");

var BN = require('bn.js');

var crt = require('browserify-rsa');

var createHash = require('create-hash');

var withPublic = require("./withPublic");

var Buffer = require('safe-buffer').Buffer;

module.exports = function privateDecrypt(privateKey, enc, reverse) {
  var padding;

  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }

  var key = parseKeys(privateKey);
  var k = key.modulus.byteLength();

  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }

  var msg;

  if (reverse) {
    msg = withPublic(new BN(enc), key);
  } else {
    msg = crt(enc, key);
  }

  var zBuffer = Buffer.alloc(k - msg.length);
  msg = Buffer.concat([zBuffer, msg], k);

  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;

  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }

  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb = msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));

  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }

  var i = hLen;

  while (db[i] === 0) {
    i++;
  }

  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }

  return db.slice(i);
}

function pkcs1(key, msg, reverse) {
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;

  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }

  var ps = msg.slice(2, i - 1);

  if (p1.toString('hex') !== '0002' && !reverse || p1.toString('hex') !== '0001' && reverse) {
    status++;
  }

  if (ps.length < 8) {
    status++;
  }

  if (status) {
    throw new Error('decryption error');
  }

  return msg.slice(i);
}

function compare(a, b) {
  a = Buffer.from(a);
  b = Buffer.from(b);
  var dif = 0;
  var len = a.length;

  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }

  var i = -1;

  while (++i < len) {
    dif += a[i] ^ b[i];
  }

  return dif;
}

},{"./mgf":388,"./withPublic":392,"./xor":393,"bn.js":389,"browserify-rsa":69,"create-hash":124,"parse-asn1":370,"safe-buffer":446}],391:[function(require,module,exports){
var parseKeys = require('parse-asn1');

var randomBytes = require('randombytes');

var createHash = require('create-hash');

var mgf = require("./mgf");

var xor = require("./xor");

var BN = require('bn.js');

var withPublic = require("./withPublic");

var crt = require('browserify-rsa');

var Buffer = require('safe-buffer').Buffer;

module.exports = function publicEncrypt(publicKey, msg, reverse) {
  var padding;

  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }

  var key = parseKeys(publicKey);
  var paddedMsg;

  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);

    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }

  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;

  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }

  var ps = Buffer.alloc(k - mLen - hLen2 - 2);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
}

function pkcs1(key, msg, reverse) {
  var mLen = msg.length;
  var k = key.modulus.byteLength();

  if (mLen > k - 11) {
    throw new Error('message too long');
  }

  var ps;

  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }

  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
}

function nonZero(len) {
  var out = Buffer.allocUnsafe(len);
  var i = 0;
  var cache = randomBytes(len * 2);
  var cur = 0;
  var num;

  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2);
      cur = 0;
    }

    num = cache[cur++];

    if (num) {
      out[i++] = num;
    }
  }

  return out;
}

},{"./mgf":388,"./withPublic":392,"./xor":393,"bn.js":389,"browserify-rsa":69,"create-hash":124,"parse-asn1":370,"randombytes":427,"safe-buffer":446}],392:[function(require,module,exports){
var BN = require('bn.js');

var Buffer = require('safe-buffer').Buffer;

function withPublic(paddedMsg, key) {
  return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}

module.exports = withPublic;

},{"bn.js":389,"safe-buffer":446}],393:[function(require,module,exports){
module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;

  while (++i < len) {
    a[i] ^= b[i];
  }

  return a;
};

},{}],394:[function(require,module,exports){
(function (process){(function (){
var once = require('once');

var eos = require('end-of-stream');

var fs = require('fs'); // we only need fs to get the ReadStream and WriteStream prototypes


var noop = function () {};

var ancient = /^v?\.0/.test(process.version);

var isFn = function (fn) {
  return typeof fn === 'function';
};

var isFS = function (stream) {
  if (!ancient) return false; // newer node version do not need to care about fs is a special way

  if (!fs) return false; // browser

  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort);
};

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks

    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy();
    callback(err || new Error('stream was destroyed'));
  };
};

var call = function (fn) {
  fn();
};

var pipe = function (from, to) {
  return from.pipe(to);
};

var pump = function () {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum');
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
};

module.exports = pump;

}).call(this)}).call(this,require('_process'))
},{"_process":380,"end-of-stream":168,"fs":48,"once":358}],395:[function(require,module,exports){
var pump = require('pump');

var inherits = require('inherits');

var Duplexify = require('duplexify');

var toArray = function (args) {
  if (!args.length) return [];
  return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args);
};

var define = function (opts) {
  var Pumpify = function () {
    var streams = toArray(arguments);
    if (!(this instanceof Pumpify)) return new Pumpify(streams);
    Duplexify.call(this, null, null, opts);
    if (streams.length) this.setPipeline(streams);
  };

  inherits(Pumpify, Duplexify);

  Pumpify.prototype.setPipeline = function () {
    var streams = toArray(arguments);
    var self = this;
    var ended = false;
    var w = streams[0];
    var r = streams[streams.length - 1];
    r = r.readable ? r : null;
    w = w.writable ? w : null;

    var onclose = function () {
      streams[0].emit('error', new Error('stream was destroyed'));
    };

    this.on('close', onclose);
    this.on('prefinish', function () {
      if (!ended) self.cork();
    });
    pump(streams, function (err) {
      self.removeListener('close', onclose);
      if (err) return self.destroy(err.message === 'premature close' ? null : err);
      ended = true; // pump ends after the last stream is not writable *but*
      // pumpify still forwards the readable part so we need to catch errors
      // still, so reenable autoDestroy in this case

      if (self._autoDestroy === false) self._autoDestroy = true;
      self.uncork();
    });
    if (this.destroyed) return onclose();
    this.setWritable(w);
    this.setReadable(r);
  };

  return Pumpify;
};

module.exports = define({
  autoDestroy: false,
  destroy: false
});
module.exports.obj = define({
  autoDestroy: false,
  destroy: false,
  objectMode: true,
  highWaterMark: 16
});
module.exports.ctor = define;

},{"duplexify":396,"inherits":279,"pump":394}],396:[function(require,module,exports){
(function (process,Buffer){(function (){
var stream = require('readable-stream');

var eos = require('end-of-stream');

var inherits = require('inherits');

var shift = require('stream-shift');

var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);

var onuncork = function (self, fn) {
  if (self._corked) self.once('uncork', fn);else fn();
};

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err);
};

var destroyer = function (self, end) {
  return function (err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();
  };
};

var end = function (ws, fn) {
  if (!ws) return fn();
  if (ws._writableState && ws._writableState.finished) return fn();
  if (ws._writableState) return ws.end(fn);
  ws.end();
  fn();
};

var noop = function () {};

var toStreams2 = function (rs) {
  return new stream.Readable({
    objectMode: true,
    highWaterMark: 16
  }).wrap(rs);
};

var Duplexify = function (writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);
  stream.Duplex.call(this, opts);
  this._writable = null;
  this._readable = null;
  this._readable2 = null;
  this._autoDestroy = !opts || opts.autoDestroy !== false;
  this._forwardDestroy = !opts || opts.destroy !== false;
  this._forwardEnd = !opts || opts.end !== false;
  this._corked = 1; // start corked

  this._ondrain = null;
  this._drained = false;
  this._forwarding = false;
  this._unwrite = null;
  this._unread = null;
  this._ended = false;
  this.destroyed = false;
  if (writable) this.setWritable(writable);
  if (readable) this.setReadable(readable);
};

inherits(Duplexify, stream.Duplex);

Duplexify.obj = function (writable, readable, opts) {
  if (!opts) opts = {};
  opts.objectMode = true;
  opts.highWaterMark = 16;
  return new Duplexify(writable, readable, opts);
};

Duplexify.prototype.cork = function () {
  if (++this._corked === 1) this.emit('cork');
};

Duplexify.prototype.uncork = function () {
  if (this._corked && --this._corked === 0) this.emit('uncork');
};

Duplexify.prototype.setWritable = function (writable) {
  if (this._unwrite) this._unwrite();

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy();
    return;
  }

  if (writable === null || writable === false) {
    this.end();
    return;
  }

  var self = this;
  var unend = eos(writable, {
    writable: true,
    readable: false
  }, destroyer(this, this._forwardEnd));

  var ondrain = function () {
    var ondrain = self._ondrain;
    self._ondrain = null;
    if (ondrain) ondrain();
  };

  var clear = function () {
    self._writable.removeListener('drain', ondrain);

    unend();
  };

  if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks

  this._writable = writable;

  this._writable.on('drain', ondrain);

  this._unwrite = clear;
  this.uncork(); // always uncork setWritable
};

Duplexify.prototype.setReadable = function (readable) {
  if (this._unread) this._unread();

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy();
    return;
  }

  if (readable === null || readable === false) {
    this.push(null);
    this.resume();
    return;
  }

  var self = this;
  var unend = eos(readable, {
    writable: false,
    readable: true
  }, destroyer(this));

  var onreadable = function () {
    self._forward();
  };

  var onend = function () {
    self.push(null);
  };

  var clear = function () {
    self._readable2.removeListener('readable', onreadable);

    self._readable2.removeListener('end', onend);

    unend();
  };

  this._drained = true;
  this._readable = readable;
  this._readable2 = readable._readableState ? readable : toStreams2(readable);

  this._readable2.on('readable', onreadable);

  this._readable2.on('end', onend);

  this._unread = clear;

  this._forward();
};

Duplexify.prototype._read = function () {
  this._drained = true;

  this._forward();
};

Duplexify.prototype._forward = function () {
  if (this._forwarding || !this._readable2 || !this._drained) return;
  this._forwarding = true;
  var data;

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue;
    this._drained = this.push(data);
  }

  this._forwarding = false;
};

Duplexify.prototype.destroy = function (err, cb) {
  if (!cb) cb = noop;
  if (this.destroyed) return cb(null);
  this.destroyed = true;
  var self = this;
  process.nextTick(function () {
    self._destroy(err);

    cb(null);
  });
};

Duplexify.prototype._destroy = function (err) {
  if (err) {
    var ondrain = this._ondrain;
    this._ondrain = null;
    if (ondrain) ondrain(err);else this.emit('error', err);
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy();
    if (this._writable && this._writable.destroy) this._writable.destroy();
  }

  this.emit('close');
};

Duplexify.prototype._write = function (data, enc, cb) {
  if (this.destroyed) return;
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));
  if (data === SIGNAL_FLUSH) return this._finish(cb);
  if (!this._writable) return cb();
  if (this._writable.write(data) === false) this._ondrain = cb;else if (!this.destroyed) cb();
};

Duplexify.prototype._finish = function (cb) {
  var self = this;
  this.emit('preend');
  onuncork(this, function () {
    end(self._forwardEnd && self._writable, function () {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true;
      self.emit('prefinish');
      onuncork(self, cb);
    });
  });
};

Duplexify.prototype.end = function (data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data);
  if (typeof enc === 'function') return this.end(data, null, enc);
  this._ended = true;
  if (data) this.write(data);
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH);
  return stream.Writable.prototype.end.call(this, cb);
};

module.exports = Duplexify;

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":380,"buffer":97,"end-of-stream":168,"inherits":279,"readable-stream":411,"stream-shift":564}],397:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],398:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":400,"./_stream_writable":402,"_process":380,"dup":77,"inherits":279}],399:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":401,"dup":78,"inherits":279}],400:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":397,"./_stream_duplex":398,"./internal/streams/async_iterator":403,"./internal/streams/buffer_list":404,"./internal/streams/destroy":405,"./internal/streams/from":407,"./internal/streams/state":409,"./internal/streams/stream":410,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],401:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":397,"./_stream_duplex":398,"dup":80,"inherits":279}],402:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":397,"./_stream_duplex":398,"./internal/streams/destroy":405,"./internal/streams/state":409,"./internal/streams/stream":410,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],403:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":406,"_process":380,"dup":82}],404:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],405:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],406:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":397,"dup":85}],407:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],408:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":397,"./end-of-stream":406,"dup":87}],409:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":397,"dup":88}],410:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],411:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":398,"./lib/_stream_passthrough.js":399,"./lib/_stream_readable.js":400,"./lib/_stream_transform.js":401,"./lib/_stream_writable.js":402,"./lib/internal/streams/end-of-stream.js":406,"./lib/internal/streams/pipeline.js":408,"dup":90}],412:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise;
module.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global) // reuse resolved promise, and allocate it lazily
: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {
  throw err;
}, 0));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],413:[function(require,module,exports){
'use strict';

function tryStringify(o) {
  try {
    return JSON.stringify(o);
  } catch (e) {
    return '"[Circular]"';
  }
}

module.exports = format;

function format(f, args, opts) {
  var ss = opts && opts.stringify || tryStringify;
  var offset = 1;

  if (f === null) {
    f = args[0];
    offset = 0;
  }

  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset;
    if (len === 1) return f;
    var objects = new Array(len);
    objects[0] = ss(f);

    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index]);
    }

    return objects.join(' ');
  }

  var argLen = args.length;
  if (argLen === 0) return f;
  var x = '';
  var str = '';
  var a = 1 - offset;
  var lastPos = 0;
  var flen = f && f.length || 0;

  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      switch (f.charCodeAt(i + 1)) {
        case 100:
          // 'd'
          if (a >= argLen) break;
          if (lastPos < i) str += f.slice(lastPos, i);
          if (args[a] == null) break;
          str += Number(args[a]);
          lastPos = i = i + 2;
          break;

        case 79: // 'O'

        case 111: // 'o'

        case 106:
          // 'j'
          if (a >= argLen) break;
          if (lastPos < i) str += f.slice(lastPos, i);
          if (args[a] === undefined) break;
          var type = typeof args[a];

          if (type === 'string') {
            str += '\'' + args[a] + '\'';
            lastPos = i + 2;
            i++;
            break;
          }

          if (type === 'function') {
            str += args[a].name || '<anonymous>';
            lastPos = i + 2;
            i++;
            break;
          }

          str += ss(args[a]);
          lastPos = i + 2;
          i++;
          break;

        case 115:
          // 's'
          if (a >= argLen) break;
          if (lastPos < i) str += f.slice(lastPos, i);
          str += String(args[a]);
          lastPos = i + 2;
          i++;
          break;

        case 37:
          // '%'
          if (lastPos < i) str += f.slice(lastPos, i);
          str += '%';
          lastPos = i + 2;
          i++;
          break;
      }

      ++a;
    }

    ++i;
  }

  if (lastPos === 0) str = f;else if (lastPos < flen) {
    str += f.slice(lastPos);
  }

  while (a < argLen) {
    x = args[a++];

    if (x === null || typeof x !== 'object') {
      str += ' ' + String(x);
    } else {
      str += ' ' + ss(x);
    }
  }

  return str;
}

},{}],414:[function(require,module,exports){
const RAW = require('random-access-web');

module.exports = function RAA(application) {
  if (!application) throw new Error('Must specify application name for storage');
  return RAW(application);
};

},{"random-access-web":425}],415:[function(require,module,exports){
(function (Buffer){(function (){
const ras = require('random-access-storage');

const TYPE = {
  type: 'octet/stream'
};
const requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
const persistentStorage = navigator.persistentStorage || navigator.webkitPersistentStorage;
const FileReader = window.FileReader;
const Blob = window.Blob;
createFile.DEFAULT_MAX_SIZE = Number.MAX_SAFE_INTEGER;
createFile.requestQuota = requestQuota;
module.exports = createFile;

function requestQuota(n, force, cb) {
  if (typeof force === 'function') return requestQuota(n, true, force);
  persistentStorage.queryUsageAndQuota(function (used, quota) {
    if (quota && !force) return cb(null, quota);
    persistentStorage.requestQuota(n, function (quota) {
      cb(null, quota);
    }, cb);
  }, cb);
}

function createFile(name, opts) {
  if (!opts) opts = {};
  const maxSize = opts.maxSize || createFile.DEFAULT_MAX_SIZE;
  const mutex = new Mutex();
  var fs = null;
  var entry = null;
  var toDestroy = null;
  var readers = [];
  var writers = [];
  return ras({
    read,
    write,
    open,
    stat,
    close,
    destroy
  });

  function read(req) {
    const r = readers.pop() || new ReadRequest(readers, entry, mutex);
    r.run(req);
  }

  function write(req) {
    const w = writers.pop() || new WriteRequest(writers, entry, mutex);
    w.run(req);
  }

  function close(req) {
    readers = writers = entry = fs = null;
    req.callback(null);
  }

  function stat(req) {
    entry.file(file => {
      req.callback(null, file);
    }, err => req.callback(err));
  }

  function destroy(req) {
    toDestroy.remove(ondone, onerror);

    function ondone() {
      toDestroy = null;
      req.callback(null, null);
    }

    function onerror(err) {
      toDestroy = null;
      req.callback(err, null);
    }
  }

  function open(req) {
    requestQuota(maxSize, false, function (err, granted) {
      if (err) return onerror(err);
      requestFileSystem(window.PERSISTENT, granted, function (res) {
        fs = res;
        mkdirp(parentFolder(name), function () {
          fs.root.getFile(name, {
            create: true
          }, function (e) {
            entry = toDestroy = e;
            req.callback(null);
          }, onerror);
        });
      }, onerror);
    });

    function mkdirp(name, ondone) {
      if (!name) return ondone();
      fs.root.getDirectory(name, {
        create: true
      }, ondone, function () {
        mkdirp(parentFolder(name), function () {
          fs.root.getDirectory(name, {
            create: true
          }, ondone, ondone);
        });
      });
    }

    function onerror(err) {
      fs = entry = null;
      req.callback(err);
    }
  }
}

function parentFolder(path) {
  const i = path.lastIndexOf('/');
  const j = path.lastIndexOf('\\');
  const p = path.slice(0, Math.max(0, i, j));
  return /^\w:$/.test(p) ? '' : p;
}

function WriteRequest(pool, entry, mutex) {
  this.pool = pool;
  this.entry = entry;
  this.mutex = mutex;
  this.writer = null;
  this.req = null;
  this.locked = false;
  this.truncating = false;
}

WriteRequest.prototype.makeWriter = function () {
  const self = this;
  this.entry.createWriter(function (writer) {
    self.writer = writer;

    writer.onwriteend = function () {
      self.onwrite(null);
    };

    writer.onerror = function (err) {
      self.onwrite(err);
    };

    self.run(self.req);
  });
};

WriteRequest.prototype.onwrite = function (err) {
  const req = this.req;
  this.req = null;

  if (this.locked) {
    this.locked = false;
    this.mutex.release();
  }

  if (this.truncating) {
    this.truncating = false;
    if (!err) return this.run(req);
  }

  this.pool.push(this);
  req.callback(err, null);
};

WriteRequest.prototype.truncate = function () {
  this.truncating = true;
  this.writer.truncate(this.req.offset);
};

WriteRequest.prototype.lock = function () {
  if (this.locked) return true;
  this.locked = this.mutex.lock(this);
  return this.locked;
};

WriteRequest.prototype.run = function (req) {
  this.entry.file(file => {
    this.req = req;
    if (!this.writer || this.writer.length !== file.size) return this.makeWriter();
    const end = req.offset + req.size;
    if (end > file.size && !this.lock()) return;

    if (req.offset > this.writer.length) {
      if (req.offset > file.size) return this.truncate();
      return this.makeWriter();
    }

    this.writer.seek(req.offset);
    this.writer.write(new Blob([req.data], TYPE));
  }, err => req.callback(err));
};

function Mutex() {
  this.queued = null;
}

Mutex.prototype.release = function () {
  const queued = this.queued;
  this.queued = null;

  for (var i = 0; i < queued.length; i++) {
    queued[i].run(queued[i].req);
  }
};

Mutex.prototype.lock = function (req) {
  if (this.queued) {
    this.queued.push(req);
    return false;
  }

  this.queued = [];
  return true;
};

function ReadRequest(pool, entry, mutex) {
  this.pool = pool;
  this.entry = entry;
  this.mutex = mutex;
  this.reader = new FileReader();
  this.req = null;
  this.retry = true;
  this.locked = false;
  const self = this;

  this.reader.onerror = function () {
    self.onread(this.error, null);
  };

  this.reader.onload = function () {
    const buf = Buffer.from(this.result);
    self.onread(null, buf);
  };
}

ReadRequest.prototype.lock = function () {
  if (this.locked) return true;
  this.locked = this.mutex.lock(this);
  return this.locked;
};

ReadRequest.prototype.onread = function (err, buf) {
  const req = this.req;

  if (err && this.retry) {
    this.retry = false;
    if (this.lock(this)) this.run(req);
    return;
  }

  this.req = null;
  this.pool.push(this);
  this.retry = true;

  if (this.locked) {
    this.locked = false;
    this.mutex.release();
  }

  req.callback(err, buf);
};

ReadRequest.prototype.run = function (req) {
  this.entry.file(file => {
    const end = req.offset + req.size;
    this.req = req;
    if (end > file.size) return this.onread(new Error('Could not satisfy length'), null);
    this.reader.readAsArrayBuffer(file.slice(req.offset, end));
  }, err => req.callback(err));
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"random-access-storage":424}],416:[function(require,module,exports){
module.exports = function () {
  throw new Error('random-access-file is not supported in the browser');
};

},{}],417:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const indexedDB = exports.indexedDB = window.indexedDB;

},{}],418:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _randomAccessStorage = require("random-access-storage");

var _randomAccessStorage2 = _interopRequireDefault(_randomAccessStorage);

var _IndexedDB = require("./IndexedDB");

var _buffer = require("buffer");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const promise = request => new Promise((resolve, reject) => {
  request.onsuccess = () => resolve(request.result);

  request.onerror = () => reject(request.error);
});

class RandomAccessIDBFileVolume {
  constructor(db, name, version, storeName, options) {
    this.db = db;
    this.name = name;
    this.version = version;
    this.storeName = storeName;
    this.options = options;
  }

  store() {
    const {
      db,
      storeName
    } = this;
    const transaction = db.transaction([storeName], "readwrite");
    return transaction.objectStore(storeName);
  }

  async delete(url) {
    return await promise(this.store().delete(url));
  }

  async save(url, file) {
    return await promise(this.store().put(file, url));
  }

  async open(url, mode) {
    const file = await promise(this.store().get(url));

    if (file) {
      return file;
    } else if (mode === "readwrite") {
      const file = await promise(this.db.createMutableFile(url, "binary/random"));
      await this.save(url, file);
      return file;
    } else {
      throw new RangeError(`File ${url} does not exist`);
    }
  }

  mount(file, options) {
    return new RandomAccessProvider(this, `/${file}`, options);
  }

}

class RandomAccessProvider extends _randomAccessStorage2.default {
  static async mount(options = {}) {
    if (!self.IDBMutableFile) {
      throw Error(`Runtime does not supports IDBMutableFile https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile`);
    } else {
      const name = options.name || `RandomAccess`;
      const version = options.version || 1.0;
      const storeName = options.storeName || `IDBMutableFile`;

      const request = _IndexedDB.indexedDB.open(name, version);

      request.onupgradeneeded = () => {
        const db = request.result;

        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName);
        }
      };

      const db = await promise(request);
      const volume = new RandomAccessIDBFileVolume(db, name, version, storeName, options);
      return (path, options) => volume.mount(path, options);
    }
  }

  static async open(self, request) {
    const {
      options
    } = self;
    const mode = request.preferReadonly ? "readonly" : "readwrite";
    self.debug && console.log(`>> open ${self.url} ${mode}`);

    if (!self.file || self.mode !== mode && mode === "readwrite") {
      self.mode = mode;
      self.file = await self.volume.open(self.url, mode);
    }

    if (!(mode === "readonly" || !options.truncate)) {
      const file = self.activate();
      await promise(file.truncate(options.size || 0));
    }

    self.debug && console.log(`<< open ${self.url} ${mode}`);
  }

  static async read(self, {
    data,
    offset,
    size
  }) {
    self.debug && console.log(`>> read ${self.url} <${offset}, ${size}>`);

    const buffer = data || _buffer.Buffer.allocUnsafe(size);

    if (size === 0) {
      return buffer;
    }

    const file = self.activate();
    file.location = offset;
    const chunk = await promise(file.readAsArrayBuffer(size));

    if (chunk.byteLength !== size) {
      throw new Error("Could not satisfy length");
    }

    _buffer.Buffer.from(chunk).copy(buffer);

    self.debug && console.log(`<< read ${self.url} <${offset}, ${size}>`, buffer);
    return buffer;
  }

  static async write(self, {
    data,
    offset,
    size
  }) {
    self.debug && console.log(`>> write ${self.url} <${offset}, ${size}>`, data);
    const {
      byteLength,
      byteOffset
    } = data;
    const chunk = byteLength === size ? data : data.slice(0, size);
    const file = self.activate();
    file.location = offset;
    const wrote = await promise(file.write(chunk));
    self.debug && console.log(`<< write ${self.url} <${offset}, ${size}>`);
    return wrote;
  }

  static async delete(self, {
    offset,
    size
  }) {
    self.debug && console.log(`>> delete ${self.url} <${offset}, ${size}>`);
    const stat = await this.stat(self);

    if (offset + size >= stat.size) {
      const file = self.activate();
      await promise(file.truncate(offset));
    }

    self.debug && console.log(`<< delete ${self.url} <${offset}, ${size}>`);
  }

  static async stat(self) {
    self.debug && console.log(`>> stat ${self.url}`);
    const file = self.activate();
    const stat = await promise(file.getMetadata());
    self.debug && console.log(`<< stat {size:${stat.size}} ${self.url} `);
    return stat;
  }

  static async close(self) {
    self.debug && console.log(`>> close ${self.url}`);
    const {
      lockedFile
    } = self;

    if (lockedFile && lockedFile.active) {
      await promise(lockedFile.flush());
    }

    self.lockedFile = null;
    self.file = null;
    self.debug && console.log(`<< close ${self.url}`);
  }

  static async destroy(self) {
    self.debug && console.log(`>> destroy ${self.url}`);
    await self.volume.delete(self.url);
    self.debug && console.log(`<< destroy ${self.url}`);
  }

  static async awake(self) {
    const {
      workQueue
    } = self;
    self.isIdle = false;
    let index = 0;

    while (index < workQueue.length) {
      const request = workQueue[index++];
      await this.perform(self, request);
    }

    workQueue.length = 0;
    self.isIdle = true;
  }

  static schedule(self, request) {
    self.workQueue.push(request);

    if (self.isIdle) {
      this.awake(self);
    }
  }

  static async perform(self, request) {
    try {
      switch (request.type) {
        case RequestType.open:
          {
            return request.callback(null, await this.open(self, request));
          }

        case RequestType.read:
          {
            return request.callback(null, await this.read(self, request));
          }

        case RequestType.write:
          {
            return request.callback(null, await this.write(self, request));
          }

        case RequestType.delete:
          {
            return request.callback(null, await this.delete(self, request));
          }

        case RequestType.stat:
          {
            return request.callback(null, await this.stat(self));
          }

        case RequestType.close:
          {
            return request.callback(null, await this.close(self));
          }

        case RequestType.destroy:
          {
            return request.callback(null, await this.destroy(self));
          }
      }
    } catch (error) {
      request.callback(error);
    }
  }

  _open(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _openReadonly(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _write(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _read(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _del(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _stat(request) {
    RandomAccessProvider.perform(this, request);
  }

  _close(request) {
    RandomAccessProvider.schedule(this, request);
  }

  _destroy(request) {
    RandomAccessProvider.schedule(this, request);
  }

  constructor(volume, url, options = {}) {
    super();
    this.volume = volume;
    this.url = url;
    this.options = options;
    this.mode = "readonly";
    this.file = null;
    this.lockedFile = null;
    this.workQueue = [];
    this.isIdle = true;
    this.debug = !!volume.options.debug;
  }

  activate() {
    const {
      lockedFile,
      file,
      mode
    } = this;

    if (lockedFile && lockedFile.active) {
      return lockedFile;
    } else if (file) {
      const lockedFile = file.open(mode);
      this.lockedFile = lockedFile;
      return lockedFile;
    } else {
      throw new RangeError(`Unable to activate file, likely provider was destroyed`);
    }
  }

}

const RequestType = {
  open: 0,
  read: 1,
  write: 2,
  delete: 3,
  stat: 4,
  close: 5,
  destroy: 6
};
exports.default = RandomAccessProvider;
module.exports = exports["default"];

},{"./IndexedDB":417,"buffer":97,"random-access-storage":419}],419:[function(require,module,exports){
(function (process){(function (){
var events = require('events');

var inherits = require('inherits');

var NOT_READABLE = defaultImpl(new Error('Not readable'));
var NOT_WRITABLE = defaultImpl(new Error('Not writable'));
var NOT_DELETABLE = defaultImpl(new Error('Not deletable'));
var NOT_STATABLE = defaultImpl(new Error('Not statable'));
var NO_OPEN_READABLE = defaultImpl(new Error('No readonly open'));
module.exports = RandomAccess;

function RandomAccess(opts) {
  if (!(this instanceof RandomAccess)) return new RandomAccess(opts);
  events.EventEmitter.call(this);
  this._queued = [];
  this._pending = 0;
  this._needsOpen = true;
  this.opened = false;
  this.closed = false;
  this.destroyed = false;

  if (opts) {
    if (opts.openReadonly) this._openReadonly = opts.openReadonly;
    if (opts.open) this._open = opts.open;
    if (opts.read) this._read = opts.read;
    if (opts.write) this._write = opts.write;
    if (opts.del) this._del = opts.del;
    if (opts.stat) this._stat = opts.stat;
    if (opts.close) this._close = opts.close;
    if (opts.destroy) this._destroy = opts.destroy;
  }

  this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE;
  this.readable = this._read !== NOT_READABLE;
  this.writable = this._write !== NOT_WRITABLE;
  this.deletable = this._del !== NOT_DELETABLE;
  this.statable = this._stat !== NOT_STATABLE;
}

inherits(RandomAccess, events.EventEmitter);

RandomAccess.prototype.open = function (cb) {
  if (!cb) cb = noop;
  if (this.opened && !this._needsOpen) return process.nextTick(cb, null);
  queueAndRun(this, new Request(this, 0, 0, 0, null, cb));
};

RandomAccess.prototype._open = defaultImpl(null);
RandomAccess.prototype._openReadonly = NO_OPEN_READABLE;

RandomAccess.prototype.read = function (offset, size, cb) {
  this.run(new Request(this, 1, offset, size, null, cb));
};

RandomAccess.prototype._read = NOT_READABLE;

RandomAccess.prototype.write = function (offset, data, cb) {
  if (!cb) cb = noop;
  openWritable(this);
  this.run(new Request(this, 2, offset, data.length, data, cb));
};

RandomAccess.prototype._write = NOT_WRITABLE;

RandomAccess.prototype.del = function (offset, size, cb) {
  if (!cb) cb = noop;
  openWritable(this);
  this.run(new Request(this, 3, offset, size, null, cb));
};

RandomAccess.prototype._del = NOT_DELETABLE;

RandomAccess.prototype.stat = function (cb) {
  this.run(new Request(this, 4, 0, 0, null, cb));
};

RandomAccess.prototype._stat = NOT_STATABLE;

RandomAccess.prototype.close = function (cb) {
  if (!cb) cb = noop;
  if (this.closed) return process.nextTick(cb, null);
  queueAndRun(this, new Request(this, 5, 0, 0, null, cb));
};

RandomAccess.prototype._close = defaultImpl(null);

RandomAccess.prototype.destroy = function (cb) {
  if (!cb) cb = noop;
  if (!this.closed) this.close(noop);
  queueAndRun(this, new Request(this, 6, 0, 0, null, cb));
};

RandomAccess.prototype._destroy = defaultImpl(null);

RandomAccess.prototype.run = function (req) {
  if (this._needsOpen) this.open(noop);
  if (this._queued.length) this._queued.push(req);else req._run();
};

function noop() {}

function Request(self, type, offset, size, data, cb) {
  this.type = type;
  this.offset = offset;
  this.data = data;
  this.size = size;
  this.storage = self;
  this._sync = false;
  this._callback = cb;
  this._openError = null;
}

Request.prototype._maybeOpenError = function (err) {
  if (this.type !== 0) return;
  var queued = this.storage._queued;

  for (var i = 0; i < queued.length; i++) queued[i]._openError = err;
};

Request.prototype._unqueue = function (err) {
  var ra = this.storage;
  var queued = ra._queued;

  if (!err) {
    switch (this.type) {
      case 0:
        if (!ra.opened) {
          ra.opened = true;
          ra.emit('open');
        }

        break;

      case 5:
        if (!ra.closed) {
          ra.closed = true;
          ra.emit('close');
        }

        break;

      case 6:
        if (!ra.destroyed) {
          ra.destroyed = true;
          ra.emit('destroy');
        }

        break;
    }
  } else {
    this._maybeOpenError(err);
  }

  if (queued.length && queued[0] === this) queued.shift();
  if (! --ra._pending && queued.length) queued[0]._run();
};

Request.prototype.callback = function (err, val) {
  if (this._sync) return nextTick(this, err, val);

  this._unqueue(err);

  this._callback(err, val);
};

Request.prototype._openAndNotClosed = function () {
  var ra = this.storage;
  if (ra.opened && !ra.closed) return true;
  if (!ra.opened) nextTick(this, this._openError || new Error('Not opened'));else if (ra.closed) nextTick(this, new Error('Closed'));
  return false;
};

Request.prototype._open = function () {
  var ra = this.storage;
  if (ra.opened && !ra._needsOpen) return nextTick(this, null);
  if (ra.closed) return nextTick(this, new Error('Closed'));
  ra._needsOpen = false;
  if (ra.preferReadonly) ra._openReadonly(this);else ra._open(this);
};

Request.prototype._run = function () {
  var ra = this.storage;
  ra._pending++;
  this._sync = true;

  switch (this.type) {
    case 0:
      this._open();

      break;

    case 1:
      if (this._openAndNotClosed()) ra._read(this);
      break;

    case 2:
      if (this._openAndNotClosed()) ra._write(this);
      break;

    case 3:
      if (this._openAndNotClosed()) ra._del(this);
      break;

    case 4:
      if (this._openAndNotClosed()) ra._stat(this);
      break;

    case 5:
      if (ra.closed || !ra.opened) nextTick(this, null);else ra._close(this);
      break;

    case 6:
      if (ra.destroyed) nextTick(this, null);else ra._destroy(this);
      break;
  }

  this._sync = false;
};

function queueAndRun(self, req) {
  self._queued.push(req);

  if (!self._pending) req._run();
}

function openWritable(self) {
  if (self.preferReadonly) {
    self._needsOpen = true;
    self.preferReadonly = false;
  }
}

function defaultImpl(err) {
  return overridable;

  function overridable(req) {
    nextTick(req, err);
  }
}

function nextTick(req, err, val) {
  process.nextTick(nextTickCallback, req, err, val);
}

function nextTickCallback(req, err, val) {
  req.callback(err, val);
}

}).call(this)}).call(this,require('_process'))
},{"_process":380,"events":172,"inherits":279}],420:[function(require,module,exports){
(function (Buffer){(function (){
var RandomAccess = require('random-access-storage');

var inherits = require('inherits');

var nextTick = require('next-tick');

var once = require('once');

var blocks = require("./lib/blocks.js");

var bufferFrom = require('buffer-from');

var bufferAlloc = require('buffer-alloc');

var DELIM = '\0';
var win = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {};

module.exports = function (dbname, xopts) {
  if (!xopts) xopts = {};
  var idb = xopts.idb || (typeof win !== 'undefined' ? win.indexedDB || win.mozIndexedDB || win.webkitIndexedDB || win.msIndexedDB : null);
  if (!idb) throw new Error('indexedDB not present and not given');
  var db = null,
      dbqueue = [];

  if (typeof idb.open === 'function') {
    var req = idb.open(dbname);
    req.addEventListener('upgradeneeded', function () {
      db = req.result;
      db.createObjectStore('data');
    });
    req.addEventListener('success', function () {
      db = req.result;
      dbqueue.forEach(function (cb) {
        cb(db);
      });
      dbqueue = null;
    });
  } else {
    db = idb;
  }

  return function (name, opts) {
    if (typeof name === 'object') {
      opts = name;
      name = opts.name;
    }

    if (!opts) opts = {};
    opts.name = name;
    return new Store(Object.assign({
      db: getdb
    }, xopts, opts));
  };

  function getdb(cb) {
    if (db) nextTick(function () {
      cb(db);
    });else dbqueue.push(cb);
  }
};

function Store(opts) {
  if (!(this instanceof Store)) return new Store(opts);
  RandomAccess.call(this);
  if (!opts) opts = {};
  if (typeof opts === 'string') opts = {
    name: opts
  };
  this.size = opts.size || 4096;
  this.name = opts.name;
  this.length = opts.length || 0;
  this._getdb = opts.db;
}

inherits(Store, RandomAccess);

Store.prototype._blocks = function (i, j) {
  return blocks(this.size, i, j);
};

Store.prototype._read = function (req) {
  var self = this;
  var buffers = [];

  self._store('readonly', function (err, store) {
    if ((self.length || 0) < req.offset + req.size) {
      return req.callback(new Error('Could not satisfy length'));
    }

    if (err) return req.callback(err);

    var offsets = self._blocks(req.offset, req.offset + req.size);

    var pending = offsets.length + 1;
    var firstBlock = offsets.length > 0 ? offsets[0].block : 0;
    var j = 0;

    for (var i = 0; i < offsets.length; i++) (function (o) {
      var key = self.name + DELIM + o.block;
      backify(store.get(key), function (err, ev) {
        if (err) return req.callback(err);
        buffers[o.block - firstBlock] = ev.target.result ? bufferFrom(ev.target.result.subarray(o.start, o.end)) : bufferAlloc(o.end - o.start);
        if (--pending === 0) req.callback(null, Buffer.concat(buffers));
      });
    })(offsets[i]);

    if (--pending === 0) req.callback(null, Buffer.concat(buffers));
  });
};

Store.prototype._write = function (req) {
  var self = this;

  self._store('readwrite', function (err, store) {
    if (err) return req.callback(err);

    var offsets = self._blocks(req.offset, req.offset + req.data.length);

    var pending = 1;
    var buffers = {};

    for (var i = 0; i < offsets.length; i++) (function (o, i) {
      if (o.end - o.start === self.size) return;
      pending++;
      var key = self.name + DELIM + o.block;
      backify(store.get(key), function (err, ev) {
        if (err) return req.callback(err);
        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size));
        if (--pending === 0) write(store, offsets, buffers);
      });
    })(offsets[i], i);

    if (--pending === 0) write(store, offsets, buffers);
  });

  function write(store, offsets, buffers) {
    for (var i = 0, j = 0; i < offsets.length; i++) {
      var o = offsets[i];
      var len = o.end - o.start;

      if (len === self.size) {
        block = bufferFrom(req.data.slice(j, j + len));
      } else {
        block = buffers[i];
        req.data.copy(block, o.start, j, j + len);
      }

      store.put(block, self.name + DELIM + o.block);
      j += len;
    }

    var length = Math.max(self.length || 0, req.offset + req.data.length);
    store.put(length, self.name + DELIM + 'length');
    store.transaction.addEventListener('complete', function () {
      self.length = length;
      req.callback(null);
    });
    store.transaction.addEventListener('error', function (err) {
      req.callback(err);
    });
  }
};

Store.prototype._store = function (mode, cb) {
  cb = once(cb);
  var self = this;

  self._getdb(function (db) {
    var tx = db.transaction(['data'], mode);
    var store = tx.objectStore('data');
    tx.addEventListener('error', cb);
    cb(null, store);
  });
};

Store.prototype._open = function (req) {
  var self = this;

  this._getdb(function (db) {
    self._store('readonly', function (err, store) {
      backify(store.get(self.name + DELIM + "length"), function (err, ev) {
        self.length = ev.target.result || 0;
        req.callback(null);
      });
    });
  });
};

Store.prototype._close = function (req) {
  this._getdb(function (db) {
    db.close();
    req.callback();
  });
};

Store.prototype._stat = function (req) {
  var self = this;
  nextTick(function () {
    req.callback(null, {
      size: self.length
    });
  });
};

function backify(r, cb) {
  r.addEventListener('success', function (ev) {
    cb(null, ev);
  });
  r.addEventListener('error', cb);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/blocks.js":421,"buffer":97,"buffer-alloc":93,"buffer-from":422,"inherits":279,"next-tick":346,"once":358,"random-access-storage":424}],421:[function(require,module,exports){
module.exports = function (size, start, end) {
  var result = [];

  for (var n = Math.floor(start / size) * size; n < end; n += size) {
    result.push({
      block: Math.floor(n / size),
      start: Math.max(n, start) % size,
      end: Math.min(n + size, end) % size || size
    });
  }

  return result;
};

},{}],422:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"buffer":97,"dup":95}],423:[function(require,module,exports){
(function (process,Buffer){(function (){
const RandomAccess = require('random-access-storage');

const isOptions = require('is-options');

const inherits = require('inherits');

const DEFAULT_PAGE_SIZE = 1024 * 1024;
module.exports = RAM;

function RAM(opts) {
  if (!(this instanceof RAM)) return new RAM(opts);
  if (typeof opts === 'number') opts = {
    length: opts
  };
  if (!opts) opts = {};
  RandomAccess.call(this);

  if (Buffer.isBuffer(opts)) {
    opts = {
      length: opts.length,
      buffer: opts
    };
  }

  if (!isOptions(opts)) opts = {};
  this.length = opts.length || 0;
  this.pageSize = opts.length || opts.pageSize || DEFAULT_PAGE_SIZE;
  this.buffers = [];
  if (opts.buffer) this.buffers.push(opts.buffer);
}

inherits(RAM, RandomAccess);

RAM.prototype._stat = function (req) {
  callback(req, null, {
    size: this.length
  });
};

RAM.prototype._write = function (req) {
  var i = Math.floor(req.offset / this.pageSize);
  var rel = req.offset - i * this.pageSize;
  var start = 0;
  const len = req.offset + req.size;
  if (len > this.length) this.length = len;

  while (start < req.size) {
    const page = this._page(i++, true);

    const free = this.pageSize - rel;
    const end = free < req.size - start ? start + free : req.size;
    req.data.copy(page, rel, start, end);
    start = end;
    rel = 0;
  }

  callback(req, null, null);
};

RAM.prototype._read = function (req) {
  var i = Math.floor(req.offset / this.pageSize);
  var rel = req.offset - i * this.pageSize;
  var start = 0;

  if (req.offset + req.size > this.length) {
    return callback(req, new Error('Could not satisfy length'), null);
  }

  const data = Buffer.alloc(req.size);

  while (start < req.size) {
    const page = this._page(i++, false);

    const avail = this.pageSize - rel;
    const wanted = req.size - start;
    const len = avail < wanted ? avail : wanted;
    if (page) page.copy(data, start, rel, rel + len);
    start += len;
    rel = 0;
  }

  callback(req, null, data);
};

RAM.prototype._del = function (req) {
  var i = Math.floor(req.offset / this.pageSize);
  var rel = req.offset - i * this.pageSize;
  var start = 0;

  if (rel && req.offset + req.size >= this.length) {
    var buf = this.buffers[i];
    if (buf) buf.fill(0, rel);
  }

  if (req.offset + req.size > this.length) {
    req.size = Math.max(0, this.length - req.offset);
  }

  while (start < req.size) {
    if (rel === 0 && req.size - start >= this.pageSize) {
      this.buffers[i++] = undefined;
    }

    rel = 0;
    start += this.pageSize - rel;
  }

  if (req.offset + req.size >= this.length) {
    this.length = req.offset;
  }

  callback(req, null, null);
};

RAM.prototype._destroy = function (req) {
  this._buffers = [];
  this.length = 0;
  callback(req, null, null);
};

RAM.prototype._page = function (i, upsert) {
  var page = this.buffers[i];
  if (page || !upsert) return page;
  page = this.buffers[i] = Buffer.alloc(this.pageSize);
  return page;
};

RAM.prototype.toBuffer = function () {
  const buf = Buffer.alloc(this.length);

  for (var i = 0; i < this.buffers.length; i++) {
    if (this.buffers[i]) this.buffers[i].copy(buf, i * this.pageSize);
  }

  return buf;
};

function callback(req, err, data) {
  process.nextTick(callbackNT, req, err, data);
}

function callbackNT(req, err, data) {
  req.callback(err, data);
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":380,"buffer":97,"inherits":279,"is-options":284,"random-access-storage":424}],424:[function(require,module,exports){
(function (process){(function (){
var events = require('events');

var inherits = require('inherits');

var NOT_READABLE = defaultImpl(new Error('Not readable'));
var NOT_WRITABLE = defaultImpl(new Error('Not writable'));
var NOT_DELETABLE = defaultImpl(new Error('Not deletable'));
var NOT_STATABLE = defaultImpl(new Error('Not statable'));
var NO_OPEN_READABLE = defaultImpl(new Error('No readonly open')); // NON_BLOCKING_OPS

var READ_OP = 0;
var WRITE_OP = 1;
var DEL_OP = 2;
var STAT_OP = 3; // BLOCKING_OPS

var OPEN_OP = 4;
var CLOSE_OP = 5;
var DESTROY_OP = 6;
module.exports = RandomAccess;

function RandomAccess(opts) {
  if (!(this instanceof RandomAccess)) return new RandomAccess(opts);
  events.EventEmitter.call(this);
  this._queued = [];
  this._pending = 0;
  this._needsOpen = true;
  this.opened = false;
  this.closed = false;
  this.destroyed = false;

  if (opts) {
    if (opts.openReadonly) this._openReadonly = opts.openReadonly;
    if (opts.open) this._open = opts.open;
    if (opts.read) this._read = opts.read;
    if (opts.write) this._write = opts.write;
    if (opts.del) this._del = opts.del;
    if (opts.stat) this._stat = opts.stat;
    if (opts.close) this._close = opts.close;
    if (opts.destroy) this._destroy = opts.destroy;
  }

  this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE;
  this.readable = this._read !== NOT_READABLE;
  this.writable = this._write !== NOT_WRITABLE;
  this.deletable = this._del !== NOT_DELETABLE;
  this.statable = this._stat !== NOT_STATABLE;
}

inherits(RandomAccess, events.EventEmitter);

RandomAccess.prototype.read = function (offset, size, cb) {
  this.run(new Request(this, READ_OP, offset, size, null, cb));
};

RandomAccess.prototype._read = NOT_READABLE;

RandomAccess.prototype.write = function (offset, data, cb) {
  if (!cb) cb = noop;
  openWritable(this);
  this.run(new Request(this, WRITE_OP, offset, data.length, data, cb));
};

RandomAccess.prototype._write = NOT_WRITABLE;

RandomAccess.prototype.del = function (offset, size, cb) {
  if (!cb) cb = noop;
  openWritable(this);
  this.run(new Request(this, DEL_OP, offset, size, null, cb));
};

RandomAccess.prototype._del = NOT_DELETABLE;

RandomAccess.prototype.stat = function (cb) {
  this.run(new Request(this, STAT_OP, 0, 0, null, cb));
};

RandomAccess.prototype._stat = NOT_STATABLE;

RandomAccess.prototype.open = function (cb) {
  if (!cb) cb = noop;
  if (this.opened && !this._needsOpen) return process.nextTick(cb, null);
  queueAndRun(this, new Request(this, OPEN_OP, 0, 0, null, cb));
};

RandomAccess.prototype._open = defaultImpl(null);
RandomAccess.prototype._openReadonly = NO_OPEN_READABLE;

RandomAccess.prototype.close = function (cb) {
  if (!cb) cb = noop;
  if (this.closed) return process.nextTick(cb, null);
  queueAndRun(this, new Request(this, CLOSE_OP, 0, 0, null, cb));
};

RandomAccess.prototype._close = defaultImpl(null);

RandomAccess.prototype.destroy = function (cb) {
  if (!cb) cb = noop;
  if (!this.closed) this.close(noop);
  queueAndRun(this, new Request(this, DESTROY_OP, 0, 0, null, cb));
};

RandomAccess.prototype._destroy = defaultImpl(null);

RandomAccess.prototype.run = function (req) {
  if (this._needsOpen) this.open(noop);
  if (this._queued.length) this._queued.push(req);else req._run();
};

function noop() {}

function Request(self, type, offset, size, data, cb) {
  this.type = type;
  this.offset = offset;
  this.data = data;
  this.size = size;
  this.storage = self;
  this._sync = false;
  this._callback = cb;
  this._openError = null;
}

Request.prototype._maybeOpenError = function (err) {
  if (this.type !== OPEN_OP) return;
  var queued = this.storage._queued;

  for (var i = 0; i < queued.length; i++) queued[i]._openError = err;
};

Request.prototype._unqueue = function (err) {
  var ra = this.storage;
  var queued = ra._queued;

  if (!err) {
    switch (this.type) {
      case OPEN_OP:
        if (!ra.opened) {
          ra.opened = true;
          ra.emit('open');
        }

        break;

      case CLOSE_OP:
        if (!ra.closed) {
          ra.closed = true;
          ra.emit('close');
        }

        break;

      case DESTROY_OP:
        if (!ra.destroyed) {
          ra.destroyed = true;
          ra.emit('destroy');
        }

        break;
    }
  } else {
    this._maybeOpenError(err);
  }

  if (queued.length && queued[0] === this) queued.shift();
  if (! --ra._pending) drainQueue(ra);
};

Request.prototype.callback = function (err, val) {
  if (this._sync) return nextTick(this, err, val);

  this._unqueue(err);

  this._callback(err, val);
};

Request.prototype._openAndNotClosed = function () {
  var ra = this.storage;
  if (ra.opened && !ra.closed) return true;
  if (!ra.opened) nextTick(this, this._openError || new Error('Not opened'));else if (ra.closed) nextTick(this, new Error('Closed'));
  return false;
};

Request.prototype._open = function () {
  var ra = this.storage;
  if (ra.opened && !ra._needsOpen) return nextTick(this, null);
  if (ra.closed) return nextTick(this, new Error('Closed'));
  ra._needsOpen = false;
  if (ra.preferReadonly) ra._openReadonly(this);else ra._open(this);
};

Request.prototype._run = function () {
  var ra = this.storage;
  ra._pending++;
  this._sync = true;

  switch (this.type) {
    case READ_OP:
      if (this._openAndNotClosed()) ra._read(this);
      break;

    case WRITE_OP:
      if (this._openAndNotClosed()) ra._write(this);
      break;

    case DEL_OP:
      if (this._openAndNotClosed()) ra._del(this);
      break;

    case STAT_OP:
      if (this._openAndNotClosed()) ra._stat(this);
      break;

    case OPEN_OP:
      this._open();

      break;

    case CLOSE_OP:
      if (ra.closed || !ra.opened) nextTick(this, null);else ra._close(this);
      break;

    case DESTROY_OP:
      if (ra.destroyed) nextTick(this, null);else ra._destroy(this);
      break;
  }

  this._sync = false;
};

function queueAndRun(self, req) {
  self._queued.push(req);

  if (!self._pending) req._run();
}

function drainQueue(self) {
  var queued = self._queued;

  while (queued.length > 0) {
    var blocking = queued[0].type > 3;
    if (!blocking || !self._pending) queued[0]._run();
    if (blocking) return;
    queued.shift();
  }
}

function openWritable(self) {
  if (self.preferReadonly) {
    self._needsOpen = true;
    self.preferReadonly = false;
  }
}

function defaultImpl(err) {
  return overridable;

  function overridable(req) {
    nextTick(req, err);
  }
}

function nextTick(req, err, val) {
  process.nextTick(nextTickCallback, req, err, val);
}

function nextTickCallback(req, err, val) {
  req.callback(err, val);
}

}).call(this)}).call(this,require('_process'))
},{"_process":380,"events":172,"inherits":279}],425:[function(require,module,exports){
/* global self */
const global = typeof window !== 'undefined' ? window : self;
const requestFileSystem = global.requestFileSystem || global.webkitRequestFileSystem;
const mutableFile = global.IDBMutableFile;
const idb = global.indexedDB;
const DEFAULT_DB_NAME = 'random-access-web';

let storage = () => require('random-access-memory');

if (requestFileSystem) {
  storage = options => {
    const RACF = require('random-access-chrome-file');

    if (typeof options === 'object' && options.maxSize) {
      RACF.DEFAULT_MAX_SIZE = options.maxSize;
    }

    return RACF;
  };
} else if (mutableFile) {
  storage = (options = {}) => {
    if (typeof options === 'string') options = {
      name: options
    };
    return require("./mutable-file-wrapper.js")(options);
  };
} else if (idb) {
  storage = (options = {}) => {
    if (typeof options === 'string') options = {
      name: options
    };
    const name = options.name || DEFAULT_DB_NAME;
    return require('random-access-idb')(name, options);
  };
}

module.exports = storage;

},{"./mutable-file-wrapper.js":426,"random-access-chrome-file":415,"random-access-idb":420,"random-access-memory":423}],426:[function(require,module,exports){
module.exports = function mutableStorage(options) {
  const randomAccess = require('random-access-storage');

  const mutableAccess = require('random-access-idb-mutable-file');

  let mounted = null;
  let loading = null;

  function doMount() {
    return mutableAccess.mount(options).then(requestFile => {
      mounted = requestFile;
      loading = null;
    });
  }

  return name => {
    let file = null;
    return randomAccess({
      open: function (req) {
        if (!mounted && !loading) {
          loading = doMount();
        }

        if (loading) {
          loading.then(() => {
            this._open(req);
          }, err => {
            req.callback(err);
          });
          return;
        }

        file = mounted(name);
        req.callback();
      },
      write: function (req) {
        file.write(req.offset, req.data, function (err, data) {
          req.callback(err, data);
        });
      },
      read: function (req) {
        file.read(req.offset, req.size, function (err, data) {
          req.callback(err, data);
        });
      },
      del: function (req) {
        file.del(req.offset, req.size, function (err, data) {
          req.callback(err, data);
        });
      },
      stat: function (req) {
        file.stat(function (err, data) {
          req.callback(err, data);
        });
      },
      close: function (req) {
        file.close(function (err, data) {
          req.callback(err, data);
        });
      },
      destroy: function (req) {
        file.destroy(function (err, data) {
          req.callback(err, data);
        });
      }
    });
  };
};

},{"random-access-idb-mutable-file":418,"random-access-storage":424}],427:[function(require,module,exports){
(function (process,global){(function (){
'use strict'; // limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues

var MAX_BYTES = 65536; // Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48

var MAX_UINT32 = 4294967295;

function oldBrowser() {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11');
}

var Buffer = require('safe-buffer').Buffer;

var crypto = global.crypto || global.msCrypto;

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}

function randomBytes(size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes');
  var bytes = Buffer.allocUnsafe(size);

  if (size > 0) {
    // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) {
      // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto.getRandomValues(bytes);
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }

  return bytes;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":380,"safe-buffer":446}],428:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

function oldBrowser() {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
}

var safeBuffer = require('safe-buffer');

var randombytes = require('randombytes');

var Buffer = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto = global.crypto || global.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;

function assertOffset(offset, length) {
  if (typeof offset !== 'number' || offset !== offset) {
    // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number');
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32');
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range');
  }
}

function assertSize(size, offset, length) {
  if (typeof size !== 'number' || size !== size) {
    // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number');
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32');
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small');
  }
}

if (crypto && crypto.getRandomValues || !process.browser) {
  exports.randomFill = randomFill;
  exports.randomFillSync = randomFillSync;
} else {
  exports.randomFill = oldBrowser;
  exports.randomFillSync = oldBrowser;
}

function randomFill(buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }

  if (typeof offset === 'function') {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === 'function') {
    cb = size;
    size = buf.length - offset;
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function');
  }

  assertOffset(offset, buf.length);
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size, cb);
}

function actualFill(buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto.getRandomValues(uint);

    if (cb) {
      process.nextTick(function () {
        cb(null, buf);
      });
      return;
    }

    return buf;
  }

  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err);
      }

      bytes.copy(buf, offset);
      cb(null, buf);
    });
    return;
  }

  var bytes = randombytes(size);
  bytes.copy(buf, offset);
  return buf;
}

function randomFillSync(buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0;
  }

  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }

  assertOffset(offset, buf.length);
  if (size === undefined) size = buf.length - offset;
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":380,"randombytes":427,"safe-buffer":446}],429:[function(require,module,exports){
module.exports = function (arr) {
  if (!Array.isArray(arr)) throw `C'mon pal. You gotta feed this thing *arrays*!`;
  const randomized = [];
  let copy = arr.slice(); // Avoid mutating the original array.

  while (copy.length) {
    const num = Math.floor(Math.random() * copy.length);
    randomized.push(copy.splice(num, 1)[0]);
  }

  return randomized;
};

},{}],430:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require("./_stream_readable");

var Writable = require("./_stream_writable");

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

},{"./_stream_readable":432,"./_stream_writable":434,"core-util-is":119,"inherits":279,"process-nextick-args":379}],431:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require("./_stream_transform");
/*<replacement>*/


var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":433,"core-util-is":119,"inherits":279}],432:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require("./internal/streams/stream");
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var debugUtil = require("../../util/util.js");

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


var BufferList = require("./internal/streams/BufferList");

var destroyImpl = require("./internal/streams/destroy");

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require("./_stream_duplex");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../util/util.js":579,"./_stream_duplex":430,"./internal/streams/BufferList":435,"./internal/streams/destroy":436,"./internal/streams/stream":437,"_process":380,"core-util-is":119,"events":172,"inherits":279,"isarray":286,"process-nextick-args":379,"safe-buffer":438,"string_decoder/":439}],433:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var Duplex = require("./_stream_duplex");
/*<replacement>*/


var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

},{"./_stream_duplex":430,"core-util-is":119,"inherits":279}],434:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require("./internal/streams/stream");
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require("./internal/streams/destroy");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require("./_stream_duplex");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require("./_stream_duplex"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":430,"./internal/streams/destroy":436,"./internal/streams/stream":437,"_process":380,"core-util-is":119,"inherits":279,"process-nextick-args":379,"safe-buffer":438,"timers":571,"util-deprecate":576}],435:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = require('safe-buffer').Buffer;

var util = require("../../../../util/util.js");

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

},{"../../../../util/util.js":579,"safe-buffer":438}],436:[function(require,module,exports){
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":379}],437:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],438:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

},{"buffer":97}],439:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":438}],440:[function(require,module,exports){
exports = module.exports = require("./lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require("./lib/_stream_writable.js");
exports.Duplex = require("./lib/_stream_duplex.js");
exports.Transform = require("./lib/_stream_transform.js");
exports.PassThrough = require("./lib/_stream_passthrough.js");

},{"./lib/_stream_duplex.js":430,"./lib/_stream_passthrough.js":431,"./lib/_stream_readable.js":432,"./lib/_stream_transform.js":433,"./lib/_stream_writable.js":434}],441:[function(require,module,exports){
'use strict';
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

var Event =
/** @class */
function () {
  function Event(type, target) {
    this.target = target;
    this.type = type;
  }

  return Event;
}();

var ErrorEvent =
/** @class */
function (_super) {
  __extends(ErrorEvent, _super);

  function ErrorEvent(error, target) {
    var _this = _super.call(this, 'error', target) || this;

    _this.message = error.message;
    _this.error = error;
    return _this;
  }

  return ErrorEvent;
}(Event);

var CloseEvent =
/** @class */
function (_super) {
  __extends(CloseEvent, _super);

  function CloseEvent(code, reason, target) {
    if (code === void 0) {
      code = 1000;
    }

    if (reason === void 0) {
      reason = '';
    }

    var _this = _super.call(this, 'close', target) || this;

    _this.wasClean = true;
    _this.code = code;
    _this.reason = reason;
    return _this;
  }

  return CloseEvent;
}(Event);
/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */


var getGlobalWebSocket = function () {
  if (typeof WebSocket !== 'undefined') {
    // @ts-ignore
    return WebSocket;
  }
};
/**
 * Returns true if given argument looks like a WebSocket class
 */


var isWebSocket = function (w) {
  return typeof w !== 'undefined' && !!w && w.CLOSING === 2;
};

var DEFAULT = {
  maxReconnectionDelay: 10000,
  minReconnectionDelay: 1000 + Math.random() * 4000,
  minUptime: 5000,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4000,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};

var ReconnectingWebSocket =
/** @class */
function () {
  function ReconnectingWebSocket(url, protocols, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    this._listeners = {
      error: [],
      message: [],
      open: [],
      close: []
    };
    this._retryCount = -1;
    this._shouldReconnect = true;
    this._connectLock = false;
    this._binaryType = 'blob';
    this._closeCalled = false;
    this._messageQueue = [];
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
     */

    this.onclose = null;
    /**
     * An event listener to be called when an error occurs
     */

    this.onerror = null;
    /**
     * An event listener to be called when a message is received from the server
     */

    this.onmessage = null;
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data
     */

    this.onopen = null;

    this._handleOpen = function (event) {
      _this._debug('open event');

      var _a = _this._options.minUptime,
          minUptime = _a === void 0 ? DEFAULT.minUptime : _a;
      clearTimeout(_this._connectTimeout);
      _this._uptimeTimeout = setTimeout(function () {
        return _this._acceptOpen();
      }, minUptime);
      _this._ws.binaryType = _this._binaryType; // send enqueued messages (messages sent before websocket open event)

      _this._messageQueue.forEach(function (message) {
        return _this._ws.send(message);
      });

      _this._messageQueue = [];

      if (_this.onopen) {
        _this.onopen(event);
      }

      _this._listeners.open.forEach(function (listener) {
        return _this._callEventListener(event, listener);
      });
    };

    this._handleMessage = function (event) {
      _this._debug('message event');

      if (_this.onmessage) {
        _this.onmessage(event);
      }

      _this._listeners.message.forEach(function (listener) {
        return _this._callEventListener(event, listener);
      });
    };

    this._handleError = function (event) {
      _this._debug('error event', event.message);

      _this._disconnect(undefined, event.message === 'TIMEOUT' ? 'timeout' : undefined);

      if (_this.onerror) {
        _this.onerror(event);
      }

      _this._debug('exec error listeners');

      _this._listeners.error.forEach(function (listener) {
        return _this._callEventListener(event, listener);
      });

      _this._connect();
    };

    this._handleClose = function (event) {
      _this._debug('close event');

      _this._clearTimeouts();

      if (_this._shouldReconnect) {
        _this._connect();
      }

      if (_this.onclose) {
        _this.onclose(event);
      }

      _this._listeners.close.forEach(function (listener) {
        return _this._callEventListener(event, listener);
      });
    };

    this._url = url;
    this._protocols = protocols;
    this._options = options;

    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }

    this._connect();
  }

  Object.defineProperty(ReconnectingWebSocket, "CONNECTING", {
    get: function () {
      return 0;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket, "OPEN", {
    get: function () {
      return 1;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket, "CLOSING", {
    get: function () {
      return 2;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket, "CLOSED", {
    get: function () {
      return 3;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "CONNECTING", {
    get: function () {
      return ReconnectingWebSocket.CONNECTING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "OPEN", {
    get: function () {
      return ReconnectingWebSocket.OPEN;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "CLOSING", {
    get: function () {
      return ReconnectingWebSocket.CLOSING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "CLOSED", {
    get: function () {
      return ReconnectingWebSocket.CLOSED;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "binaryType", {
    get: function () {
      return this._ws ? this._ws.binaryType : this._binaryType;
    },
    set: function (value) {
      this._binaryType = value;

      if (this._ws) {
        this._ws.binaryType = value;
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "retryCount", {
    /**
     * Returns the number or connection retries
     */
    get: function () {
      return Math.max(this._retryCount, 0);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "bufferedAmount", {
    /**
     * The number of bytes of data that have been queued using calls to send() but not yet
     * transmitted to the network. This value resets to zero once all queued data has been sent.
     * This value does not reset to zero when the connection is closed; if you keep calling send(),
     * this will continue to climb. Read only
     */
    get: function () {
      var bytes = this._messageQueue.reduce(function (acc, message) {
        if (typeof message === 'string') {
          acc += message.length; // not byte size
        } else if (message instanceof Blob) {
          acc += message.size;
        } else {
          acc += message.byteLength;
        }

        return acc;
      }, 0);

      return bytes + (this._ws ? this._ws.bufferedAmount : 0);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "extensions", {
    /**
     * The extensions selected by the server. This is currently only the empty string or a list of
     * extensions as negotiated by the connection
     */
    get: function () {
      return this._ws ? this._ws.extensions : '';
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "protocol", {
    /**
     * A string indicating the name of the sub-protocol the server selected;
     * this will be one of the strings specified in the protocols parameter when creating the
     * WebSocket object
     */
    get: function () {
      return this._ws ? this._ws.protocol : '';
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "readyState", {
    /**
     * The current state of the connection; this is one of the Ready state constants
     */
    get: function () {
      if (this._ws) {
        return this._ws.readyState;
      }

      return this._options.startClosed ? ReconnectingWebSocket.CLOSED : ReconnectingWebSocket.CONNECTING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket.prototype, "url", {
    /**
     * The URL as resolved by the constructor
     */
    get: function () {
      return this._ws ? this._ws.url : '';
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Closes the WebSocket connection or connection attempt, if any. If the connection is already
   * CLOSED, this method does nothing
   */

  ReconnectingWebSocket.prototype.close = function (code, reason) {
    if (code === void 0) {
      code = 1000;
    }

    this._closeCalled = true;
    this._shouldReconnect = false;

    this._clearTimeouts();

    if (!this._ws) {
      this._debug('close enqueued: no ws instance');

      return;
    }

    if (this._ws.readyState === this.CLOSED) {
      this._debug('close: already closed');

      return;
    }

    this._ws.close(code, reason);
  };
  /**
   * Closes the WebSocket connection or connection attempt and connects again.
   * Resets retry counter;
   */


  ReconnectingWebSocket.prototype.reconnect = function (code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;

    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);

      this._connect();
    }
  };
  /**
   * Enqueue specified data to be transmitted to the server over the WebSocket connection
   */


  ReconnectingWebSocket.prototype.send = function (data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug('send', data);

      this._ws.send(data);
    } else {
      var _a = this._options.maxEnqueuedMessages,
          maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;

      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug('enqueue', data);

        this._messageQueue.push(data);
      }
    }
  };
  /**
   * Register an event handler of a specific event type
   */


  ReconnectingWebSocket.prototype.addEventListener = function (type, listener) {
    if (this._listeners[type]) {
      // @ts-ignore
      this._listeners[type].push(listener);
    }
  };

  ReconnectingWebSocket.prototype.dispatchEvent = function (event) {
    var e_1, _a;

    var listeners = this._listeners[event.type];

    if (listeners) {
      try {
        for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
          var listener = listeners_1_1.value;

          this._callEventListener(event, listener);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }

    return true;
  };
  /**
   * Removes an event listener
   */


  ReconnectingWebSocket.prototype.removeEventListener = function (type, listener) {
    if (this._listeners[type]) {
      // @ts-ignore
      this._listeners[type] = this._listeners[type].filter(function (l) {
        return l !== listener;
      });
    }
  };

  ReconnectingWebSocket.prototype._debug = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (this._options.debug) {
      // not using spread because compiled version uses Symbols
      // tslint:disable-next-line
      console.log.apply(console, __spread(['RWS>'], args));
    }
  };

  ReconnectingWebSocket.prototype._getNextDelay = function () {
    var _a = this._options,
        _b = _a.reconnectionDelayGrowFactor,
        reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b,
        _c = _a.minReconnectionDelay,
        minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c,
        _d = _a.maxReconnectionDelay,
        maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;
    var delay = 0;

    if (this._retryCount > 0) {
      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);

      if (delay > maxReconnectionDelay) {
        delay = maxReconnectionDelay;
      }
    }

    this._debug('next delay', delay);

    return delay;
  };

  ReconnectingWebSocket.prototype._wait = function () {
    var _this = this;

    return new Promise(function (resolve) {
      setTimeout(resolve, _this._getNextDelay());
    });
  };

  ReconnectingWebSocket.prototype._getNextUrl = function (urlProvider) {
    if (typeof urlProvider === 'string') {
      return Promise.resolve(urlProvider);
    }

    if (typeof urlProvider === 'function') {
      var url = urlProvider();

      if (typeof url === 'string') {
        return Promise.resolve(url);
      }

      if (!!url.then) {
        return url;
      }
    }

    throw Error('Invalid URL');
  };

  ReconnectingWebSocket.prototype._connect = function () {
    var _this = this;

    if (this._connectLock || !this._shouldReconnect) {
      return;
    }

    this._connectLock = true;
    var _a = this._options,
        _b = _a.maxRetries,
        maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b,
        _c = _a.connectionTimeout,
        connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c,
        _d = _a.WebSocket,
        WebSocket = _d === void 0 ? getGlobalWebSocket() : _d;

    if (this._retryCount >= maxRetries) {
      this._debug('max retries reached', this._retryCount, '>=', maxRetries);

      return;
    }

    this._retryCount++;

    this._debug('connect', this._retryCount);

    this._removeListeners();

    if (!isWebSocket(WebSocket)) {
      throw Error('No valid WebSocket class provided');
    }

    this._wait().then(function () {
      return _this._getNextUrl(_this._url);
    }).then(function (url) {
      // close could be called before creating the ws
      if (_this._closeCalled) {
        return;
      }

      _this._debug('connect', {
        url: url,
        protocols: _this._protocols
      });

      _this._ws = _this._protocols ? new WebSocket(url, _this._protocols) : new WebSocket(url);
      _this._ws.binaryType = _this._binaryType;
      _this._connectLock = false;

      _this._addListeners();

      _this._connectTimeout = setTimeout(function () {
        return _this._handleTimeout();
      }, connectionTimeout);
    });
  };

  ReconnectingWebSocket.prototype._handleTimeout = function () {
    this._debug('timeout event');

    this._handleError(new ErrorEvent(Error('TIMEOUT'), this));
  };

  ReconnectingWebSocket.prototype._disconnect = function (code, reason) {
    if (code === void 0) {
      code = 1000;
    }

    this._clearTimeouts();

    if (!this._ws) {
      return;
    }

    this._removeListeners();

    try {
      this._ws.close(code, reason);

      this._handleClose(new CloseEvent(code, reason, this));
    } catch (error) {// ignore
    }
  };

  ReconnectingWebSocket.prototype._acceptOpen = function () {
    this._debug('accept open');

    this._retryCount = 0;
  };

  ReconnectingWebSocket.prototype._callEventListener = function (event, listener) {
    if ('handleEvent' in listener) {
      // @ts-ignore
      listener.handleEvent(event);
    } else {
      // @ts-ignore
      listener(event);
    }
  };

  ReconnectingWebSocket.prototype._removeListeners = function () {
    if (!this._ws) {
      return;
    }

    this._debug('removeListeners');

    this._ws.removeEventListener('open', this._handleOpen);

    this._ws.removeEventListener('close', this._handleClose);

    this._ws.removeEventListener('message', this._handleMessage); // @ts-ignore


    this._ws.removeEventListener('error', this._handleError);
  };

  ReconnectingWebSocket.prototype._addListeners = function () {
    if (!this._ws) {
      return;
    }

    this._debug('addListeners');

    this._ws.addEventListener('open', this._handleOpen);

    this._ws.addEventListener('close', this._handleClose);

    this._ws.addEventListener('message', this._handleMessage); // @ts-ignore


    this._ws.addEventListener('error', this._handleError);
  };

  ReconnectingWebSocket.prototype._clearTimeouts = function () {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  };

  return ReconnectingWebSocket;
}();

module.exports = ReconnectingWebSocket;

},{}],442:[function(require,module,exports){
const TOS = require('time-ordered-set');

class Entry {
  constructor(pool, key, val) {
    this.pool = pool;
    this.prev = null;
    this.next = null;
    this.key = key;
    this.value = val;
    this.refs = 0;
  }

  bump() {
    if (this.refs > 0) return;
    this.pool.gcable.add(this);

    this.pool._gcMaybe();
  }

  delete() {
    this.pool.gcable.remove(this);
    this.pool.entries.delete(this.key);
    if (this.pool.close) this.pool.close(this.value);
  }

  increment() {
    this.refs++;

    if (this.refs === 1) {
      this.pool.gcable.remove(this);
    }

    this.pool._gcMaybe();
  }

  decrement() {
    this.refs--;

    if (this.refs === 0) {
      this.pool.gcable.add(this);

      this.pool._gcMaybe();
    }

    this.pool._gcMaybe();
  }

}

module.exports = class Pool {
  constructor({
    maxSize = Infinity,
    close
  } = {}) {
    this.maxSize = maxSize;
    this.close = close;
    this.gcable = new TOS();
    this.entries = new Map();
  }

  get size() {
    return this.entries.size;
  }

  isFull() {
    return this.entries.size < this.maxSize;
  }

  entry(key) {
    return this.entries.get(key);
  }

  get(key, bump = true) {
    const entry = this.entry(key);
    if (!entry) return;
    if (bump) entry.bump();
    return entry.value;
  }

  delete(key) {
    const e = this.entry(key);
    if (e) e.delete();
  }

  add(val, forceGC = false) {
    return this.set(val, val, forceGC);
  }

  has(key) {
    return this.entries.has(key);
  }

  set(key, val, forceGC = false) {
    const existing = this.entries.get(key);

    if (existing) {
      existing.bump();
      existing.value = val;
      return existing;
    }

    const entry = new Entry(this, key, val);
    this.gcable.add(entry);
    this.entries.set(key, entry); // allow gc list to grow by one if otherwise we could destroy ourself unless forceGC is set

    this._gcMaybe(!forceGC);

    return entry;
  }

  gc() {
    const oldest = this.gcable.oldest;
    if (!oldest) return null;
    oldest.delete();
    return oldest.value;
  }

  _gcMaybe(allowOne = false) {
    if (this.gcable.length === 1 && allowOne) return;
    if (this.entries.size <= this.maxSize && this.close) return;
    this.gc();
  }

  increment(key) {
    const e = this.entry(key);
    if (e) e.increment();
  }

  decrement(key) {
    const e = this.entry(key);
    if (e) e.decrement();
  }

  bump(key) {
    const e = this.entry(key);
    if (e) e.bump();
  }

};

},{"time-ordered-set":569}],443:[function(require,module,exports){
(function (process){(function (){
var isWin = process.platform === 'win32';

module.exports = function (str) {
  var i = str.length - 1;

  if (i < 2) {
    return str;
  }

  while (isSeparator(str, i)) {
    i--;
  }

  return str.substr(0, i + 1);
};

function isSeparator(str, i) {
  var char = str[i];
  return i > 0 && (char === '/' || isWin && char === '\\');
}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],444:[function(require,module,exports){
'use strict';

function reusify(Constructor) {
  var head = new Constructor();
  var tail = head;

  function get() {
    var current = head;

    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }

    current.next = null;
    return current;
  }

  function release(obj) {
    tail.next = obj;
    tail = obj;
  }

  return {
    get: get,
    release: release
  };
}

module.exports = reusify;

},{}],445:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;

var inherits = require('inherits');

var HashBase = require('hash-base');

var ARRAY16 = new Array(16);
var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

function RIPEMD160() {
  HashBase.call(this, 64); // state

  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
}

inherits(RIPEMD160, HashBase);

RIPEMD160.prototype._update = function () {
  var words = ARRAY16;

  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0; // computation

  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;

    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
    } else {
      // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
    }

    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  } // update state


  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  buffer.writeInt32LE(this._e, 16);
  return buffer;
};

function rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function fn1(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}

function fn2(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}

function fn3(a, b, c, d, e, m, k, s) {
  return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}

function fn4(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}

function fn5(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}

module.exports = RIPEMD160;

},{"buffer":97,"hash-base":189,"inherits":279}],446:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

},{"buffer":97}],447:[function(require,module,exports){
(function (process){(function (){
/* eslint-disable node/no-deprecated-api */
'use strict';

var buffer = require('buffer');

var Buffer = buffer.Buffer;
var safer = {};
var key;

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === 'SlowBuffer' || key === 'Buffer') continue;
  safer[key] = buffer[key];
}

var Safer = safer.Buffer = {};

for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue;
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
  Safer[key] = Buffer[key];
}

safer.Buffer.prototype = Buffer.prototype;

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }

    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
    }

    return Buffer(value, encodingOrOffset, length);
  };
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }

    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }

    var buf = Buffer(size);

    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }

    return buf;
  };
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
  } catch (e) {// we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };

  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}

module.exports = safer;

}).call(this)}).call(this,require('_process'))
},{"_process":380,"buffer":97}],448:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer; // prototype class for hash functions


function Hash(blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer.from(data, enc);
  }

  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if (accum % blockSize === 0) {
      this._update(block);
    }
  }

  this._len += length;
  return this;
};

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

  this._block.fill(0, rem + 1);

  if (rem >= this._finalSize) {
    this._update(this._block);

    this._block.fill(0);
  }

  var bits = this._len * 8; // uint32

  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;

    this._block.writeUInt32BE(highBits, this._blockSize - 8);

    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }

  this._update(this._block);

  var hash = this._hash();

  return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

},{"safe-buffer":446}],449:[function(require,module,exports){
var exports = module.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
  return new Algorithm();
};

exports.sha = require("./sha");
exports.sha1 = require("./sha1");
exports.sha224 = require("./sha224");
exports.sha256 = require("./sha256");
exports.sha384 = require("./sha384");
exports.sha512 = require("./sha512");

},{"./sha":450,"./sha1":451,"./sha224":452,"./sha256":453,"./sha384":454,"./sha512":455}],450:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */
var inherits = require('inherits');

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);

function Sha() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}

inherits(Sha, Hash);

Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

module.exports = Sha;

},{"./hash":448,"inherits":279,"safe-buffer":446}],451:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
var inherits = require('inherits');

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);

function Sha1() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function rotl1(num) {
  return num << 1 | num >>> 31;
}

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

module.exports = Sha1;

},{"./hash":448,"inherits":279,"safe-buffer":446}],452:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits = require('inherits');

var Sha256 = require("./sha256");

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var W = new Array(64);

function Sha224() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha224, Sha256);

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;
  return this;
};

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};

module.exports = Sha224;

},{"./hash":448,"./sha256":453,"inherits":279,"safe-buffer":446}],453:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits = require('inherits');

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
var W = new Array(64);

function Sha256() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha256, Hash);

Sha256.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;
  return this;
};

function ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}

function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}

Sha256.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

  for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;

  for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
    var T2 = sigma0(a) + maj(a, b, c) | 0;
    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};

module.exports = Sha256;

},{"./hash":448,"inherits":279,"safe-buffer":446}],454:[function(require,module,exports){
var inherits = require('inherits');

var SHA512 = require("./sha512");

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var W = new Array(160);

function Sha384() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}

inherits(Sha384, SHA512);

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;
  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;
  return this;
};

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};

module.exports = Sha384;

},{"./hash":448,"./sha512":455,"inherits":279,"safe-buffer":446}],455:[function(require,module,exports){
var inherits = require('inherits');

var Hash = require("./hash");

var Buffer = require('safe-buffer').Buffer;

var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
var W = new Array(160);

function Sha512() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}

inherits(Sha512, Hash);

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;
  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;
  return this;
};

function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}

function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}

function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}

function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}

function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}

function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}

function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}

Sha512.prototype._update = function (M) {
  var W = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }

  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];
    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W[i] = Wih;
    W[i + 1] = Wil;
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];
    var majh = maj(ah, bh, ch);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

    var Kih = K[j];
    var Kil = K[j + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }

  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};

module.exports = Sha512;

},{"./hash":448,"inherits":279,"safe-buffer":446}],456:[function(require,module,exports){
const js = require("./sha256.js");

const wasm = require('sha256-wasm');

var Proto = js;

module.exports = function () {
  return new Proto();
};

module.exports.ready = function (cb) {
  wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = wasm.WASM_SUPPORTED;
module.exports.WASM_LOADED = false;
var SHA256_BYTES = module.exports.SHA256_BYTES = 32;
wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    module.exports = Proto = wasm;
  }
});

},{"./sha256.js":457,"sha256-wasm":458}],457:[function(require,module,exports){
(function (Buffer){(function (){
if (btoa == null) var btoa = buf => require('buf' + 'fer')['Buf' + 'fer'].from(buf).toString('base64');
if (atob == null) var atob = buf => new Uint8Array(require('buf' + 'fer')['Buf' + 'fer'].from(buf, 'base64'));

const assert = require('nanoassert');

module.exports = Sha256;
const SHA256_BYTES = module.exports.SHA256_BYTES = 32;
const BLOCKSIZE = 64;
const K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

function expand(a, b, c, d) {
  var b_ = ((a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10) + b;
  var d_ = ((c >>> 7 | c << 25) ^ (c >>> 18 | c << 14) ^ c >>> 3) + d;
  return b_ + d_ << 0;
}

function compress(state, words) {
  // initialise registers
  var ch, maj, s0, s1, T1, T2;
  var [a, b, c, d, e, f, g, h] = state; // expand message schedule

  const w = new Uint32Array(64);

  for (let i = 0; i < 16; i++) w[i] = bswap(words[i]);

  for (let i = 16; i < 64; i++) w[i] = expand(w[i - 2], w[i - 7], w[i - 15], w[i - 16]);

  for (let i = 0; i < 64; i += 4) round(i);

  state[0] = state[0] + a;
  state[1] = state[1] + b;
  state[2] = state[2] + c;
  state[3] = state[3] + d;
  state[4] = state[4] + e;
  state[5] = state[5] + f;
  state[6] = state[6] + g;
  state[7] = state[7] + h;

  function round(n) {
    ch = e & f ^ ~e & g;
    maj = a & b ^ a & c ^ b & c;
    s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
    s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
    T1 = h + ch + s1 + w[n] + K[n];
    T2 = s0 + maj;
    h = d + T1;
    d = T1 + T2;
    ch = h & e ^ ~h & f;
    maj = d & a ^ d & b ^ a & b;
    s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
    s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
    T1 = g + ch + s1 + w[n + 1] + K[n + 1];
    T2 = s0 + maj;
    g = c + T1;
    c = T1 + T2;
    ch = g & h ^ ~g & e;
    maj = c & d ^ c & a ^ d & a;
    s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
    s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
    T1 = f + ch + s1 + w[n + 2] + K[n + 2];
    T2 = s0 + maj;
    f = b + T1;
    b = T1 + T2;
    ch = f & g ^ ~f & h;
    maj = b & c ^ b & d ^ c & d;
    s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
    s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
    T1 = e + ch + s1 + w[n + 3] + K[n + 3];
    T2 = s0 + maj;
    e = a + T1;
    a = T1 + T2;
  }
}

function Sha256() {
  if (!(this instanceof Sha256)) return new Sha256();
  this.buffer = new ArrayBuffer(64);
  this.bytesRead = 0;
  this.pos = 0;
  this.digestLength = SHA256_BYTES;
  this.finalised = false;
  this.load = new Uint8Array(this.buffer);
  this.words = new Uint32Array(this.buffer);
  this.state = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
  return this;
}

Sha256.prototype.update = function (input, enc) {
  assert(this.finalised === false, 'Hash instance finalised');
  var [inputBuf, len] = formatInput(input, enc);
  var i = 0;
  this.bytesRead += len;

  while (len > 0) {
    this.load.set(inputBuf.subarray(i, i + BLOCKSIZE - this.pos), this.pos);
    i += BLOCKSIZE - this.pos;
    len -= BLOCKSIZE - this.pos;
    if (len < 0) break;
    this.pos = 0;
    compress(this.state, this.words);
  }

  this.pos = this.bytesRead & 0x3f;
  this.load.fill(0, this.pos);
  return this;
};

Sha256.prototype.digest = function (enc, offset = 0) {
  assert(this.finalised === false, 'Hash instance finalised');
  this.finalised = true;
  this.load.fill(0, this.pos);
  this.load[this.pos] = 0x80;

  if (this.pos > 55) {
    compress(this.state, this.words);
    this.words.fill(0);
    this.pos = 0;
  }

  const view = new DataView(this.buffer);
  view.setUint32(56, this.bytesRead / 2 ** 29);
  view.setUint32(60, this.bytesRead << 3);
  compress(this.state, this.words);
  const resultBuf = new Uint8Array(this.state.map(bswap).buffer);

  if (!enc) {
    return new Uint8Array(resultBuf);
  }

  if (typeof enc === 'string') {
    if (enc === 'hex') return hexSlice(resultBuf, 0, resultBuf.length);
    if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(resultBuf);
    if (enc === 'base64') return btoa(resultBuf);
    throw new Error('Encoding: ' + enc + ' not supported');
  }

  assert(enc instanceof Uint8Array, 'input must be Uint8Array or Buffer');
  assert(enc.byteLength >= this.digestLength + offset, 'input not large enough for digest');

  for (let i = 0; i < this.digestLength; i++) {
    enc[i + offset] = resultBuf[i];
  }

  return enc;
};

function HMAC(key) {
  if (!(this instanceof HMAC)) return new HMAC(key);
  this.pad = Buffer.alloc(64);
  this.inner = Sha256();
  this.outer = Sha256();
  const keyhash = Buffer.alloc(32);

  if (key.byteLength > 64) {
    Sha256().update(key).digest(keyhash);
    key = keyhash;
  }

  this.pad.fill(0x36);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.inner.update(this.pad);
  this.pad.fill(0x5c);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.outer.update(this.pad);
  this.pad.fill(0);
  keyhash.fill(0);
}

HMAC.prototype.update = function (input, enc) {
  this.inner.update(input, enc);
  return this;
};

HMAC.prototype.digest = function (enc, offset = 0) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc, offset);
};

Sha256.HMAC = HMAC;

function hexSlice(buf, start = 0, len) {
  if (!len) len = buf.byteLength;
  var str = '';

  for (var i = 0; i < len; i++) str += toHex(buf[start + i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function formatInput(input, enc) {
  var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
  return [result, result.byteLength];
}

function strToBuf(input, enc) {
  if (enc === 'hex') return hex2bin(input);else if (enc === 'utf8' || enc === 'utf-8') return new TextDecoder().decode(input);else if (enc === 'base64') return atob(input);else throw new Error('Encoding: ' + enc + ' not supported');
}

function hex2bin(str) {
  if (str.length % 2 !== 0) return hex2bin('0' + str);
  var ret = new Uint8Array(str.length / 2);

  for (var i = 0; i < ret.length; i++) ret[i] = Number('0x' + str.substring(2 * i, 2 * i + 2));

  return ret;
}

function bswap(a) {
  var r = (a & 0x00ff00ff) >>> 8 | (a & 0x00ff00ff) << 24;
  var l = (a & 0xff00ff00) << 8 | (a & 0xff00ff00) >>> 24;
  return r | l;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"nanoassert":319}],458:[function(require,module,exports){
(function (Buffer){(function (){
if (btoa == null) var btoa = buf => require('buf' + 'fer')['Buf' + 'fer'].from(buf).toString('base64');
if (atob == null) var atob = buf => new Uint8Array(require('buf' + 'fer')['Buf' + 'fer'].from(buf, 'base64'));

const assert = require('nanoassert');

const wasm = require("./sha256.js")({
  imports: {
    debug: {
      log(...args) {
        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')));
      },

      log_tee(arg) {
        console.log((arg >>> 0).toString(16).padStart(8, '0'));
        return arg;
      }

    }
  }
});

let head = 0;
const freeList = [];
module.exports = Sha256;
const SHA256_BYTES = module.exports.SHA256_BYTES = 32;
const INPUT_OFFSET = 40;
const STATEBYTES = 108;
const BLOCKSIZE = 64;

function Sha256() {
  if (!(this instanceof Sha256)) return new Sha256();
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Sha256.ready(cb)');

  if (!freeList.length) {
    freeList.push(head);
    head += STATEBYTES; // need 100 bytes for internal state
  }

  this.finalized = false;
  this.digestLength = SHA256_BYTES;
  this.pointer = freeList.pop();
  this.pos = 0;
  wasm.memory.fill(0, this.pointer, this.pointer + STATEBYTES);
  if (this.pointer + this.digestLength > wasm.memory.length) wasm.realloc(this.pointer + STATEBYTES);
}

Sha256.prototype.update = function (input, enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  if (head % 4 !== 0) head += 4 - head % 4;
  assert(head % 4 === 0, 'input shoud be aligned for int32');
  const [inputBuf, length] = formatInput(input, enc);
  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer');
  if (head + length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE);
  wasm.memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos);
  wasm.memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head);
  this.pos = this.pos + length & 0x3f;
  wasm.exports.sha256(this.pointer, head, length, 0);
  return this;
};

Sha256.prototype.digest = function (enc, offset = 0) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  const paddingStart = this.pointer + INPUT_OFFSET + this.pos;
  wasm.memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE);
  wasm.exports.sha256(this.pointer, head, 0, 1);
  const resultBuf = wasm.memory.subarray(this.pointer, this.pointer + this.digestLength);

  if (!enc) {
    return resultBuf;
  }

  if (typeof enc === 'string') {
    if (enc === 'hex') return hexSlice(resultBuf, 0, resultBuf.length);
    if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(resultBuf);
    if (enc === 'base64') return btoa(resultBuf);
    throw new Error('Encoding: ' + enc + ' not supported');
  }

  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer');
  assert(enc.byteLength >= this.digestLength + offset, "output must have at least 'SHA256_BYTES' bytes remaining");

  for (let i = 0; i < this.digestLength; i++) {
    enc[i + offset] = resultBuf[i];
  }

  return enc;
};

Sha256.WASM = wasm && wasm.buffer;
Sha256.WASM_SUPPORTED = typeof WebAssembly !== 'undefined';

Sha256.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported'));
  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve(err);else reject();
      cb(err);
    });
  });
  return p;
};

Sha256.prototype.ready = Sha256.ready;

function HMAC(key) {
  if (!(this instanceof HMAC)) return new HMAC(key);
  this.pad = Buffer.alloc(64);
  this.inner = Sha256();
  this.outer = Sha256();
  const keyhash = Buffer.alloc(32);

  if (key.byteLength > 64) {
    Sha256().update(key).digest(keyhash);
    key = keyhash;
  }

  this.pad.fill(0x36);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.inner.update(this.pad);
  this.pad.fill(0x5c);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.outer.update(this.pad);
  this.pad.fill(0);
  keyhash.fill(0);
}

HMAC.prototype.update = function (input, enc) {
  this.inner.update(input, enc);
  return this;
};

HMAC.prototype.digest = function (enc, offset = 0) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc, offset);
};

Sha256.HMAC = HMAC;

function noop() {}

function formatInput(input, enc) {
  var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
  return [result, result.byteLength];
}

function strToBuf(input, enc = 'utf8') {
  if (enc === 'hex') return hex2bin(input);else if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(input);else if (enc === 'base64') return atob(input);else throw new Error('Encoding: ' + enc + ' not supported');
}

function hex2bin(str) {
  if (str.length % 2 !== 0) return hex2bin('0' + str);
  var ret = new Uint8Array(str.length / 2);

  for (var i = 0; i < ret.length; i++) ret[i] = Number('0x' + str.substring(2 * i, 2 * i + 2));

  return ret;
}

function readReverseEndian(buf, interval, start, len) {
  const result = new Uint8Array(len);

  for (let i = 0; i < len; i++) {
    const index = Math.floor(i / interval) * interval + (interval - 1) - i % interval;
    result[index] = buf[i + start];
  }

  return result;
}

function hexSlice(buf, start = 0, len) {
  if (!len) len = buf.byteLength;
  var str = '';

  for (var i = 0; i < len; i++) str += toHex(buf[start + i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
} // only works for base that is power of 2


function roundUp(n, base) {
  return n + base - 1 & -base;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./sha256.js":460,"buffer":97,"nanoassert":459}],459:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],460:[function(require,module,exports){
module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABNAVgAX8Bf2AIf39/f39/f38AYAR/f39/AX9gEX9/f39/f39/f39/f39/f39/AGAEf39/fwADBgUAAQIDBAUDAQABBikIfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwcTAgZtZW1vcnkCAAZzaGEyNTYABArgFwUZACAAQf+B/AdxQQh4IABBgP6DeHFBCHdyC7wDAQZ/IwQjBXEjBEF/cyMGcXMhCiMAIwFxIwAjAnFzIwEjAnFzIQsjAEECeCMAQQ14cyMAQRZ4cyEMIwRBBngjBEELeHMjBEEZeHMhDSMHIApqIA1qIABqIARqIQggDCALaiEJIwMgCGokByAIIAlqJAMjByMEcSMHQX9zIwVxcyEKIwMjAHEjAyMBcXMjACMBcXMhCyMDQQJ4IwNBDXhzIwNBFnhzIQwjB0EGeCMHQQt4cyMHQRl4cyENIwYgCmogDWogAWogBWohCCAMIAtqIQkjAiAIaiQGIAggCWokAiMGIwdxIwZBf3MjBHFzIQojAiMDcSMCIwBxcyMDIwBxcyELIwJBAngjAkENeHMjAkEWeHMhDCMGQQZ4IwZBC3hzIwZBGXhzIQ0jBSAKaiANaiACaiAGaiEIIAwgC2ohCSMBIAhqJAUgCCAJaiQBIwUjBnEjBUF/cyMHcXMhCiMBIwJxIwEjA3FzIwIjA3FzIQsjAUECeCMBQQ14cyMBQRZ4cyEMIwVBBngjBUELeHMjBUEZeHMhDSMEIApqIA1qIANqIAdqIQggDCALaiEJIwAgCGokBCAIIAlqJAALKwAgAEEReCAAQRN4cyAAQQp2cyABaiACQQd4IAJBEnhzIAJBA3ZzIANqagvNCwEwfyAAKAJoQQBGBEAgAEHnzKfQBjYCACAAQYXdntt7NgIEIABB8ua74wM2AgggAEG66r+qejYCDCAAQf+kuYgFNgIQIABBjNGV2Hk2AhQgAEGrs4/8ATYCGCAAQZmag98FNgIcIABBATYCaAsgACgCACQAIAAoAgQkASAAKAIIJAIgACgCDCQDIAAoAhAkBCAAKAIUJAUgACgCGCQGIAAoAhwkByABEAAhASACEAAhAiADEAAhAyAEEAAhBCAFEAAhBSAGEAAhBiAHEAAhByAIEAAhCCAJEAAhCSAKEAAhCiALEAAhCyAMEAAhDCANEAAhDSAOEAAhDiAPEAAhDyAQEAAhECAPIAogAiABEAIhESAQIAsgAyACEAIhEiARIAwgBCADEAIhEyASIA0gBSAEEAIhFCATIA4gBiAFEAIhFSAUIA8gByAGEAIhFiAVIBAgCCAHEAIhFyAWIBEgCSAIEAIhGCAXIBIgCiAJEAIhGSAYIBMgCyAKEAIhGiAZIBQgDCALEAIhGyAaIBUgDSAMEAIhHCAbIBYgDiANEAIhHSAcIBcgDyAOEAIhHiAdIBggECAPEAIhHyAeIBkgESAQEAIhICAfIBogEiAREAIhISAgIBsgEyASEAIhIiAhIBwgFCATEAIhIyAiIB0gFSAUEAIhJCAjIB4gFiAVEAIhJSAkIB8gFyAWEAIhJiAlICAgGCAXEAIhJyAmICEgGSAYEAIhKCAnICIgGiAZEAIhKSAoICMgGyAaEAIhKiApICQgHCAbEAIhKyAqICUgHSAcEAIhLCArICYgHiAdEAIhLSAsICcgHyAeEAIhLiAtICggICAfEAIhLyAuICkgISAgEAIhMCAvICogIiAhEAIhMSAwICsgIyAiEAIhMiAxICwgJCAjEAIhMyAyIC0gJSAkEAIhNCAzIC4gJiAlEAIhNSA0IC8gJyAmEAIhNiA1IDAgKCAnEAIhNyA2IDEgKSAoEAIhOCA3IDIgKiApEAIhOSA4IDMgKyAqEAIhOiA5IDQgLCArEAIhOyA6IDUgLSAsEAIhPCA7IDYgLiAtEAIhPSA8IDcgLyAuEAIhPiA9IDggMCAvEAIhPyA+IDkgMSAwEAIhQCABIAIgAyAEQZjfqJQEQZGJ3YkHQc/3g657QaW3181+EAEgBSAGIAcgCEHbhNvKA0Hxo8TPBUGkhf6ReUHVvfHYehABIAkgCiALIAxBmNWewH1BgbaNlAFBvovGoQJBw/uxqAUQASANIA4gDyAQQfS6+ZUHQf7j+oZ4QaeN8N55QfTi74x8EAEgESASIBMgFEHB0+2kfkGGj/n9fkHGu4b+AEHMw7KgAhABIBUgFiAXIBhB79ik7wJBqonS0wRB3NPC5QVB2pHmtwcQASAZIBogGyAcQdKi+cF5Qe2Mx8F6QcjPjIB7Qcf/5fp7EAEgHSAeIB8gIEHzl4C3fEHHop6tfUHRxqk2QefSpKEBEAEgISAiICMgJEGFldy9AkG4wuzwAkH827HpBEGTmuCZBRABICUgJiAnIChB1OapqAZBu5WoswdBrpKLjnhBhdnIk3kQASApICogKyAsQaHR/5V6QcvM6cB6QfCWrpJ8QaOjsbt8EAEgLSAuIC8gMEGZ0MuMfUGkjOS0fUGF67igf0HwwKqDARABIDEgMiAzIDRBloKTzQFBiNjd8QFBzO6hugJBtfnCpQMQASA1IDYgNyA4QbOZ8MgDQcrU4vYEQc+U89wFQfPfucEGEAEgOSA6IDsgPEHuhb6kB0HvxpXFB0GU8KGmeEGIhJzmeBABID0gPiA/IEBB+v/7hXlB69nBonpB98fm93tB8vHFs3wQASAAIAAoAgAjAGo2AgAgACAAKAIEIwFqNgIEIAAgACgCCCMCajYCCCAAIAAoAgwjA2o2AgwgACAAKAIQIwRqNgIQIAAgACgCFCMFajYCFCAAIAAoAhgjBmo2AhggACAAKAIcIwdqNgIcC4oIAgF+En8gACkDICEEIASnQT9xIAJqIQYgBCACrXwhBCAAIAQ3AyACQCAAKAIoIQcgACgCLCEIIAAoAjAhCSAAKAI0IQogACgCOCELIAAoAjwhDCAAKAJAIQ0gACgCRCEOIAAoAkghDyAAKAJMIRAgACgCUCERIAAoAlQhEiAAKAJYIRMgACgCXCEUIAAoAmAhFSAAKAJkIRYgBkHAAGsiBkEASA0AIAAgByAIIAkgCiALIAwgDSAOIA8gECARIBIgEyAUIBUgFhADA0AgASgCACEHIAEoAgQhCCABKAIIIQkgASgCDCEKIAEoAhAhCyABKAIUIQwgASgCGCENIAEoAhwhDiABKAIgIQ8gASgCJCEQIAEoAighESABKAIsIRIgASgCMCETIAEoAjQhFCABKAI4IRUgASgCPCEWIAFBwABqIQEgBkHAAGsiBkEASARAIAAgBzYCKCAAIAg2AiwgACAJNgIwIAAgCjYCNCAAIAs2AjggACAMNgI8IAAgDTYCQCAAIA42AkQgACAPNgJIIAAgEDYCTCAAIBE2AlAgACASNgJUIAAgEzYCWCAAIBQ2AlwgACAVNgJgIAAgFjYCZAwCCyAAIAcgCCAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYQAwwACwsgA0EBRgRAIASnQT9xIQZBgAEgBkEDcUEDdHQhBQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGQQJ2Dg8DBAUGBwgJCgsMDQ4PEAECCwsgBSAVciEVQQAhBQsgBSAWciEWQQAhBSAAIAcgCCAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYQAyAAIAQ3AyBBACEHQQAhCEEAIQlBACEKQQAhC0EAIQxBACENQQAhDkEAIQ9BACEQQQAhEUEAIRJBACETQQAhFEEAIRVBACEWCyAFIAdyIQdBACEFCyAFIAhyIQhBACEFCyAFIAlyIQlBACEFCyAFIApyIQpBACEFCyAFIAtyIQtBACEFCyAFIAxyIQxBACEFCyAFIA1yIQ1BACEFCyAFIA5yIQ5BACEFCyAFIA9yIQ9BACEFCyAFIBByIRBBACEFCyAFIBFyIRFBACEFCyAFIBJyIRJBACEFCyAFIBNyIRNBACEFCyAFIBRyIRRBACEFCyAEQh2IpxAAIRUgBEIDhqcQACEWIAAgByAIIAkgCiALIAwgDSAOIA8gECARIBIgEyAUIBUgFhADIAAgACgCABAANgIAIAAgACgCBBAANgIEIAAgACgCCBAANgIIIAAgACgCDBAANgIMIAAgACgCEBAANgIQIAAgACgCFBAANgIUIAAgACgCGBAANgIYIAAgACgCHBAANgIcCws=');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return require('buf' + 'fer').Buffer.from(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

},{}],461:[function(require,module,exports){
const js = require("./sha512.js");

const wasm = require('sha512-wasm');

var Proto = js;

module.exports = function () {
  return new Proto();
};

module.exports.ready = function (cb) {
  wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var SHA512_BYTES = module.exports.SHA512_BYTES = 64;
wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    module.exports = Proto = wasm;
  }
});

},{"./sha512.js":462,"sha512-wasm":463}],462:[function(require,module,exports){
(function (Buffer){(function (){
if (btoa == null) var btoa = buf => require('buf' + 'fer')['Buf' + 'fer'].from(buf).toString('base64');
if (atob == null) var atob = buf => new Uint8Array(require('buf' + 'fer')['Buf' + 'fer'].from(buf, 'base64'));

const assert = require('nanoassert');

module.exports = Sha512;
const BLOCKSIZE = 128;
var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

function Sha512() {
  if (!(this instanceof Sha512)) return new Sha512();
  this.hh = new Int32Array(8);
  this.hl = new Int32Array(8);
  this.buffer = new Uint8Array(128);
  this.finalised = false;
  this.bytesRead = 0;
  this.pos = 0;
  this.hh[0] = 0x6a09e667;
  this.hh[1] = 0xbb67ae85;
  this.hh[2] = 0x3c6ef372;
  this.hh[3] = 0xa54ff53a;
  this.hh[4] = 0x510e527f;
  this.hh[5] = 0x9b05688c;
  this.hh[6] = 0x1f83d9ab;
  this.hh[7] = 0x5be0cd19;
  this.hl[0] = 0xf3bcc908;
  this.hl[1] = 0x84caa73b;
  this.hl[2] = 0xfe94f82b;
  this.hl[3] = 0x5f1d36f1;
  this.hl[4] = 0xade682d1;
  this.hl[5] = 0x2b3e6c1f;
  this.hl[6] = 0xfb41bd6b;
  this.hl[7] = 0x137e2179;
  return this;
}

Sha512.prototype.update = function (input, enc) {
  assert(this.finalised === false, 'Hash instance finalised');
  var [inputBuf, len] = formatInput(input, enc);
  this.bytesRead += len;
  const full = len + this.pos & -128;
  this.buffer.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pos);
  const pos = this.pos;
  len -= BLOCKSIZE - this.pos;

  if (len >= 0) {
    compress(this.hh, this.hl, this.buffer, 128);
    this.pos = 0;
  }

  if (len > 127) {
    compress(this.hh, this.hl, inputBuf.subarray(BLOCKSIZE - pos, full - pos), full - BLOCKSIZE);
    len %= 128;
  }

  this.buffer.set(inputBuf.subarray(inputBuf.byteLength - len));
  this.pos = this.bytesRead & 0x7f;
  this.buffer.fill(0, this.pos);
  return this;
};

Sha512.prototype.digest = function (enc, offset = 0) {
  assert(this.finalised === false, 'Hash instance finalised');
  this.finalised = true;
  this.buffer.fill(0, this.pos);
  this.buffer[this.pos] = 128;

  if (this.pos > 111) {
    compress(this.hh, this.hl, this.buffer, 128);
    this.buffer.fill(0);
    this.pos = 0;
  }

  ts64(this.buffer, 120, this.bytesRead / 0x20000000 | 0, this.bytesRead << 3);
  compress(this.hh, this.hl, this.buffer, 128);

  if (enc instanceof Uint8Array && enc.byteLength > 63) {
    for (let i = 0; i < 8; i++) ts64(enc, 8 * i + offset, this.hh[i], this.hl[i]);

    return enc;
  }

  const resultBuf = new Uint8Array(64);

  for (let i = 0; i < 8; i++) ts64(resultBuf, 8 * i, this.hh[i], this.hl[i]);

  if (typeof enc === 'string') {
    if (enc === 'hex') return hexSlice(resultBuf, 0, resultBuf.length);
    if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(resultBuf);
    if (enc === 'base64') return btoa(resultBuf);
    throw new Error('Encoding: ' + enc + ' not supported');
  }

  return resultBuf;
};

function ts64(x, i, h, l) {
  x[i] = h >> 24 & 0xff;
  x[i + 1] = h >> 16 & 0xff;
  x[i + 2] = h >> 8 & 0xff;
  x[i + 3] = h & 0xff;
  x[i + 4] = l >> 24 & 0xff;
  x[i + 5] = l >> 16 & 0xff;
  x[i + 6] = l >> 8 & 0xff;
  x[i + 7] = l & 0xff;
}

function hexSlice(buf, start = 0, len) {
  if (!len) len = buf.byteLength;
  var str = '';

  for (var i = 0; i < len; i++) str += toHex(buf[start + i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function formatInput(input, enc) {
  var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
  return [result, result.byteLength];
}

function strToBuf(input, enc) {
  if (enc === 'hex') return hex2bin(input);else if (enc === 'utf8' || enc === 'utf-8') return new TextDecoder().decode(input);else if (enc === 'base64') return atob(input);else throw new Error('Encoding: ' + enc + ' not supported');
}

function hex2bin(str) {
  if (str.length % 2 !== 0) return hex2bin('0' + str);
  var ret = new Uint8Array(str.length / 2);

  for (var i = 0; i < ret.length; i++) ret[i] = Number('0x' + str.substring(2 * i, 2 * i + 2));

  return ret;
}

function compress(hh, hl, m, n) {
  var wh = new Int32Array(16),
      wl = new Int32Array(16),
      bh0,
      bh1,
      bh2,
      bh3,
      bh4,
      bh5,
      bh6,
      bh7,
      bl0,
      bl1,
      bl2,
      bl3,
      bl4,
      bl5,
      bl6,
      bl7,
      th,
      tl,
      i,
      j,
      h,
      l,
      a,
      b,
      c,
      d;
  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],
      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];
  var pos = 0;

  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
      wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
    }

    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;
      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7; // add

      h = ah7;
      l = al7;
      a = l & 0xffff;
      b = l >>> 16;
      c = h & 0xffff;
      d = h >>> 16; // Sigma1

      h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
      l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16; // Ch

      h = ah4 & ah5 ^ ~ah4 & ah6;
      l = al4 & al5 ^ ~al4 & al6;
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16; // K

      h = K[i * 2];
      l = K[i * 2 + 1];
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16; // w

      h = wh[i % 16];
      l = wl[i % 16];
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16; // add

      h = th;
      l = tl;
      a = l & 0xffff;
      b = l >>> 16;
      c = h & 0xffff;
      d = h >>> 16; // Sigma0

      h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
      l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16; // Maj

      h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
      l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      bh7 = c & 0xffff | d << 16;
      bl7 = a & 0xffff | b << 16; // add

      h = bh3;
      l = bl3;
      a = l & 0xffff;
      b = l >>> 16;
      c = h & 0xffff;
      d = h >>> 16;
      h = th;
      l = tl;
      a += l & 0xffff;
      b += l >>> 16;
      c += h & 0xffff;
      d += h >>> 16;
      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;
      bh3 = c & 0xffff | d << 16;
      bl3 = a & 0xffff | b << 16;
      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;
      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i % 16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16;
          h = wh[(j + 9) % 16];
          l = wl[(j + 9) % 16];
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // sigma0

          th = wh[(j + 1) % 16];
          tl = wl[(j + 1) % 16];
          h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
          l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // sigma1

          th = wh[(j + 14) % 16];
          tl = wl[(j + 14) % 16];
          h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
          l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          wh[j] = c & 0xffff | d << 16;
          wl[j] = a & 0xffff | b << 16;
        }
      }
    } // add


    h = ah0;
    l = al0;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[0];
    l = hl[0];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[0] = ah0 = c & 0xffff | d << 16;
    hl[0] = al0 = a & 0xffff | b << 16;
    h = ah1;
    l = al1;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[1];
    l = hl[1];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[1] = ah1 = c & 0xffff | d << 16;
    hl[1] = al1 = a & 0xffff | b << 16;
    h = ah2;
    l = al2;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[2];
    l = hl[2];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[2] = ah2 = c & 0xffff | d << 16;
    hl[2] = al2 = a & 0xffff | b << 16;
    h = ah3;
    l = al3;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[3];
    l = hl[3];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[3] = ah3 = c & 0xffff | d << 16;
    hl[3] = al3 = a & 0xffff | b << 16;
    h = ah4;
    l = al4;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[4];
    l = hl[4];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[4] = ah4 = c & 0xffff | d << 16;
    hl[4] = al4 = a & 0xffff | b << 16;
    h = ah5;
    l = al5;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[5];
    l = hl[5];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[5] = ah5 = c & 0xffff | d << 16;
    hl[5] = al5 = a & 0xffff | b << 16;
    h = ah6;
    l = al6;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[6];
    l = hl[6];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[6] = ah6 = c & 0xffff | d << 16;
    hl[6] = al6 = a & 0xffff | b << 16;
    h = ah7;
    l = al7;
    a = l & 0xffff;
    b = l >>> 16;
    c = h & 0xffff;
    d = h >>> 16;
    h = hh[7];
    l = hl[7];
    a += l & 0xffff;
    b += l >>> 16;
    c += h & 0xffff;
    d += h >>> 16;
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    hh[7] = ah7 = c & 0xffff | d << 16;
    hl[7] = al7 = a & 0xffff | b << 16;
    pos += 128;
    n -= 128;
  }
}

function HMAC(key) {
  if (!(this instanceof HMAC)) return new HMAC(key);
  this.pad = Buffer.alloc(128);
  this.inner = Sha512();
  this.outer = Sha512();
  const keyhash = Buffer.alloc(64);

  if (key.byteLength > 128) {
    Sha512().update(key).digest(keyhash);
    key = keyhash;
  }

  this.pad.fill(0x36);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.inner.update(this.pad);
  this.pad.fill(0x5c);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.outer.update(this.pad);
  this.pad.fill(0);
  keyhash.fill(0);
}

HMAC.prototype.update = function (input, enc) {
  this.inner.update(input, enc);
  return this;
};

HMAC.prototype.digest = function (enc, offset = 0) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc, offset);
};

Sha512.HMAC = HMAC;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"nanoassert":319}],463:[function(require,module,exports){
(function (Buffer){(function (){
if (btoa == null) var btoa = buf => require('buf' + 'fer')['Buf' + 'fer'].from(buf).toString('base64');
if (atob == null) var atob = buf => new Uint8Array(require('buf' + 'fer')['Buf' + 'fer'].from(buf, 'base64'));

const assert = require('nanoassert');

const wasm = require("./sha512.js")({
  imports: {
    debug: {
      log(...args) {
        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')));
      },

      log_tee(arg) {
        console.log((arg >>> 0).toString(16).padStart(8, '0'));
        return arg;
      }

    }
  }
});

let head = 0; // assetrt head % 8 === 0 to guarantee alignment

const freeList = [];
module.exports = Sha512;
const SHA512_BYTES = module.exports.SHA512_BYTES = 64;
const INPUT_OFFSET = 80;
const STATEBYTES = 216;
const BLOCKSIZE = 128;

function Sha512() {
  if (!(this instanceof Sha512)) return new Sha512();
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Sha512.ready(cb)');

  if (!freeList.length) {
    freeList.push(head);
    head += STATEBYTES;
  }

  this.finalized = false;
  this.digestLength = SHA512_BYTES;
  this.pointer = freeList.pop();
  this.pos = 0;
  this.wasm = wasm;
  wasm.memory.fill(0, this.pointer, this.pointer + STATEBYTES);
  if (this.pointer + this.digestLength > wasm.memory.length) wasm.realloc(this.pointer + STATEBYTES);
}

Sha512.prototype.update = function (input, enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  if (head % 8 !== 0) head += 8 - head % 8;
  assert(head % 8 === 0, 'input should be aligned for int64');
  const [inputBuf, length] = formatInput(input, enc);
  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer');
  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE);
  wasm.memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos);
  wasm.memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head);
  this.pos = this.pos + length & 0x7f;
  wasm.exports.sha512(this.pointer, head, length, 0);
  return this;
};

Sha512.prototype.digest = function (enc, offset = 0) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  const paddingStart = this.pointer + INPUT_OFFSET + this.pos;
  wasm.memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE);
  wasm.exports.sha512(this.pointer, head, 0, 1);
  const resultBuf = wasm.memory.subarray(this.pointer, this.pointer + this.digestLength);

  if (!enc) {
    return resultBuf;
  }

  if (typeof enc === 'string') {
    if (enc === 'hex') return hexSlice(resultBuf, 0, resultBuf.length);
    if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(resultBuf);
    if (enc === 'base64') return btoa(resultBuf);
    throw new Error('Encoding: ' + enc + ' not supported');
  }

  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer');
  assert(enc.byteLength >= this.digestLength + offset, "output must have at least 'SHA512_BYTES' bytes remaining");

  for (let i = 0; i < this.digestLength; i++) {
    enc[i + offset] = resultBuf[i];
  }

  return enc;
};

Sha512.WASM = wasm && wasm.buffer;
Sha512.WASM_SUPPORTED = typeof WebAssembly !== 'undefined';

Sha512.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported'));
  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve(err);else reject();
      cb(err);
    });
  });
  return p;
};

Sha512.prototype.ready = Sha512.ready;

function HMAC(key) {
  if (!(this instanceof HMAC)) return new HMAC(key);
  this.pad = Buffer.alloc(128);
  this.inner = Sha512();
  this.outer = Sha512();
  const keyhash = Buffer.alloc(64);

  if (key.byteLength > 128) {
    Sha512().update(key).digest(keyhash);
    key = keyhash;
  }

  this.pad.fill(0x36);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.inner.update(this.pad);
  this.pad.fill(0x5c);

  for (let i = 0; i < key.byteLength; i++) {
    this.pad[i] ^= key[i];
  }

  this.outer.update(this.pad);
  this.pad.fill(0);
  keyhash.fill(0);
}

HMAC.prototype.update = function (input, enc) {
  this.inner.update(input, enc);
  return this;
};

HMAC.prototype.digest = function (enc, offset = 0) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc, offset);
};

Sha512.HMAC = HMAC;

function noop() {}

function formatInput(input, enc) {
  var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
  return [result, result.byteLength];
}

function strToBuf(input, enc) {
  if (enc === 'hex') return hex2bin(input);else if (enc === 'utf8' || enc === 'utf-8') return new TextEncoder().encode(input);else if (enc === 'base64') return atob(input);else throw new Error('Encoding: ' + enc + ' not supported');
}

function hex2bin(str) {
  if (str.length % 2 !== 0) return hex2bin('0' + str);
  var ret = new Uint8Array(str.length / 2);

  for (var i = 0; i < ret.length; i++) ret[i] = Number('0x' + str.substring(2 * i, 2 * i + 2));

  return ret;
}

function hexSlice(buf, start, len) {
  var str = '';

  for (var i = 0; i < len; i++) str += toHex(buf[start + i]);

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
} // only works for base that is power of 2


function roundUp(n, base) {
  return n + base - 1 & -base;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./sha512.js":465,"buffer":97,"nanoassert":464}],464:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],465:[function(require,module,exports){
module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABNAVgAX4BfmAIfn5+fn5+fn4AYAR+fn5+AX5gEX9+fn5+fn5+fn5+fn5+fn5+AGAEf39/fwADBgUAAQIDBAUDAQAABikIfgFCAAt+AUIAC34BQgALfgFCAAt+AUIAC34BQgALfgFCAAt+AUIACwcTAgZtZW1vcnkCAAZzaGE1MTIABAqZHgVCACAAQoCA/P+PgECDQhCJIABC//+DgPD/P4NCEIqEIQAgAEL/gfyH8J/A/wCDQgiJIABCgP6D+I/gv4B/g0IIioQLvAMBBn4jBCMFgyMEQn+FIwaDhSEKIwAjAYMjACMCg4UjASMCg4UhCyMAQhyKIwBCIoqFIwBCJ4qFIQwjBEIOiiMEQhKKhSMEQimKhSENIwcgCnwgDXwgAHwgBHwhCCAMIAt8IQkjAyAIfCQHIAggCXwkAyMHIwSDIwdCf4UjBYOFIQojAyMAgyMDIwGDhSMAIwGDhSELIwNCHIojA0IiioUjA0InioUhDCMHQg6KIwdCEoqFIwdCKYqFIQ0jBiAKfCANfCABfCAFfCEIIAwgC3whCSMCIAh8JAYgCCAJfCQCIwYjB4MjBkJ/hSMEg4UhCiMCIwODIwIjAIOFIwMjAIOFIQsjAkIciiMCQiKKhSMCQieKhSEMIwZCDoojBkISioUjBkIpioUhDSMFIAp8IA18IAJ8IAZ8IQggDCALfCEJIwEgCHwkBSAIIAl8JAEjBSMGgyMFQn+FIweDhSEKIwEjAoMjASMDg4UjAyMCg4UhCyMBQhyKIwFCIoqFIwFCJ4qFIQwjBUIOiiMFQhKKhSMFQimKhSENIwQgCnwgDXwgA3wgB3whCCAMIAt8IQkjACAIfCQEIAggCXwkAAsrACAAQhOKIABCPYqFIABCBoiFIAF8IAJCAYogAkIIioUgAkIHiIUgA3x8C6QRACAAKQPQAUIAUQRAIABCiJLznf/M+YTqADcDACAAQrvOqqbY0Ouzu383AwggAEKr8NP0r+68tzw3AxAgAELx7fT4paf9p6V/NwMYIABC0YWa7/rPlIfRADcDICAAQp/Y+dnCkdqCm383AyggAELr+obav7X2wR83AzAgAEL5wvibkaOz8NsANwM4IABCATcD0AELIAApAwAkACAAKQMIJAEgACkDECQCIAApAxgkAyAAKQMgJAQgACkDKCQFIAApAzAkBiAAKQM4JAcgARAAIQEgAhAAIQIgAxAAIQMgBBAAIQQgBRAAIQUgBhAAIQYgBxAAIQcgCBAAIQggCRAAIQkgChAAIQogCxAAIQsgDBAAIQwgDRAAIQ0gDhAAIQ4gDxAAIQ8gEBAAIRAgASACIAMgBEKi3KK5jfOLxcIAQs3LvZ+SktGb8QBCr/a04v75vuC1f0K8t6eM2PT22mkQASAFIAYgByAIQrjqopq/y7CrOUKZoJewm77E+NkAQpuf5fjK1OCfkn9CmIK2093al46rfxABIAkgCiALIAxCwoSMmIrT6oNYQr7fwauU4NbBEkKM5ZL35LfhmCRC4un+r724n4bVABABIA0gDiAPIBBC75Luk8+ul9/yAEKxrdrY47+s74B/QrWknK7y1IHum39ClM2k+8yu/M1BEAEgDyAKIAIgARACIQEgECALIAMgAhACIQIgASAMIAQgAxACIQMgAiANIAUgBBACIQQgAyAOIAYgBRACIQUgBCAPIAcgBhACIQYgBSAQIAggBxACIQcgBiABIAkgCBACIQggByACIAogCRACIQkgCCADIAsgChACIQogCSAEIAwgCxACIQsgCiAFIA0gDBACIQwgCyAGIA4gDRACIQ0gDCAHIA8gDhACIQ4gDSAIIBAgDxACIQ8gDiAJIAEgEBACIRAgASACIAMgBELSlcX3mbjazWRC48u8wuPwkd9vQrWrs9zouOfgD0LluLK9x7mohiQQASAFIAYgByAIQvWErMn1jcv0LUKDyZv1ppWhusoAQtT3h+rLu6rY3ABCtafFmKib4vz2ABABIAkgCiALIAxCq7+b866qlJ+Yf0KQ5NDt0s3xmKh/Qr/C7MeJ+cmBsH9C5J289/v436y/fxABIA0gDiAPIBBCwp+i7bP+gvBGQqXOqpj5qOTTVULvhI6AnuqY5QZC8Ny50PCsypQUEAEgDyAKIAIgARACIQEgECALIAMgAhACIQIgASAMIAQgAxACIQMgAiANIAUgBBACIQQgAyAOIAYgBRACIQUgBCAPIAcgBhACIQYgBSAQIAggBxACIQcgBiABIAkgCBACIQggByACIAogCRACIQkgCCADIAsgChACIQogCSAEIAwgCxACIQsgCiAFIA0gDBACIQwgCyAGIA4gDRACIQ0gDCAHIA8gDhACIQ4gDSAIIBAgDxACIQ8gDiAJIAEgEBACIRAgASACIAMgBEL838i21NDC2ydCppKb4YWnyI0uQu3VkNbFv5uWzQBC3+fW7Lmig5zTABABIAUgBiAHIAhC3se93cjqnIXlAEKo5d7js9eCtfYAQubdtr/kpbLhgX9Cu+qIpNGQi7mSfxABIAkgCiALIAxC5IbE55SU+t+if0KB4Ijiu8mZjah/QpGv4oeN7uKlQkKw/NKysLSUtkcQASANIA4gDyAQQpikvbedg7rJUUKQ0parxcTBzFZCqsDEu9WwjYd0Qrij75WDjqi1EBABIA8gCiACIAEQAiEBIBAgCyADIAIQAiECIAEgDCAEIAMQAiEDIAIgDSAFIAQQAiEEIAMgDiAGIAUQAiEFIAQgDyAHIAYQAiEGIAUgECAIIAcQAiEHIAYgASAJIAgQAiEIIAcgAiAKIAkQAiEJIAggAyALIAoQAiEKIAkgBCAMIAsQAiELIAogBSANIAwQAiEMIAsgBiAOIA0QAiENIAwgByAPIA4QAiEOIA0gCCAQIA8QAiEPIA4gCSABIBAQAiEQIAEgAiADIARCyKHLxuuisNIZQtPWhoqFgdubHkKZ17v8zemdpCdCqJHtjN6Wr9g0EAEgBSAGIAcgCELjtKWuvJaDjjlCy5WGmq7JquzOAELzxo+798myztsAQqPxyrW9/puX6AAQASAJIAogCyAMQvzlvu/l3eDH9ABC4N7cmPTt2NL4AELy1sKPyoKe5IR/QuzzkNOBwcDjjH8QASANIA4gDyAQQqi8jJui/7/fkH9C6fuK9L2dm6ikf0KV8pmW+/7o/L5/QqumyZuunt64RhABIA8gCiACIAEQAiEBIBAgCyADIAIQAiECIAEgDCAEIAMQAiEDIAIgDSAFIAQQAiEEIAMgDiAGIAUQAiEFIAQgDyAHIAYQAiEGIAUgECAIIAcQAiEHIAYgASAJIAgQAiEIIAcgAiAKIAkQAiEJIAggAyALIAoQAiEKIAkgBCAMIAsQAiELIAogBSANIAwQAiEMIAsgBiAOIA0QAiENIAwgByAPIA4QAiEOIA0gCCAQIA8QAiEPIA4gCSABIBAQAiEQIAEgAiADIARCnMOZ0e7Zz5NKQoeEg47ymK7DUUKe1oPv7Lqf7WpC+KK78/7v0751EAEgBSAGIAcgCEK6392Qp/WZ+AZCprGiltq437EKQq6b5PfLgOafEUKbjvGY0ebCuBsQASAJIAogCyAMQoT7kZjS/t3tKEKTyZyGtO+q5TJCvP2mrqHBr888QsyawODJ+NmOwwAQASANIA4gDyAQQraF+dnsl/XizABCqvyV48+zyr/ZAELs9dvWs/Xb5d8AQpewndLEsYai7AAQASAAIAApAwAjAHw3AwAgACAAKQMIIwF8NwMIIAAgACkDECMCfDcDECAAIAApAxgjA3w3AxggACAAKQMgIwR8NwMgIAAgACkDKCMFfDcDKCAAIAApAzAjBnw3AzAgACAAKQM4Iwd8NwM4C8MIARV+IAApA0AhBCAAKQNIIQUgBEL/AIMgAq18IQggBCEGIAQgAq18IQQgACAENwNAIAQgBlQEQCAFQgF8IQUgACAFNwNICwJAIAApA1AhCSAAKQNYIQogACkDYCELIAApA2ghDCAAKQNwIQ0gACkDeCEOIAApA4ABIQ8gACkDiAEhECAAKQOQASERIAApA5gBIRIgACkDoAEhEyAAKQOoASEUIAApA7ABIRUgACkDuAEhFiAAKQPAASEXIAApA8gBIRggCEKAAX0iCEIAUw0AIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADA0AgASkDACEJIAEpAwghCiABKQMQIQsgASkDGCEMIAEpAyAhDSABKQMoIQ4gASkDMCEPIAEpAzghECABKQNAIREgASkDSCESIAEpA1AhEyABKQNYIRQgASkDYCEVIAEpA2ghFiABKQNwIRcgASkDeCEYIAFBgAFqIQEgCEKAAX0iCEIAUwRAIAAgCTcDUCAAIAo3A1ggACALNwNgIAAgDDcDaCAAIA03A3AgACAONwN4IAAgDzcDgAEgACAQNwOIASAAIBE3A5ABIAAgEjcDmAEgACATNwOgASAAIBQ3A6gBIAAgFTcDsAEgACAWNwO4ASAAIBc3A8ABIAAgGDcDyAEMAgsgACAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYgFyAYEAMMAAsLIANBAUYEQCAEQv8AgyEIQoABIAhCB4NCA4aGIQcCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCKdBA3YODwMEBQYHCAkKCwwNDg8QAQILCyAHIBeEIRdCACEHCyAHIBiEIRhCACEHIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADIAAgBDcDQEIAIQlCACEKQgAhC0IAIQxCACENQgAhDkIAIQ9CACEQQgAhEUIAIRJCACETQgAhFEIAIRVCACEWQgAhF0IAIRgLIAcgCYQhCUIAIQcLIAcgCoQhCkIAIQcLIAcgC4QhC0IAIQcLIAcgDIQhDEIAIQcLIAcgDYQhDUIAIQcLIAcgDoQhDkIAIQcLIAcgD4QhD0IAIQcLIAcgEIQhEEIAIQcLIAcgEYQhEUIAIQcLIAcgEoQhEkIAIQcLIAcgE4QhE0IAIQcLIAcgFIQhFEIAIQcLIAcgFYQhFUIAIQcLIAcgFoQhFkIAIQcLIARCPYggBUIDiHwQACEXIARCCH4QACEYIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADIAAgACkDABAANwMAIAAgACkDCBAANwMIIAAgACkDEBAANwMQIAAgACkDGBAANwMYIAAgACkDIBAANwMgIAAgACkDKBAANwMoIAAgACkDMBAANwMwIAAgACkDOBAANwM4Cws=');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return require('buf' + 'fer').Buffer.from(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

},{}],466:[function(require,module,exports){
var varint = require('varint');

exports.encode = function encode(v, b, o) {
  v = v >= 0 ? v * 2 : v * -2 - 1;
  var r = varint.encode(v, b, o);
  encode.bytes = varint.encode.bytes;
  return r;
};

exports.decode = function decode(b, o) {
  var v = varint.decode(b, o);
  decode.bytes = varint.decode.bytes;
  return v & 1 ? (v + 1) / -2 : v / 2;
};

exports.encodingLength = function (v) {
  return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);
};

},{"varint":582}],467:[function(require,module,exports){
(function (Buffer){(function (){
var noise = require('noise-protocol');

var NoiseSymmetricState = require('noise-protocol/symmetric-state');

var NoiseHash = require('noise-protocol/hash');

var assert = require('nanoassert');

var EMPTY = Buffer.alloc(0);

function SimpleHandshake(isInitiator, opts) {
  if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts);
  opts = opts || {};
  var pattern = opts.pattern || 'NN';
  var prolouge = opts.prolouge || EMPTY;
  this.handshakeHash = null;

  this.onstatickey = opts.onstatickey || function (_, cb) {
    cb();
  };

  this.onephemeralkey = opts.onephemeralkey || function (_, cb) {
    cb();
  };

  this.onhandshake = opts.onhandshake || function (_, cb) {
    cb();
  };

  this.state = noise.initialize(pattern, isInitiator, prolouge, opts.staticKeyPair, opts.ephemeralKeyPair, opts.remoteStaticKey, opts.remoteEphemeralKey); // initiators should send first message, so if initiator, waiting = false
  // while servers should await any message, so if not initiator, waiting = true

  this.waiting = isInitiator === false;
  this.finished = false; // Will hold the "split" for transport encryption after handshake

  this.split = null; // ~64KiB is the max noise message length

  this._tx = Buffer.alloc(65535);
  this._rx = Buffer.alloc(65535);
}

SimpleHandshake.prototype.recv = function recv(data, cb) {
  var self = this;
  assert(self.finished === false, 'Should not call recv if finished');
  assert(data != null, 'must have data');
  assert(data.byteLength <= self._rx.byteLength, 'too much data received');
  assert(self.waiting === true, 'Wrong state, not ready to receive data');
  assert(self.split == null, 'split should be null');
  var hasREBefore = self.state.re != null;
  var hasRSBefore = self.state.rs != null;

  try {
    self.split = noise.readMessage(self.state, data, self._rx);
  } catch (ex) {
    return self._finish(ex, null, cb);
  }

  self.waiting = false;
  var hasREAfter = self.state.re != null;
  var hasRSAfter = self.state.rs != null; // e and s may come in the same message, so we always have to check static
  // after ephemeral. Assumption here (which holds for all official Noise handshakes)
  // is that e always comes before s

  if (hasREBefore === false && hasREAfter === true) {
    return self.onephemeralkey(self.state.re, checkStatic);
  }

  return checkStatic();

  function checkStatic(err) {
    if (err) return ondone(err);

    if (hasRSBefore === false && hasRSAfter === true) {
      return self.onstatickey(self.state.rs, ondone);
    }

    return ondone();
  }

  function ondone(err) {
    if (err) return self._finish(err, null, cb);

    var msg = self._rx.subarray(0, noise.readMessage.bytes);

    if (self.split) return self._finish(null, msg, cb);
    cb(null, msg);
  }
};

SimpleHandshake.prototype.send = function send(data, cb) {
  assert(this.finished === false, 'Should not call send if finished');
  assert(this.waiting === false, 'Wrong state, not ready to send data');
  assert(this.split == null, 'split should be null');
  data = data || EMPTY;

  try {
    this.split = noise.writeMessage(this.state, data, this._tx);
  } catch (ex) {
    return this._finish(ex, null, cb);
  }

  this.waiting = true;

  var buf = this._tx.subarray(0, noise.writeMessage.bytes);

  if (this.split != null) return this._finish(null, buf, cb);
  return cb(null, buf);
};

SimpleHandshake.prototype.destroy = function () {
  this._finish(null, null, function () {});
};

SimpleHandshake.prototype._finish = function _finish(err, msg, cb) {
  assert(this.finished === false, 'Already finished');
  const self = this;
  self.finished = true;
  self.waiting = false;

  if (self.split) {
    self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN);
    NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash);
  }

  if (err) return ondone(err);
  self.onhandshake(self.state, ondone);

  function ondone(err) {
    noise.destroy(self.state);
    cb(err, msg, self.split); // Should be sodium_memzero?

    self._rx.fill(0);

    self._tx.fill(0);
  }
};

SimpleHandshake.keygen = noise.keygen;
SimpleHandshake.seedKeygen = noise.seedKeygen;
module.exports = SimpleHandshake;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"nanoassert":468,"noise-protocol":353,"noise-protocol/hash":352,"noise-protocol/symmetric-state":355}],468:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],469:[function(require,module,exports){
(function (Buffer){(function (){
const Handshake = require("./lib/handshake");

const messages = require("./messages");

const XOR = require("./lib/xor");

const SMC = require('simple-message-channels');

const crypto = require('hypercore-crypto');

const varint = require('varint');

module.exports = class SimpleProtocol {
  constructor(initiator, handlers) {
    const payload = {
      nonce: XOR.nonce()
    };
    this.handlers = handlers || {};
    this.remotePayload = null;
    this.remotePublicKey = null;
    this.publicKey = null;
    this.handshakeHash = null;
    this.destroyed = false;
    this._initiator = initiator;
    this._payload = payload;
    this._pending = [];
    this._handshake = null;
    this._split = null;
    this._encryption = null;
    this._noise = !(handlers.encrypted === false && handlers.noise === false);
    this._buffering = null;
    this._handshaking = false;
    this._messages = new SMC({
      onmessage,
      onmissing,
      context: this,
      types: [{
        context: this,
        onmessage: onopen,
        encoding: messages.Open
      }, {
        context: this,
        onmessage: onoptions,
        encoding: messages.Options
      }, {
        context: this,
        onmessage: onstatus,
        encoding: messages.Status
      }, {
        context: this,
        onmessage: onhave,
        encoding: messages.Have
      }, {
        context: this,
        onmessage: onunhave,
        encoding: messages.Unhave
      }, {
        context: this,
        onmessage: onwant,
        encoding: messages.Want
      }, {
        context: this,
        onmessage: onunwant,
        encoding: messages.Unwant
      }, {
        context: this,
        onmessage: onrequest,
        encoding: messages.Request
      }, {
        context: this,
        onmessage: oncancel,
        encoding: messages.Cancel
      }, {
        context: this,
        onmessage: ondata,
        encoding: messages.Data
      }, {
        context: this,
        onmessage: onclose,
        encoding: messages.Close
      }]
    });

    if (handlers.encrypted !== false || handlers.noise !== false) {
      this._handshaking = true;

      if (typeof this.handlers.keyPair !== 'function') {
        this._onkeypair(null, this.handlers.keyPair || null);
      } else {
        this._buffering = [];
        this.handlers.keyPair(this._onkeypair.bind(this));
      }
    }
  }

  _onkeypair(err, keyPair) {
    if (err) return this.destroy(err);
    if (this._handshake !== null) return;
    this.handlers.keyPair = keyPair;
    const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this));
    this.publicKey = handshake.keyPair.publicKey;
    this._handshake = handshake;

    if (this._buffering) {
      while (this._buffering.length) this._recv(this._buffering.shift());
    }

    this._buffering = null;
  }

  open(ch, message) {
    return this._send(ch, 0, message);
  }

  options(ch, message) {
    return this._send(ch, 1, message);
  }

  status(ch, message) {
    return this._send(ch, 2, message);
  }

  have(ch, message) {
    return this._send(ch, 3, message);
  }

  unhave(ch, message) {
    return this._send(ch, 4, message);
  }

  want(ch, message) {
    return this._send(ch, 5, message);
  }

  unwant(ch, message) {
    return this._send(ch, 6, message);
  }

  request(ch, message) {
    return this._send(ch, 7, message);
  }

  cancel(ch, message) {
    return this._send(ch, 8, message);
  }

  data(ch, message) {
    return this._send(ch, 9, message);
  }

  close(ch, message) {
    return this._send(ch, 10, message || {});
  }

  extension(ch, id, message) {
    const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length);
    varint.encode(id, buf, 0);
    message.copy(buf, varint.encode.bytes);
    return this._send(ch, 15, buf);
  }

  ping() {
    if (this._handshaking || this._pending.length) return;
    let ping = Buffer.from([0]);

    if (this._encryption !== null) {
      ping = this._encryption.encrypt(ping);
    }

    return this.handlers.send(ping);
  }

  _onhandshake(err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {
    if (err) return this.destroy(new Error('Noise handshake error')); // workaround for https://github.com/emilbayes/noise-protocol/issues/5

    if (!remotePayload) return this.destroy(new Error('Remote did not include a handshake payload'));
    this.remotePublicKey = remotePublicKey;
    this.handshakeHash = handshakeHash;

    try {
      remotePayload = messages.NoisePayload.decode(remotePayload);
    } catch (_) {
      return this.destroy(new Error('Could not parse remote payload'));
    }

    this._handshake = null;
    this._handshaking = false;
    this._split = split;
    this._encryption = this.handlers.encrypted === false ? null : new XOR({
      rnonce: remotePayload.nonce,
      tnonce: this._payload.nonce
    }, split);
    this.remotePayload = remotePayload;
    if (this.handlers.onhandshake) this.handlers.onhandshake();
    if (this.destroyed) return;
    if (overflow) this.recv(overflow);

    while (this._pending.length && !this.destroyed) {
      this._sendNow(...this._pending.shift());
    }
  }

  _send(channel, type, message) {
    if (this._handshaking || this._pending.length) {
      this._pending.push([channel, type, message]);

      return false;
    }

    return this._sendNow(channel, type, message);
  }

  _sendNow(channel, type, message) {
    if (type === 0 && message.key && !message.capability) {
      message.capability = this.capability(message.key);
      message.key = null;
    }

    let data = this._messages.send(channel, type, message);

    if (this._encryption !== null) {
      data = this._encryption.encrypt(data);
    }

    return this.handlers.send(data);
  }

  capability(key) {
    return crypto.capability(key, this._split);
  }

  remoteCapability(key) {
    return crypto.remoteCapability(key, this._split);
  }

  recv(data) {
    if (this._buffering !== null) this._buffering.push(data);else this._recv(data);
  }

  _recv(data) {
    if (this.destroyed) return;

    if (this._handshaking) {
      this._handshake.recv(data);

      return;
    }

    if (this._encryption !== null) {
      data = this._encryption.decrypt(data);
    }

    if (!this._messages.recv(data)) {
      this.destroy(this._messages.error);
    }
  }

  destroy(err) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (this._handshake) this._handshake.destroy();
    if (this._encryption) this._encryption.destroy();
    if (this.handlers.destroy) this.handlers.destroy(err);
  }

  static keyPair(seed) {
    return Handshake.keyPair(seed);
  }

};

function onopen(ch, message, self) {
  if (self.handlers.onopen) self.handlers.onopen(ch, message);
}

function onoptions(ch, message, self) {
  if (self.handlers.onoptions) self.handlers.onoptions(ch, message);
}

function onstatus(ch, message, self) {
  if (self.handlers.onstatus) self.handlers.onstatus(ch, message);
}

function onhave(ch, message, self) {
  if (self.handlers.onhave) self.handlers.onhave(ch, message);
}

function onunhave(ch, message, self) {
  if (self.handlers.onunhave) self.handlers.onunhave(ch, message);
}

function onwant(ch, message, self) {
  if (self.handlers.onwant) self.handlers.onwant(ch, message);
}

function onunwant(ch, message, self) {
  if (self.handlers.onunwant) self.handlers.onunwant(ch, message);
}

function onrequest(ch, message, self) {
  if (self.handlers.onrequest) self.handlers.onrequest(ch, message);
}

function oncancel(ch, message, self) {
  if (self.handlers.oncancel) self.handlers.oncancel(ch, message);
}

function ondata(ch, message, self) {
  if (self.handlers.ondata) self.handlers.ondata(ch, message);
}

function onclose(ch, message, self) {
  if (self.handlers.onclose) self.handlers.onclose(ch, message);
}

function onmessage(ch, type, message, self) {
  if (type !== 15) return;
  const id = varint.decode(message);
  const m = message.slice(varint.decode.bytes);
  if (self.handlers.onextension) self.handlers.onextension(ch, id, m);
}

function onmissing(bytes, self) {
  if (self.handlers.onmissing) self.handlers.onmissing(bytes);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/handshake":470,"./lib/xor":471,"./messages":472,"buffer":97,"hypercore-crypto":236,"simple-message-channels":473,"varint":582}],470:[function(require,module,exports){
(function (process,Buffer){(function (){
const SH = require('simple-handshake');

const DH = require('noise-protocol/dh');

const crypto = require('hypercore-crypto');

const varint = require('varint');

module.exports = class ProtocolHandshake {
  constructor(initiator, payload, opts, done) {
    this.options = opts;
    this.ondone = done;
    this.buffer = null;
    this.length = 0;
    this.remotePayload = null;
    this.payload = payload;
    this.keyPair = opts.keyPair || ProtocolHandshake.keyPair();
    this.remotePublicKey = null;
    this.onrecv = onrecv.bind(this);
    this.onsend = onsend.bind(this);
    this.destroyed = false;
    this.noise = SH(initiator, {
      pattern: 'XX',
      onhandshake,
      staticKeyPair: this.keyPair,
      onstatickey: onstatickey.bind(this)
    });
    const self = this;
    if (this.noise.waiting === false) process.nextTick(start, this);

    function onhandshake(state, cb) {
      process.nextTick(finish, self);
      cb(null);
    }
  }

  recv(data) {
    if (this.destroyed) return;
    if (this.buffer) this.buffer = Buffer.concat([this.buffer, data]);else this.buffer = data;

    while (!this.destroyed && !this.noise.finished) {
      if (!this.buffer || this.buffer.length < 3) return;

      if (this.length) {
        if (this.buffer.length < this.length) return;
        const message = this.buffer.slice(0, this.length);
        this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null;
        this.length = 0;
        this.noise.recv(message, this.onrecv);
      } else {
        this.length = varint.decode(this.buffer, 0);
        this.buffer = this.buffer.slice(varint.decode.bytes);
      }
    }
  }

  destroy(err) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (!this.noise.finished) this.noise.destroy();
    this.ondone(err);
  }

  static keyPair(seed) {
    const obj = {
      // suboptimal but to reduce secure memory overhead on linux with default settings
      // better fix is to batch mallocs in noise-protocol
      publicKey: Buffer.alloc(DH.PKLEN),
      secretKey: Buffer.alloc(DH.SKLEN)
    };
    if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);else DH.generateKeypair(obj.publicKey, obj.secretKey);
    return obj;
  }

};

function finish(self) {
  if (self.destroyed) return;
  self.destroyed = true; // suboptimal but to reduce secure memory overhead on linux with default settings
  // better fix is to batch mallocs in noise-protocol

  const split = {
    rx: Buffer.from(self.noise.split.rx),
    tx: Buffer.from(self.noise.split.tx)
  };
  crypto.free(self.noise.split.rx);
  crypto.free(self.noise.split.tx);
  self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash);
}

function start(self) {
  if (self.destroyed) return;
  self.noise.send(self.payload, self.onsend);
}

function onsend(err, data) {
  if (err) return this.destroy(err);
  const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length);
  varint.encode(data.length, buf, 0);
  data.copy(buf, varint.encode.bytes);
  this.options.send(buf);
}

function onrecv(err, data) {
  // data is reused so we need to copy it if we use it
  if (err) return this.destroy(err);
  if (data && data.length) this.remotePayload = Buffer.concat([data]);
  if (this.destroyed || this.noise.finished) return;

  if (this.noise.waiting === false) {
    this.noise.send(this.payload, this.onsend);
  }
}

function onstatickey(remoteKey, done) {
  this.remotePublicKey = Buffer.concat([remoteKey]);
  if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done);else done(null);
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":380,"buffer":97,"hypercore-crypto":236,"noise-protocol/dh":350,"simple-handshake":467,"varint":582}],471:[function(require,module,exports){
const XSalsa20 = require('xsalsa20-universal');

const crypto = require('hypercore-crypto');

module.exports = class XOR {
  constructor(nonces, split) {
    this.rnonce = nonces.rnonce;
    this.tnonce = nonces.tnonce;
    this.rx = new XSalsa20(this.rnonce, split.rx.slice(0, 32));
    this.tx = new XSalsa20(this.tnonce, split.tx.slice(0, 32));
  }

  encrypt(data) {
    this.tx.update(data, data);
    return data;
  }

  decrypt(data) {
    this.rx.update(data, data);
    return data;
  }

  destroy() {
    this.tx.final();
    this.rx.final();
  }

  static nonce() {
    return crypto.randomBytes(24);
  }

};

},{"hypercore-crypto":236,"xsalsa20-universal":590}],472:[function(require,module,exports){
(function (Buffer){(function (){
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */

/* eslint-disable indent */

/* eslint-disable no-redeclare */

/* eslint-disable camelcase */
// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings');

var varint = encodings.varint;
var skip = encodings.skip;
var NoisePayload = exports.NoisePayload = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Open = exports.Open = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Options = exports.Options = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Status = exports.Status = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Have = exports.Have = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Unhave = exports.Unhave = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Want = exports.Want = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Unwant = exports.Unwant = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Request = exports.Request = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Cancel = exports.Cancel = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Data = exports.Data = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
var Close = exports.Close = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
};
defineNoisePayload();
defineOpen();
defineOptions();
defineStatus();
defineHave();
defineUnhave();
defineWant();
defineUnwant();
defineRequest();
defineCancel();
defineData();
defineClose();

function defineNoisePayload() {
  var enc = [encodings.bytes];
  NoisePayload.encodingLength = encodingLength;
  NoisePayload.encode = encode;
  NoisePayload.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.nonce)) throw new Error("nonce is required");
    var len = enc[0].encodingLength(obj.nonce);
    length += 1 + len;
    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.nonce)) throw new Error("nonce is required");
    buf[offset++] = 10;
    enc[0].encode(obj.nonce, buf, offset);
    offset += enc[0].encode.bytes;
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      nonce: null
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.nonce = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineOpen() {
  var enc = [encodings.bytes];
  Open.encodingLength = encodingLength;
  Open.encode = encode;
  Open.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.discoveryKey)) throw new Error("discoveryKey is required");
    var len = enc[0].encodingLength(obj.discoveryKey);
    length += 1 + len;

    if (defined(obj.capability)) {
      var len = enc[0].encodingLength(obj.capability);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.discoveryKey)) throw new Error("discoveryKey is required");
    buf[offset++] = 10;
    enc[0].encode(obj.discoveryKey, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.capability)) {
      buf[offset++] = 18;
      enc[0].encode(obj.capability, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      discoveryKey: null,
      capability: null
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.discoveryKey = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.capability = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineOptions() {
  var enc = [encodings.string, encodings.bool];
  Options.encodingLength = encodingLength;
  Options.encode = encode;
  Options.decode = decode;

  function encodingLength(obj) {
    var length = 0;

    if (defined(obj.extensions)) {
      for (var i = 0; i < obj.extensions.length; i++) {
        if (!defined(obj.extensions[i])) continue;
        var len = enc[0].encodingLength(obj.extensions[i]);
        length += 1 + len;
      }
    }

    if (defined(obj.ack)) {
      var len = enc[1].encodingLength(obj.ack);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;

    if (defined(obj.extensions)) {
      for (var i = 0; i < obj.extensions.length; i++) {
        if (!defined(obj.extensions[i])) continue;
        buf[offset++] = 10;
        enc[0].encode(obj.extensions[i], buf, offset);
        offset += enc[0].encode.bytes;
      }
    }

    if (defined(obj.ack)) {
      buf[offset++] = 16;
      enc[1].encode(obj.ack, buf, offset);
      offset += enc[1].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      extensions: [],
      ack: false
    };

    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.extensions.push(enc[0].decode(buf, offset));
          offset += enc[0].decode.bytes;
          break;

        case 2:
          obj.ack = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineStatus() {
  var enc = [encodings.bool];
  Status.encodingLength = encodingLength;
  Status.encode = encode;
  Status.decode = decode;

  function encodingLength(obj) {
    var length = 0;

    if (defined(obj.uploading)) {
      var len = enc[0].encodingLength(obj.uploading);
      length += 1 + len;
    }

    if (defined(obj.downloading)) {
      var len = enc[0].encodingLength(obj.downloading);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;

    if (defined(obj.uploading)) {
      buf[offset++] = 8;
      enc[0].encode(obj.uploading, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.downloading)) {
      buf[offset++] = 16;
      enc[0].encode(obj.downloading, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      uploading: false,
      downloading: false
    };

    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.uploading = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 2:
          obj.downloading = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineHave() {
  var enc = [encodings.varint, encodings.bytes, encodings.bool];
  Have.encodingLength = encodingLength;
  Have.encode = encode;
  Have.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.start)) throw new Error("start is required");
    var len = enc[0].encodingLength(obj.start);
    length += 1 + len;

    if (defined(obj.length)) {
      var len = enc[0].encodingLength(obj.length);
      length += 1 + len;
    }

    if (defined(obj.bitfield)) {
      var len = enc[1].encodingLength(obj.bitfield);
      length += 1 + len;
    }

    if (defined(obj.ack)) {
      var len = enc[2].encodingLength(obj.ack);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.start)) throw new Error("start is required");
    buf[offset++] = 8;
    enc[0].encode(obj.start, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.length)) {
      buf[offset++] = 16;
      enc[0].encode(obj.length, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.bitfield)) {
      buf[offset++] = 26;
      enc[1].encode(obj.bitfield, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.ack)) {
      buf[offset++] = 32;
      enc[2].encode(obj.ack, buf, offset);
      offset += enc[2].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      start: 0,
      length: 1,
      bitfield: null,
      ack: false
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.start = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.length = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 3:
          obj.bitfield = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 4:
          obj.ack = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineUnhave() {
  var enc = [encodings.varint];
  Unhave.encodingLength = encodingLength;
  Unhave.encode = encode;
  Unhave.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.start)) throw new Error("start is required");
    var len = enc[0].encodingLength(obj.start);
    length += 1 + len;

    if (defined(obj.length)) {
      var len = enc[0].encodingLength(obj.length);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.start)) throw new Error("start is required");
    buf[offset++] = 8;
    enc[0].encode(obj.start, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.length)) {
      buf[offset++] = 16;
      enc[0].encode(obj.length, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      start: 0,
      length: 1
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.start = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.length = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineWant() {
  var enc = [encodings.varint];
  Want.encodingLength = encodingLength;
  Want.encode = encode;
  Want.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.start)) throw new Error("start is required");
    var len = enc[0].encodingLength(obj.start);
    length += 1 + len;

    if (defined(obj.length)) {
      var len = enc[0].encodingLength(obj.length);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.start)) throw new Error("start is required");
    buf[offset++] = 8;
    enc[0].encode(obj.start, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.length)) {
      buf[offset++] = 16;
      enc[0].encode(obj.length, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      start: 0,
      length: 0
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.start = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.length = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineUnwant() {
  var enc = [encodings.varint];
  Unwant.encodingLength = encodingLength;
  Unwant.encode = encode;
  Unwant.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.start)) throw new Error("start is required");
    var len = enc[0].encodingLength(obj.start);
    length += 1 + len;

    if (defined(obj.length)) {
      var len = enc[0].encodingLength(obj.length);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.start)) throw new Error("start is required");
    buf[offset++] = 8;
    enc[0].encode(obj.start, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.length)) {
      buf[offset++] = 16;
      enc[0].encode(obj.length, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      start: 0,
      length: 0
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.start = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.length = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineRequest() {
  var enc = [encodings.varint, encodings.bool];
  Request.encodingLength = encodingLength;
  Request.encode = encode;
  Request.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.index)) throw new Error("index is required");
    var len = enc[0].encodingLength(obj.index);
    length += 1 + len;

    if (defined(obj.bytes)) {
      var len = enc[0].encodingLength(obj.bytes);
      length += 1 + len;
    }

    if (defined(obj.hash)) {
      var len = enc[1].encodingLength(obj.hash);
      length += 1 + len;
    }

    if (defined(obj.nodes)) {
      var len = enc[0].encodingLength(obj.nodes);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.index)) throw new Error("index is required");
    buf[offset++] = 8;
    enc[0].encode(obj.index, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.bytes)) {
      buf[offset++] = 16;
      enc[0].encode(obj.bytes, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.hash)) {
      buf[offset++] = 24;
      enc[1].encode(obj.hash, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.nodes)) {
      buf[offset++] = 32;
      enc[0].encode(obj.nodes, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      index: 0,
      bytes: 0,
      hash: false,
      nodes: 0
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.index = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.bytes = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 3:
          obj.hash = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 4:
          obj.nodes = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineCancel() {
  var enc = [encodings.varint, encodings.bool];
  Cancel.encodingLength = encodingLength;
  Cancel.encode = encode;
  Cancel.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.index)) throw new Error("index is required");
    var len = enc[0].encodingLength(obj.index);
    length += 1 + len;

    if (defined(obj.bytes)) {
      var len = enc[0].encodingLength(obj.bytes);
      length += 1 + len;
    }

    if (defined(obj.hash)) {
      var len = enc[1].encodingLength(obj.hash);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.index)) throw new Error("index is required");
    buf[offset++] = 8;
    enc[0].encode(obj.index, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.bytes)) {
      buf[offset++] = 16;
      enc[0].encode(obj.bytes, buf, offset);
      offset += enc[0].encode.bytes;
    }

    if (defined(obj.hash)) {
      buf[offset++] = 24;
      enc[1].encode(obj.hash, buf, offset);
      offset += enc[1].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      index: 0,
      bytes: 0,
      hash: false
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.index = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.bytes = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        case 3:
          obj.hash = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineData() {
  var Node = Data.Node = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  defineNode();

  function defineNode() {
    var enc = [encodings.varint, encodings.bytes];
    Node.encodingLength = encodingLength;
    Node.encode = encode;
    Node.decode = decode;

    function encodingLength(obj) {
      var length = 0;
      if (!defined(obj.index)) throw new Error("index is required");
      var len = enc[0].encodingLength(obj.index);
      length += 1 + len;
      if (!defined(obj.hash)) throw new Error("hash is required");
      var len = enc[1].encodingLength(obj.hash);
      length += 1 + len;
      if (!defined(obj.size)) throw new Error("size is required");
      var len = enc[0].encodingLength(obj.size);
      length += 1 + len;
      return length;
    }

    function encode(obj, buf, offset) {
      if (!offset) offset = 0;
      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (!defined(obj.index)) throw new Error("index is required");
      buf[offset++] = 8;
      enc[0].encode(obj.index, buf, offset);
      offset += enc[0].encode.bytes;
      if (!defined(obj.hash)) throw new Error("hash is required");
      buf[offset++] = 18;
      enc[1].encode(obj.hash, buf, offset);
      offset += enc[1].encode.bytes;
      if (!defined(obj.size)) throw new Error("size is required");
      buf[offset++] = 24;
      enc[0].encode(obj.size, buf, offset);
      offset += enc[0].encode.bytes;
      encode.bytes = offset - oldOffset;
      return buf;
    }

    function decode(buf, offset, end) {
      if (!offset) offset = 0;
      if (!end) end = buf.length;
      if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        index: 0,
        hash: null,
        size: 0
      };
      var found0 = false;
      var found1 = false;
      var found2 = false;

      while (true) {
        if (end <= offset) {
          if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid");
          decode.bytes = offset - oldOffset;
          return obj;
        }

        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;

        switch (tag) {
          case 1:
            obj.index = enc[0].decode(buf, offset);
            offset += enc[0].decode.bytes;
            found0 = true;
            break;

          case 2:
            obj.hash = enc[1].decode(buf, offset);
            offset += enc[1].decode.bytes;
            found1 = true;
            break;

          case 3:
            obj.size = enc[0].decode(buf, offset);
            offset += enc[0].decode.bytes;
            found2 = true;
            break;

          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }

  var enc = [encodings.varint, encodings.bytes, Node];
  Data.encodingLength = encodingLength;
  Data.encode = encode;
  Data.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (!defined(obj.index)) throw new Error("index is required");
    var len = enc[0].encodingLength(obj.index);
    length += 1 + len;

    if (defined(obj.value)) {
      var len = enc[1].encodingLength(obj.value);
      length += 1 + len;
    }

    if (defined(obj.nodes)) {
      for (var i = 0; i < obj.nodes.length; i++) {
        if (!defined(obj.nodes[i])) continue;
        var len = enc[2].encodingLength(obj.nodes[i]);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
    }

    if (defined(obj.signature)) {
      var len = enc[1].encodingLength(obj.signature);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (!defined(obj.index)) throw new Error("index is required");
    buf[offset++] = 8;
    enc[0].encode(obj.index, buf, offset);
    offset += enc[0].encode.bytes;

    if (defined(obj.value)) {
      buf[offset++] = 18;
      enc[1].encode(obj.value, buf, offset);
      offset += enc[1].encode.bytes;
    }

    if (defined(obj.nodes)) {
      for (var i = 0; i < obj.nodes.length; i++) {
        if (!defined(obj.nodes[i])) continue;
        buf[offset++] = 26;
        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset);
        offset += varint.encode.bytes;
        enc[2].encode(obj.nodes[i], buf, offset);
        offset += enc[2].encode.bytes;
      }
    }

    if (defined(obj.signature)) {
      buf[offset++] = 34;
      enc[1].encode(obj.signature, buf, offset);
      offset += enc[1].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      index: 0,
      value: null,
      nodes: [],
      signature: null
    };
    var found0 = false;

    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid");
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.index = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          found0 = true;
          break;

        case 2:
          obj.value = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        case 3:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.nodes.push(enc[2].decode(buf, offset, offset + len));
          offset += enc[2].decode.bytes;
          break;

        case 4:
          obj.signature = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineClose() {
  var enc = [encodings.bytes];
  Close.encodingLength = encodingLength;
  Close.encode = encode;
  Close.decode = decode;

  function encodingLength(obj) {
    var length = 0;

    if (defined(obj.discoveryKey)) {
      var len = enc[0].encodingLength(obj.discoveryKey);
      length += 1 + len;
    }

    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;

    if (defined(obj.discoveryKey)) {
      buf[offset++] = 10;
      enc[0].encode(obj.discoveryKey, buf, offset);
      offset += enc[0].encode.bytes;
    }

    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      discoveryKey: null
    };

    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }

      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;

      switch (tag) {
        case 1:
          obj.discoveryKey = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;

        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"protocol-buffers-encodings":382}],473:[function(require,module,exports){
(function (Buffer){(function (){
const varint = require('varint');

module.exports = class SimpleMessageChannels {
  constructor({
    maxSize = 8 * 1024 * 1024,
    context = null,
    onmessage = null,
    onmissing = null,
    types = null
  } = {}) {
    this._message = null;
    this._ptr = 0;
    this._varint = 0;
    this._factor = 1;
    this._length = 0;
    this._header = 0;
    this._state = 0;
    this._consumed = 0;
    this._maxSize = maxSize;
    this._types = types || [];
    this.receiving = false;
    this.destroyed = false;
    this.error = null;
    this.context = context;
    this.onmessage = onmessage;
    this.onmissing = onmissing;
  }

  destroy(err) {
    if (err) this.error = err;
    this.destroyed = true;
  }

  recv(data) {
    if (this.receiving === true) throw new Error('Cannot recursively receive data');
    this.receiving = true;
    let offset = 0;

    while (offset < data.length) {
      if (this._state === 2) offset = this._readMessage(data, offset);else offset = this._readVarint(data, offset);
    }

    if (this._state === 2 && this._length === 0) {
      this._readMessage(data, offset);
    }

    this.receiving = false;
    return !this.destroyed;
  }

  _readMessage(data, offset) {
    const free = data.length - offset;

    if (free >= this._length) {
      if (this._message) {
        data.copy(this._message, this._message.length - this._length, offset);
      } else {
        this._message = data.slice(offset, offset + this._length);
      }

      return this._nextState(data, offset += this._length) ? offset : data.length;
    }

    if (!this._message) this._message = Buffer.allocUnsafe(this._length);
    data.copy(this._message, this._message.length - this._length, offset);
    this._length -= free;
    return data.length;
  }

  _readVarint(data, offset) {
    for (; offset < data.length; offset++) {
      this._varint += (data[offset] & 127) * this._factor;
      this._consumed++;
      if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length;
      this._factor *= 128;
    }

    if (this._consumed >= 8) this.destroy(new Error('Incoming varint is invalid')); // 8 * 7bits is 56 ie max for js

    return data.length;
  }

  _nextState(data, offset) {
    switch (this._state) {
      case 0:
        this._state = 1;
        this._factor = 1;
        this._length = this._varint;
        this._consumed = this._varint = 0;
        if (this._length === 0) this._state = 0;
        return true;

      case 1:
        this._state = 2;
        this._factor = 1;
        this._header = this._varint;
        this._length -= this._consumed;
        this._consumed = this._varint = 0;

        if (this._length < 0 || this._length > this._maxSize) {
          this.destroy(new Error('Incoming message is larger than max size'));
          return false;
        }

        if (this.onmissing) {
          const extra = data.length - offset;
          if (this._length > extra) this.onmissing(this._length - extra, this.context);
        }

        return true;

      case 2:
        this._state = 0;

        this._onmessage(this._header >> 4, this._header & 0b1111, this._message, data, offset);

        this._message = null;
        return !this.destroyed;

      default:
        return false;
    }
  }

  _onmessage(channel, type, message, data, offset) {
    if (type >= this._types.length) {
      if (this.onmessage === null) return;
      return this.onmessage(channel, type, message, this.context, data, offset);
    }

    let m = null;
    const {
      onmessage,
      encoding,
      context
    } = this._types[type];

    try {
      m = encoding.decode(message);
    } catch (err) {
      this.destroy(err);
      return;
    }

    onmessage(channel, m, context, data, offset);
  }

  send(channel, type, message) {
    const header = channel << 4 | type;
    const length = this._encodingLength(type, message) + varint.encodingLength(header);
    const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length);
    varint.encode(length, payload, 0);
    const offset = varint.encode.bytes;
    varint.encode(header, payload, offset);

    this._encode(type, message, payload, offset + varint.encode.bytes);

    return payload;
  }

  sendBatch(messages) {
    let length = 0;
    let offset = 0;

    for (const {
      type,
      message
    } of messages) {
      // 16 is >= the max size of the varints
      length += 16 + this._encodingLength(type, message);
    }

    const payload = Buffer.allocUnsafe(length);

    for (const {
      channel,
      type,
      message
    } of messages) {
      const header = channel << 4 | type;
      const length = this._encodingLength(type, message) + varint.encodingLength(header);
      varint.encode(length, payload, offset);
      offset += varint.encode.bytes;
      varint.encode(header, payload, offset);
      offset += varint.encode.bytes;
      offset += this._encode(type, message, payload, offset);
    }

    return payload.slice(0, offset);
  }

  _encodingLength(type, message) {
    if (type >= this._types.length) return message.length;
    return this._types[type].encoding.encodingLength(message);
  }

  _encode(type, message, buf, offset) {
    if (type >= this._types.length) {
      message.copy(buf, offset);
      return message.length;
    }

    const enc = this._types[type].encoding;
    enc.encode(message, buf, offset);
    return enc.encode.bytes;
  }

};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"varint":582}],474:[function(require,module,exports){
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = require('debug')('simple-peer');

const getBrowserRTC = require('get-browser-rtc');

const randombytes = require('randombytes');

const stream = require('readable-stream');

const queueMicrotask = require('queue-microtask'); // TODO: remove when Node 10 is not supported


const errCode = require('err-code');

const {
  Buffer
} = require('buffer');

const MAX_BUFFERED_AMOUNT = 64 * 1024;
const ICECOMPLETE_TIMEOUT = 5 * 1000;
const CHANNEL_CLOSING_TIMEOUT = 5 * 1000; // HACK: Filter trickle lines when trickle is disabled #354

function filterTrickle(sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '');
}

function warn(message) {
  console.warn(message);
}
/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */


class Peer extends stream.Duplex {
  constructor(opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);
    this._id = randombytes(4).toString('hex').slice(0, 7);

    this._debug('new peer %o', opts);

    this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString('hex') : null;
    this.initiator = opts.initiator || false;
    this.channelConfig = opts.channelConfig || Peer.channelConfig;
    this.channelNegotiated = this.channelConfig.negotiated;
    this.config = Object.assign({}, Peer.config, opts.config);
    this.offerOptions = opts.offerOptions || {};
    this.answerOptions = opts.answerOptions || {};

    this.sdpTransform = opts.sdpTransform || (sdp => sdp);

    this.streams = opts.streams || (opts.stream ? [opts.stream] : []); // support old "stream" option

    this.trickle = opts.trickle !== undefined ? opts.trickle : true;
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
    this.destroyed = false;
    this.destroying = false;
    this._connected = false;
    this.remoteAddress = undefined;
    this.remoteFamily = undefined;
    this.remotePort = undefined;
    this.localAddress = undefined;
    this.localFamily = undefined;
    this.localPort = undefined;
    this._wrtc = opts.wrtc && typeof opts.wrtc === 'object' ? opts.wrtc : getBrowserRTC();

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT');
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT');
      }
    }

    this._pcReady = false;
    this._channelReady = false;
    this._iceComplete = false; // ice candidate trickle done (got null candidate)

    this._iceCompleteTimer = null; // send an offer/answer anyway after some timeout

    this._channel = null;
    this._pendingCandidates = [];
    this._isNegotiating = false; // is this peer waiting for negotiation to complete?

    this._firstNegotiation = true;
    this._batchedNegotiation = false; // batch synchronous negotiations

    this._queuedNegotiation = false; // is there a queued negotiation request?

    this._sendersAwaitingStable = [];
    this._senderMap = new Map();
    this._closingInterval = null;
    this._remoteTracks = [];
    this._remoteStreams = [];
    this._chunk = null;
    this._cb = null;
    this._interval = null;

    try {
      this._pc = new this._wrtc.RTCPeerConnection(this.config);
    } catch (err) {
      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'));
      return;
    } // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.


    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number';

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    };

    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    };

    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    };

    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    };

    this._pc.onicecandidate = event => {
      this._onIceCandidate(event);
    }; // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783


    if (typeof this._pc.peerIdentity === 'object') {
      this._pc.peerIdentity.catch(err => {
        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'));
      });
    } // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded


    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      });
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event);
      };
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream);
      });
    }

    this._pc.ontrack = event => {
      this._onTrack(event);
    };

    this._debug('initial negotiation');

    this._needsNegotiation();

    this._onFinishBound = () => {
      this._onFinish();
    };

    this.once('finish', this._onFinishBound);
  }

  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  } // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743


  get connected() {
    return this._connected && this._channel.readyState === 'open';
  }

  address() {
    return {
      port: this.localPort,
      family: this.localFamily,
      address: this.localAddress
    };
  }

  signal(data) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED');

    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (err) {
        data = {};
      }
    }

    this._debug('signal()');

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate');

      this._needsNegotiation();
    }

    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver');

      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
    }

    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate);
      } else {
        this._pendingCandidates.push(data.candidate);
      }
    }

    if (data.sdp) {
      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
        if (this.destroyed) return;

        this._pendingCandidates.forEach(candidate => {
          this._addIceCandidate(candidate);
        });

        this._pendingCandidates = [];
        if (this._pc.remoteDescription.type === 'offer') this._createAnswer();
      }).catch(err => {
        this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'));
      });
    }

    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'));
    }
  }

  _addIceCandidate(candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);

    this._pc.addIceCandidate(iceCandidateObj).catch(err => {
      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
        warn('Ignoring unsupported ICE candidate.');
      } else {
        this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'));
      }
    });
  }
  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */


  send(chunk) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED');

    this._channel.send(chunk);
  }
  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */


  addTransceiver(kind, init) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('addTransceiver()');

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init);

        this._needsNegotiation();
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'));
      }
    } else {
      this.emit('signal', {
        // request initiator to renegotiate
        type: 'transceiverRequest',
        transceiverRequest: {
          kind,
          init
        }
      });
    }
  }
  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */


  addStream(stream) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('addStream()');

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream);
    });
  }
  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */


  addTrack(track, stream) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('addTrack()');

    const submap = this._senderMap.get(track) || new Map(); // nested Maps map [track, stream] to sender

    let sender = submap.get(stream);

    if (!sender) {
      sender = this._pc.addTrack(track, stream);
      submap.set(stream, sender);

      this._senderMap.set(track, submap);

      this._needsNegotiation();
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED');
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED');
    }
  }
  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */


  replaceTrack(oldTrack, newTrack, stream) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('replaceTrack()');

    const submap = this._senderMap.get(oldTrack);

    const sender = submap ? submap.get(stream) : null;

    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED');
    }

    if (newTrack) this._senderMap.set(newTrack, submap);

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack);
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'));
    }
  }
  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */


  removeTrack(track, stream) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('removeSender()');

    const submap = this._senderMap.get(track);

    const sender = submap ? submap.get(stream) : null;

    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED');
    }

    try {
      sender.removed = true;

      this._pc.removeTrack(sender);
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender); // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874

      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'));
      }
    }

    this._needsNegotiation();
  }
  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */


  removeStream(stream) {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED');

    this._debug('removeSenders()');

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream);
    });
  }

  _needsNegotiation() {
    this._debug('_needsNegotiation');

    if (this._batchedNegotiation) return; // batch synchronous renegotiations

    this._batchedNegotiation = true;
    queueMicrotask(() => {
      this._batchedNegotiation = false;

      if (this.initiator || !this._firstNegotiation) {
        this._debug('starting batched negotiation');

        this.negotiate();
      } else {
        this._debug('non-initiator initial negotiation request discarded');
      }

      this._firstNegotiation = false;
    });
  }

  negotiate() {
    if (this.destroying) return;
    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED');

    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;

        this._debug('already negotiating, queueing');
      } else {
        this._debug('start negotiation');

        setTimeout(() => {
          // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer();
        }, 0);
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;

        this._debug('already negotiating, queueing');
      } else {
        this._debug('requesting negotiation from initiator');

        this.emit('signal', {
          // request initiator to renegotiate
          type: 'renegotiate',
          renegotiate: true
        });
      }
    }

    this._isNegotiating = true;
  } // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283


  destroy(err) {
    this._destroy(err, () => {});
  }

  _destroy(err, cb) {
    if (this.destroyed || this.destroying) return;
    this.destroying = true;

    this._debug('destroying (error: %s)', err && (err.message || err));

    queueMicrotask(() => {
      // allow events concurrent with the call to _destroy() to fire (see #692)
      this.destroyed = true;
      this.destroying = false;

      this._debug('destroy (error: %s)', err && (err.message || err));

      this.readable = this.writable = false;
      if (!this._readableState.ended) this.push(null);
      if (!this._writableState.finished) this.end();
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound);
      this._onFinishBound = null;

      if (this._channel) {
        try {
          this._channel.close();
        } catch (err) {} // allow events concurrent with destruction to be handled


        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }

      if (this._pc) {
        try {
          this._pc.close();
        } catch (err) {} // allow events concurrent with destruction to be handled


        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }

      this._pc = null;
      this._channel = null;
      if (err) this.emit('error', err);
      this.emit('close');
      cb();
    });
  }

  _setupData(event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'));
    }

    this._channel = event.channel;
    this._channel.binaryType = 'arraybuffer';

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }

    this.channelName = this._channel.label;

    this._channel.onmessage = event => {
      this._onChannelMessage(event);
    };

    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    };

    this._channel.onopen = () => {
      this._onChannelOpen();
    };

    this._channel.onclose = () => {
      this._onChannelClose();
    };

    this._channel.onerror = event => {
      const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));
    }; // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743


    let isClosing = false;
    this._closingInterval = setInterval(() => {
      // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose(); // closing timed out: equivalent to onclose firing

        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }

  _read() {}

  _write(chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'));

    if (this._connected) {
      try {
        this.send(chunk);
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));
      }

      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount);

        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug('write before connect');

      this._chunk = chunk;
      this._cb = cb;
    }
  } // When stream finishes writing, close socket. Half open connections are not
  // supported.


  _onFinish() {
    if (this.destroyed) return; // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?

    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000);
    };

    if (this._connected) {
      destroySoon();
    } else {
      this.once('connect', destroySoon);
    }
  }

  _startIceCompleteTimeout() {
    if (this.destroyed) return;
    if (this._iceCompleteTimer) return;

    this._debug('started iceComplete timeout');

    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true;

        this._debug('iceComplete timeout completed');

        this.emit('iceTimeout');
        this.emit('_iceComplete');
      }
    }, this.iceCompleteTimeout);
  }

  _createOffer() {
    if (this.destroyed) return;

    this._pc.createOffer(this.offerOptions).then(offer => {
      if (this.destroyed) return;
      if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);
      offer.sdp = this.sdpTransform(offer.sdp);

      const sendOffer = () => {
        if (this.destroyed) return;
        const signal = this._pc.localDescription || offer;

        this._debug('signal');

        this.emit('signal', {
          type: signal.type,
          sdp: signal.sdp
        });
      };

      const onSuccess = () => {
        this._debug('createOffer success');

        if (this.destroyed) return;
        if (this.trickle || this._iceComplete) sendOffer();else this.once('_iceComplete', sendOffer); // wait for candidates
      };

      const onError = err => {
        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));
      };

      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
    }).catch(err => {
      this.destroy(errCode(err, 'ERR_CREATE_OFFER'));
    });
  }

  _requestMissingTransceivers() {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true; // HACK: Safari returns negotiated transceivers with a null mid

          this.addTransceiver(transceiver.sender.track.kind);
        }
      });
    }
  }

  _createAnswer() {
    if (this.destroyed) return;

    this._pc.createAnswer(this.answerOptions).then(answer => {
      if (this.destroyed) return;
      if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);
      answer.sdp = this.sdpTransform(answer.sdp);

      const sendAnswer = () => {
        if (this.destroyed) return;
        const signal = this._pc.localDescription || answer;

        this._debug('signal');

        this.emit('signal', {
          type: signal.type,
          sdp: signal.sdp
        });
        if (!this.initiator) this._requestMissingTransceivers();
      };

      const onSuccess = () => {
        if (this.destroyed) return;
        if (this.trickle || this._iceComplete) sendAnswer();else this.once('_iceComplete', sendAnswer);
      };

      const onError = err => {
        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));
      };

      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
    }).catch(err => {
      this.destroy(errCode(err, 'ERR_CREATE_ANSWER'));
    });
  }

  _onConnectionStateChange() {
    if (this.destroyed) return;

    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'));
    }
  }

  _onIceStateChange() {
    if (this.destroyed) return;
    const iceConnectionState = this._pc.iceConnectionState;
    const iceGatheringState = this._pc.iceGatheringState;

    this._debug('iceStateChange (connection: %s) (gathering: %s)', iceConnectionState, iceGatheringState);

    this.emit('iceStateChange', iceConnectionState, iceGatheringState);

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true;

      this._maybeReady();
    }

    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'));
    }

    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'));
    }
  }

  getStats(cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value);
        });
      }

      return report;
    }; // Promise-based getStats() (standard)


    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats().then(res => {
        const reports = [];
        res.forEach(report => {
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, err => cb(err)); // Single-parameter callback-based getStats() (non-standard)

    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return;
        const reports = [];
        res.result().forEach(result => {
          const report = {};
          result.names().forEach(name => {
            report[name] = result.stat(name);
          });
          report.id = result.id;
          report.type = result.type;
          report.timestamp = result.timestamp;
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, err => cb(err)); // Unknown browser, skip getStats() since it's anyone's guess which style of
      // getStats() they implement.

    } else {
      cb(null, []);
    }
  }

  _maybeReady() {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady);

    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
    this._connecting = true; // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339

    const findCandidatePair = () => {
      if (this.destroyed) return;
      this.getStats((err, items) => {
        if (this.destroyed) return; // Treat getStats error as non-fatal. It's not essential.

        if (err) items = [];
        const remoteCandidates = {};
        const localCandidates = {};
        const candidatePairs = {};
        let foundSelectedCandidatePair = false;
        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item;
          }

          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item;
          }

          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item;
          }
        });

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true;
          let local = localCandidates[selectedCandidatePair.localCandidateId];

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address;
            this.localPort = Number(local.port);
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress;
            this.localPort = Number(local.portNumber);
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':');
            this.localAddress = local[0];
            this.localPort = Number(local[1]);
          }

          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4';
          }

          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address;
            this.remotePort = Number(remote.port);
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress;
            this.remotePort = Number(remote.portNumber);
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':');
            this.remoteAddress = remote[0];
            this.remotePort = Number(remote[1]);
          }

          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4';
          }

          this._debug('connect local: %s:%s remote: %s:%s', this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
        };

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
          } // Old implementations


          if (item.type === 'googCandidatePair' && item.googActiveConnection === 'true' || (item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected) {
            setSelectedCandidatePair(item);
          }
        }); // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available

        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100);
          return;
        } else {
          this._connecting = false;
          this._connected = true;
        }

        if (this._chunk) {
          try {
            this.send(this._chunk);
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));
          }

          this._chunk = null;

          this._debug('sent chunk from "write before connect"');

          const cb = this._cb;
          this._cb = null;
          cb(null);
        } // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.


        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150);
          if (this._interval.unref) this._interval.unref();
        }

        this._debug('connect');

        this.emit('connect');
      });
    };

    findCandidatePair();
  }

  _onInterval() {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }

    this._onChannelBufferedAmountLow();
  }

  _onSignalingStateChange() {
    if (this.destroyed) return;

    if (this._pc.signalingState === 'stable') {
      this._isNegotiating = false; // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'

      this._debug('flushing sender queue', this._sendersAwaitingStable);

      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender);

        this._queuedNegotiation = true;
      });

      this._sendersAwaitingStable = [];

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue');

        this._queuedNegotiation = false;

        this._needsNegotiation(); // negotiate again

      } else {
        this._debug('negotiated');

        this.emit('negotiated');
      }
    }

    this._debug('signalingStateChange %s', this._pc.signalingState);

    this.emit('signalingStateChange', this._pc.signalingState);
  }

  _onIceCandidate(event) {
    if (this.destroyed) return;

    if (event.candidate && this.trickle) {
      this.emit('signal', {
        type: 'candidate',
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      });
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true;
      this.emit('_iceComplete');
    } // as soon as we've received one valid candidate start timeout


    if (event.candidate) {
      this._startIceCompleteTimeout();
    }
  }

  _onChannelMessage(event) {
    if (this.destroyed) return;
    let data = event.data;
    if (data instanceof ArrayBuffer) data = Buffer.from(data);
    this.push(data);
  }

  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return;

    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount);

    const cb = this._cb;
    this._cb = null;
    cb(null);
  }

  _onChannelOpen() {
    if (this._connected || this.destroyed) return;

    this._debug('on channel open');

    this._channelReady = true;

    this._maybeReady();
  }

  _onChannelClose() {
    if (this.destroyed) return;

    this._debug('on channel close');

    this.destroy();
  }

  _onTrack(event) {
    if (this.destroyed) return;
    event.streams.forEach(eventStream => {
      this._debug('on track');

      this.emit('track', event.track, eventStream);

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      });

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id;
      })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream);

      queueMicrotask(() => {
        this._debug('on stream');

        this.emit('stream', eventStream); // ensure all tracks have been added
      });
    });
  }

  _debug() {
    const args = [].slice.call(arguments);
    args[0] = '[' + this._id + '] ' + args[0];
    debug.apply(null, args);
  }

}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */

Peer.config = {
  iceServers: [{
    urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478']
  }],
  sdpSemantics: 'unified-plan'
};
Peer.channelConfig = {};
module.exports = Peer;

},{"buffer":97,"debug":131,"err-code":169,"get-browser-rtc":184,"queue-microtask":412,"randombytes":427,"readable-stream":489}],475:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],476:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":478,"./_stream_writable":480,"_process":380,"dup":77,"inherits":279}],477:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":479,"dup":78,"inherits":279}],478:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":475,"./_stream_duplex":476,"./internal/streams/async_iterator":481,"./internal/streams/buffer_list":482,"./internal/streams/destroy":483,"./internal/streams/from":485,"./internal/streams/state":487,"./internal/streams/stream":488,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],479:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":475,"./_stream_duplex":476,"dup":80,"inherits":279}],480:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":475,"./_stream_duplex":476,"./internal/streams/destroy":483,"./internal/streams/state":487,"./internal/streams/stream":488,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],481:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":484,"_process":380,"dup":82}],482:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],483:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],484:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":475,"dup":85}],485:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],486:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":475,"./end-of-stream":484,"dup":87}],487:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":475,"dup":88}],488:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],489:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":476,"./lib/_stream_passthrough.js":477,"./lib/_stream_readable.js":478,"./lib/_stream_transform.js":479,"./lib/_stream_writable.js":480,"./lib/internal/streams/end-of-stream.js":484,"./lib/internal/streams/pipeline.js":486,"dup":90}],490:[function(require,module,exports){
(function (Buffer){(function (){
/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* global WebSocket */
const debug = require('debug')('simple-websocket');

const randombytes = require('randombytes');

const stream = require('readable-stream');

const queueMicrotask = require('queue-microtask'); // TODO: remove when Node 10 is not supported


const ws = require('ws'); // websockets in node - will be empty object in browser


const _WebSocket = typeof ws !== 'function' ? WebSocket : ws;

const MAX_BUFFERED_AMOUNT = 64 * 1024;
/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {Object} opts
 * @param {string=} opts.url websocket server url
 * @param {string=} opts.socket raw websocket instance to wrap
 */

class Socket extends stream.Duplex {
  constructor(opts = {}) {
    // Support simple usage: `new Socket(url)`
    if (typeof opts === 'string') {
      opts = {
        url: opts
      };
    }

    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);

    if (opts.url == null && opts.socket == null) {
      throw new Error('Missing required `url` or `socket` option');
    }

    if (opts.url != null && opts.socket != null) {
      throw new Error('Must specify either `url` or `socket` option, not both');
    }

    this._id = randombytes(4).toString('hex').slice(0, 7);

    this._debug('new websocket: %o', opts);

    this.connected = false;
    this.destroyed = false;
    this._chunk = null;
    this._cb = null;
    this._interval = null;

    if (opts.socket) {
      this.url = opts.socket.url;
      this._ws = opts.socket;
      this.connected = opts.socket.readyState === _WebSocket.OPEN;
    } else {
      this.url = opts.url;

      try {
        if (typeof ws === 'function') {
          // `ws` package accepts options
          this._ws = new _WebSocket(opts.url, null, { ...opts,
            encoding: undefined // encoding option breaks ws internals

          });
        } else {
          this._ws = new _WebSocket(opts.url);
        }
      } catch (err) {
        queueMicrotask(() => this.destroy(err));
        return;
      }
    }

    this._ws.binaryType = 'arraybuffer';

    if (opts.socket && this.connected) {
      queueMicrotask(() => this._handleOpen());
    } else {
      this._ws.onopen = () => this._handleOpen();
    }

    this._ws.onmessage = event => this._handleMessage(event);

    this._ws.onclose = () => this._handleClose();

    this._ws.onerror = err => this._handleError(err);

    this._handleFinishBound = () => this._handleFinish();

    this.once('finish', this._handleFinishBound);
  }
  /**
   * Send text/binary data to the WebSocket server.
   * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
   */


  send(chunk) {
    this._ws.send(chunk);
  } // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283


  destroy(err) {
    this._destroy(err, () => {});
  }

  _destroy(err, cb) {
    if (this.destroyed) return;

    this._debug('destroy (error: %s)', err && (err.message || err));

    this.readable = this.writable = false;
    if (!this._readableState.ended) this.push(null);
    if (!this._writableState.finished) this.end();
    this.connected = false;
    this.destroyed = true;
    clearInterval(this._interval);
    this._interval = null;
    this._chunk = null;
    this._cb = null;

    if (this._handleFinishBound) {
      this.removeListener('finish', this._handleFinishBound);
    }

    this._handleFinishBound = null;

    if (this._ws) {
      const ws = this._ws;

      const onClose = () => {
        ws.onclose = null;
      };

      if (ws.readyState === _WebSocket.CLOSED) {
        onClose();
      } else {
        try {
          ws.onclose = onClose;
          ws.close();
        } catch (err) {
          onClose();
        }
      }

      ws.onopen = null;
      ws.onmessage = null;

      ws.onerror = () => {};
    }

    this._ws = null;
    if (err) this.emit('error', err);
    this.emit('close');
    cb();
  }

  _read() {}

  _write(chunk, encoding, cb) {
    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'));

    if (this.connected) {
      try {
        this.send(chunk);
      } catch (err) {
        return this.destroy(err);
      }

      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount);

        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug('write before connect');

      this._chunk = chunk;
      this._cb = cb;
    }
  }

  _handleOpen() {
    if (this.connected || this.destroyed) return;
    this.connected = true;

    if (this._chunk) {
      try {
        this.send(this._chunk);
      } catch (err) {
        return this.destroy(err);
      }

      this._chunk = null;

      this._debug('sent chunk from "write before connect"');

      const cb = this._cb;
      this._cb = null;
      cb(null);
    } // Backpressure is not implemented in Node.js. The `ws` module has a buggy
    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492


    if (typeof ws !== 'function') {
      this._interval = setInterval(() => this._onInterval(), 150);
      if (this._interval.unref) this._interval.unref();
    }

    this._debug('connect');

    this.emit('connect');
  }

  _handleMessage(event) {
    if (this.destroyed) return;
    let data = event.data;
    if (data instanceof ArrayBuffer) data = Buffer.from(data);
    this.push(data);
  }

  _handleClose() {
    if (this.destroyed) return;

    this._debug('on close');

    this.destroy();
  }

  _handleError(_) {
    this.destroy(new Error(`Error connecting to ${this.url}`));
  } // When stream finishes writing, close socket. Half open connections are not
  // supported.


  _handleFinish() {
    if (this.destroyed) return; // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?

    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000);
    };

    if (this.connected) {
      destroySoon();
    } else {
      this.once('connect', destroySoon);
    }
  }

  _onInterval() {
    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }

    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount);

    const cb = this._cb;
    this._cb = null;
    cb(null);
  }

  _debug() {
    const args = [].slice.call(arguments);
    args[0] = '[' + this._id + '] ' + args[0];
    debug.apply(null, args);
  }

}

Socket.WEBSOCKET_SUPPORT = !!_WebSocket;
module.exports = Socket;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"debug":131,"queue-microtask":412,"randombytes":427,"readable-stream":505,"ws":48}],491:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],492:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":494,"./_stream_writable":496,"_process":380,"dup":77,"inherits":279}],493:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":495,"dup":78,"inherits":279}],494:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":491,"./_stream_duplex":492,"./internal/streams/async_iterator":497,"./internal/streams/buffer_list":498,"./internal/streams/destroy":499,"./internal/streams/from":501,"./internal/streams/state":503,"./internal/streams/stream":504,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],495:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":491,"./_stream_duplex":492,"dup":80,"inherits":279}],496:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":491,"./_stream_duplex":492,"./internal/streams/destroy":499,"./internal/streams/state":503,"./internal/streams/stream":504,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],497:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":500,"_process":380,"dup":82}],498:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],499:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],500:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":491,"dup":85}],501:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],502:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":491,"./end-of-stream":500,"dup":87}],503:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":491,"dup":88}],504:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],505:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":492,"./lib/_stream_passthrough.js":493,"./lib/_stream_readable.js":494,"./lib/_stream_transform.js":495,"./lib/_stream_writable.js":496,"./lib/internal/streams/end-of-stream.js":500,"./lib/internal/streams/pipeline.js":502,"dup":90}],506:[function(require,module,exports){
const siphash24 = require('siphash24');

module.exports = function (out, data, key) {
  siphash24(data, key, out);
};

},{"siphash24":508}],507:[function(require,module,exports){
module.exports = fallback;

function _add(a, b) {
  var rl = a.l + b.l;
  var a2 = {
    h: a.h + b.h + (rl / 2 >>> 31) >>> 0,
    l: rl >>> 0
  };
  a.h = a2.h;
  a.l = a2.l;
}

function _xor(a, b) {
  a.h ^= b.h;
  a.h >>>= 0;
  a.l ^= b.l;
  a.l >>>= 0;
}

function _rotl(a, n) {
  var a2 = {
    h: a.h << n | a.l >>> 32 - n,
    l: a.l << n | a.h >>> 32 - n
  };
  a.h = a2.h;
  a.l = a2.l;
}

function _rotl32(a) {
  var al = a.l;
  a.l = a.h;
  a.h = al;
}

function _compress(v0, v1, v2, v3) {
  _add(v0, v1);

  _add(v2, v3);

  _rotl(v1, 13);

  _rotl(v3, 16);

  _xor(v1, v0);

  _xor(v3, v2);

  _rotl32(v0);

  _add(v2, v1);

  _add(v0, v3);

  _rotl(v1, 17);

  _rotl(v3, 21);

  _xor(v1, v2);

  _xor(v3, v0);

  _rotl32(v2);
}

function _get_int(a, offset) {
  return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];
}

function fallback(out, m, key) {
  // modified from https://github.com/jedisct1/siphash-js to use uint8arrays
  var k0 = {
    h: _get_int(key, 4),
    l: _get_int(key, 0)
  };
  var k1 = {
    h: _get_int(key, 12),
    l: _get_int(key, 8)
  };
  var v0 = {
    h: k0.h,
    l: k0.l
  };
  var v2 = k0;
  var v1 = {
    h: k1.h,
    l: k1.l
  };
  var v3 = k1;
  var mi;
  var mp = 0;
  var ml = m.length;
  var ml7 = ml - 7;
  var buf = new Uint8Array(new ArrayBuffer(8));

  _xor(v0, {
    h: 0x736f6d65,
    l: 0x70736575
  });

  _xor(v1, {
    h: 0x646f7261,
    l: 0x6e646f6d
  });

  _xor(v2, {
    h: 0x6c796765,
    l: 0x6e657261
  });

  _xor(v3, {
    h: 0x74656462,
    l: 0x79746573
  });

  while (mp < ml7) {
    mi = {
      h: _get_int(m, mp + 4),
      l: _get_int(m, mp)
    };

    _xor(v3, mi);

    _compress(v0, v1, v2, v3);

    _compress(v0, v1, v2, v3);

    _xor(v0, mi);

    mp += 8;
  }

  buf[7] = ml;
  var ic = 0;

  while (mp < ml) {
    buf[ic++] = m[mp++];
  }

  while (ic < 7) {
    buf[ic++] = 0;
  }

  mi = {
    h: buf[7] << 24 | buf[6] << 16 | buf[5] << 8 | buf[4],
    l: buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0]
  };

  _xor(v3, mi);

  _compress(v0, v1, v2, v3);

  _compress(v0, v1, v2, v3);

  _xor(v0, mi);

  _xor(v2, {
    h: 0,
    l: 0xff
  });

  _compress(v0, v1, v2, v3);

  _compress(v0, v1, v2, v3);

  _compress(v0, v1, v2, v3);

  _compress(v0, v1, v2, v3);

  var h = v0;

  _xor(h, v1);

  _xor(h, v2);

  _xor(h, v3);

  out[0] = h.l & 0xff;
  out[1] = h.l >> 8 & 0xff;
  out[2] = h.l >> 16 & 0xff;
  out[3] = h.l >> 24 & 0xff;
  out[4] = h.h & 0xff;
  out[5] = h.h >> 8 & 0xff;
  out[6] = h.h >> 16 & 0xff;
  out[7] = h.h >> 24 & 0xff;
}

},{}],508:[function(require,module,exports){
var wasm = require("./siphash24");

var fallback = require("./fallback");

var assert = require('nanoassert');

module.exports = siphash24;
var BYTES = siphash24.BYTES = 8;
var KEYBYTES = siphash24.KEYBYTES = 16;
var mod = wasm();
siphash24.WASM_SUPPORTED = typeof WebAssembly !== 'undefined';
siphash24.WASM_LOADED = false;

if (mod) {
  mod.onload(function (err) {
    siphash24.WASM_LOADED = !err;
  });
}

function siphash24(data, key, out, noAssert) {
  if (!out) out = new Uint8Array(8);

  if (noAssert !== true) {
    assert(out.length >= BYTES, 'output must be at least ' + BYTES);
    assert(key.length >= KEYBYTES, 'key must be at least ' + KEYBYTES);
  }

  if (mod && mod.exports) {
    if (data.length + 24 > mod.memory.length) mod.realloc(data.length + 24);
    mod.memory.set(key, 8);
    mod.memory.set(data, 24);
    mod.exports.siphash(24, data.length);
    out.set(mod.memory.subarray(0, 8));
  } else {
    fallback(out, data, key);
  }

  return out;
}

},{"./fallback":507,"./siphash24":509,"nanoassert":319}],509:[function(require,module,exports){
module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs=');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new (require('buf' + 'fer').Buffer)(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

},{}],510:[function(require,module,exports){
module.exports = {
  SocketSignalWebsocketClient: require("./lib/client")
};

},{"./lib/client":511}],511:[function(require,module,exports){
const Socket = require('simple-websocket');

const assert = require('nanocustomassert');

const WebSocket = require('isomorphic-ws');

const delay = require('delay');

const {
  SocketSignalClient
} = require('socket-signal');

const log = require('debug')('socket-signal:websocket-client'); // round robin url provider


const defaultUrlProvider = urls => {
  let urlIndex = 0;
  return () => {
    const url = urls[urlIndex++ % urls.length];
    log('url provider', url);
    return url;
  };
};

let ReconnectingWebSocket = require('reconnecting-websocket');

if (ReconnectingWebSocket.default) {
  ReconnectingWebSocket = ReconnectingWebSocket.default;
}

class SocketSignalWebsocketClient extends SocketSignalClient {
  static createSocket(urlProvider, opts = {}) {
    assert(Array.isArray(urlProvider) || typeof urlProvider === 'function', 'must be an array or a function');
    const {
      simpleWebsocket = {},
      reconnectingWebsocket = {}
    } = opts;

    if (Array.isArray(urlProvider)) {
      urlProvider = defaultUrlProvider(urlProvider);
    }

    if (!reconnectingWebsocket.WebSocket) {
      reconnectingWebsocket.WebSocket = WebSocket;
    }

    const ws = new ReconnectingWebSocket(urlProvider, reconnectingWebsocket.protocols, reconnectingWebsocket);
    const socket = new Socket({
      socket: ws,
      ...simpleWebsocket
    });
    const _onopen = ws.onopen;
    const _onclose = ws.onclose;
    const _onerror = ws.onerror;

    ws.onopen = ev => {
      if (socket._chunk && !socket._cb) {
        socket._cb = () => {};
      }

      _onopen(ev);
    };

    ws.onclose = ev => {
      log('socket close', {
        shouldReconnect: ws._shouldReconnect,
        ev
      });

      if (ws._shouldReconnect) {
        socket.connected = false;
      } else {
        _onclose(ev);
      }
    };

    ws.onerror = ev => {
      log('socket error', {
        shouldReconnect: ws._shouldReconnect,
        ev
      });

      if (ws._shouldReconnect) {
        socket.connected = false;
      } else {
        _onerror(ev);
      }
    };

    return {
      ws,
      socket
    };
  }

  constructor(urlProvider, opts = {}) {
    const {
      heartbeat = false,
      simpleWebsocket,
      reconnectingWebsocket,
      onSocket = socket => socket,
      ...socketSignalOpts
    } = opts;
    const {
      ws,
      socket
    } = SocketSignalWebsocketClient.createSocket(urlProvider, {
      simpleWebsocket,
      reconnectingWebsocket
    });
    super(onSocket(socket), socketSignalOpts);
    this._ws = ws;
    this._heartbeat = heartbeat;
    this._lastPing = 0;
    let reconnected = false;
    this.socket.on('connect', () => {
      this.emit('connected', reconnected);
      reconnected = true;
    });
  }

  get connected() {
    return this._ws.readyState === this._ws.OPEN;
  }

  get lastPing() {
    return this._lastPing;
  }

  async _open() {
    this._heartbeat && this._startHeartbeat(this._heartbeat);
    return super._open();
  }

  async _startHeartbeat(opts = {}) {
    const {
      interval = 10 * 1000,
      timeout = 5 * 1000
    } = typeof opts === 'boolean' ? {} : opts;

    while (!(this.closed || this.closing)) {
      await delay(interval);

      if (this.connected && this.opened) {
        const data = await this.rpc.call('__ping__', {
          time: Date.now()
        }, {
          timeout
        }).catch(err => {
          this.emit('ping-error', err);
          if (this.closed || this.closing) return;
          if (err.code === 'NMSG_ERR_TIMEOUT') return this._ws.reconnect();
        });

        if (data) {
          this.emit('ping', data.time);
          this._lastPing = data.time;
        }
      }
    }
  }

}

module.exports = SocketSignalWebsocketClient;

},{"debug":131,"delay":512,"isomorphic-ws":287,"nanocustomassert":320,"reconnecting-websocket":441,"simple-websocket":490,"socket-signal":513}],512:[function(require,module,exports){
'use strict'; // From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15

const randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);

const createAbortError = () => {
  const error = new Error('Delay aborted');
  error.name = 'AbortError';
  return error;
};

const createDelay = ({
  clearTimeout: defaultClear,
  setTimeout: set,
  willResolve
}) => (ms, {
  value,
  signal
} = {}) => {
  if (signal && signal.aborted) {
    return Promise.reject(createAbortError());
  }

  let timeoutId;
  let settle;
  let rejectFn;
  const clear = defaultClear || clearTimeout;

  const signalListener = () => {
    clear(timeoutId);
    rejectFn(createAbortError());
  };

  const cleanup = () => {
    if (signal) {
      signal.removeEventListener('abort', signalListener);
    }
  };

  const delayPromise = new Promise((resolve, reject) => {
    settle = () => {
      cleanup();

      if (willResolve) {
        resolve(value);
      } else {
        reject(value);
      }
    };

    rejectFn = reject;
    timeoutId = (set || setTimeout)(settle, ms);
  });

  if (signal) {
    signal.addEventListener('abort', signalListener, {
      once: true
    });
  }

  delayPromise.clear = () => {
    clear(timeoutId);
    timeoutId = null;
    settle();
  };

  return delayPromise;
};

const createWithTimers = clearAndSet => {
  const delay = createDelay({ ...clearAndSet,
    willResolve: true
  });
  delay.reject = createDelay({ ...clearAndSet,
    willResolve: false
  });

  delay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);

  return delay;
};

const delay = createWithTimers();
delay.createWithTimers = createWithTimers;
module.exports = delay; // TODO: Remove this for the next major release

module.exports.default = delay;

},{}],513:[function(require,module,exports){
module.exports = {
  SocketSignalClient: require("./lib/client"),
  SocketSignalServer: require("./lib/server"),
  SocketSignalServerMap: require("./lib/server-map"),
  Peer: require("./lib/peer"),
  SignalBatch: require("./lib/signal-batch"),
  errors: require("./lib/errors")
};

},{"./lib/client":514,"./lib/errors":515,"./lib/peer":516,"./lib/server":518,"./lib/server-map":517,"./lib/signal-batch":519}],514:[function(require,module,exports){
(function (Buffer,process){(function (){
const crypto = require('crypto');

const assert = require('nanocustomassert');

const fastq = require('fastq');

const pEvent = require('p-event');

const nanomessagerpc = require('nanomessage-rpc');

const {
  NanoresourcePromise
} = require('nanoresource-promise/emitter');

const Peer = require("./peer");

const kConnectionsQueue = Symbol('socketsignal.connectionsqueue');
const kPeers = Symbol('socketsignal.peers');
const kDefineActions = Symbol('socketsignal.defineactions');
const kDefineEvents = Symbol('socketsignal.defineevents');
const kAddPeer = Symbol('socketsignal.addpeer');
const kCreatePeer = Symbol('socketsignal.createpeer');
const kOnSignal = Symbol('socketsignal.onsignal');

function worker({
  peer,
  data
}, done) {
  this.open().then(() => {
    this.emit('peer-connecting', peer);
    return peer.open(data);
  }).then(() => done()).catch(err => done(err));
}

class SocketSignalClient extends NanoresourcePromise {
  /**
   * @constructor
   * @param {DuplexStream} socket
   * @param {Object} opts
   * @param {Buffer} opts.id Id of 32 bytes
   * @param {number} opts.requestTimeout How long to wait for peer requests
   * @param {number} opts.queueConcurrency How many incoming connections in concurrent can handle
   * @param {Object} opts.metadata Metadata to share across network
   * @param {Object} opts.simplePeer SimplePeer options
   */
  constructor(socket, opts = {}) {
    super();
    const {
      id = crypto.randomBytes(32),
      requestTimeout = 15 * 1000,
      queueConcurrency = 4,
      simplePeer = {},
      metadata
    } = opts;
    assert(!metadata || typeof metadata === 'object', 'metadata must be an object');
    this.socket = socket;
    this.rpc = nanomessagerpc({
      timeout: requestTimeout,
      ...nanomessagerpc.useSocket(socket)
    });
    this.id = id;
    this.metadata = metadata;
    this.simplePeer = simplePeer;
    this.requestTimeout = requestTimeout;
    this[kPeers] = new Map();
    this[kConnectionsQueue] = fastq(this, worker, queueConcurrency); // rpc

    this[kDefineActions]();
    this[kDefineEvents]();
  }
  /**
   * Peers
   *
   * @type {Array<Peer>}
   */


  get peers() {
    return Array.from(this[kPeers].values());
  }
  /**
   * Peers connected
   *
   * @type {Array<Peer>}
   */


  get peersConnected() {
    return this.peers.filter(p => p.connected);
  }
  /**
   * Peers incoming and connecting
   *
   * @type {Array<Peer>}
   */


  get peersConnecting() {
    return this.peers.filter(p => !p.connected);
  }
  /**
   * Get peers by the topic
   *
   * @param {Buffer} topic
   * @returns {Array<Peer>}
   */


  getPeersByTopic(topic) {
    assert(Buffer.isBuffer(topic), 'topic is required');
    return this.peers.filter(peer => peer.topic.equals(topic));
  }
  /**
   * Join to the network by a topic
   *
   * @param {Buffer} topic
   * @returns {Promise<Array<Peer>>}
   */


  async join(topic) {
    assert(Buffer.isBuffer(topic) && topic.length === 32, 'topic must be a Buffer of 32 bytes');
    await this.open();
    const peers = await this.rpc.call('join', this._buildMessage({
      topic
    }));
    this.emit('join', topic, peers);
    return peers;
  }
  /**
   * Leave a topic from the network
   *
   * IMPORTANT: This will not close the current peers for that topic
   * you should call closeConnectionsByTopic(topic)
   *
   * @param {Buffer} topic
   * @returns {Promise}
   */


  async leave(topic) {
    assert(!topic || Buffer.isBuffer(topic) && topic.length === 32, 'topic must be a Buffer of 32 bytes');
    await this.open();
    await this.rpc.call('leave', this._buildMessage({
      topic
    }));
    this.emit('leave', topic);
  }
  /**
   * Calls a new lookup from the network
   *
   * @param {Buffer} topic
   * @returns {Promise<Array<Peer>>}
   */


  async lookup(topic) {
    assert(Buffer.isBuffer(topic) && topic.length === 32, 'topic must be a Buffer of 32 bytes');
    await this.open();
    const peers = await this.rpc.call('lookup', this._buildMessage({
      topic
    }));
    this.emit('lookup', topic, peers);
    return peers;
  }
  /**
   * Connects to a peer by their id and topic
   *
   * IMPORTANT: This will not returns a connected peer
   * you should wait for the connection by peer.ready()
   *
   * @param {Buffer} topic
   * @param {Buffer} peerId
   * @param {(Object|undefined)} opts
   * @param {Object} opts.metadata
   * @param {Object} opts.simplePeer
   * @returns {Peer}
   */


  connect(topic, peerId, opts = {}) {
    assert(Buffer.isBuffer(topic) && topic.length === 32, 'topic must be a Buffer of 32 bytes');
    assert(Buffer.isBuffer(peerId) && peerId.length === 32, 'peerId must be a Buffer of 32 bytes');
    const {
      metadata: localMetadata,
      simplePeer = {}
    } = opts;
    const peer = this[kCreatePeer]({
      initiator: true,
      sessionId: crypto.randomBytes(32),
      id: peerId,
      topic,
      localMetadata,
      simplePeer
    });
    this[kAddPeer](peer);
    return peer;
  }
  /**
   * Async handler for incoming peers, peers that you don't get it from .connect(id, topic)
   *
   * This is the right place to define rules to accept or reject connections.
   *
   * @param {(peer: Peer) => (Promise|Error)} handler
   */


  onIncomingPeer(handler) {
    this._onIncomingPeer = handler;
    return this;
  }
  /**
   * Async handler for incoming offer.
   *
   * @param {(data: { id, topic, metadata }) => (Promise|Error)} handler
   */


  onOffer(handler) {
    this._onOffer = handler;
    return this;
  }
  /**
   * Async handler for incoming answer.
   *
   * @param {(data: { id, topic, metadata }) => (Promise|Error)} handler
   */


  onAnswer(handler) {
    this._onAnswer = handler;
    return this;
  }
  /**
   * Close connections by topic
   *
   * @param {Buffer} topic
   * @returns {Promise}
   */


  closeConnectionsByTopic(topic) {
    return Promise.all(this.getPeersByTopic(topic).map(peer => new Promise(resolve => peer.close(() => resolve()))));
  }
  /**
   * @abstract
   */


  async _onIncomingPeer() {}
  /**
   * @abstract
   */


  async _onOffer(data) {}
  /**
   * @abstract
   */


  async _onAnswer(data) {}

  async _open() {
    await this.rpc.open();
  }

  async _close() {
    this[kConnectionsQueue].kill();
    await this.rpc.close();
    await Promise.all(this.peers.map(peer => new Promise(resolve => peer.close(() => resolve()))));
  }

  _buildMessage(data) {
    const {
      localMetadata = {},
      ...msg
    } = data;
    let metadata = this.metadata || {};

    if (localMetadata) {
      metadata = { ...metadata,
        ...localMetadata
      };
    }

    return { ...msg,
      id: this.id,
      metadata
    };
  }
  /**
   * @private
   */


  [kDefineActions]() {
    this.rpc.actions({
      offer: async message => {
        const result = await this._onOffer(message);
        assert(!result || typeof result === 'object');
        const peer = this[kCreatePeer]({
          initiator: false,
          sessionId: message.sessionId,
          id: message.id,
          topic: message.topic,
          metadata: message.metadata,
          localMetadata: result && result.metadata,
          simplePeer: result && result.simplePeer
        });
        this[kAddPeer](peer, message.data);
        return pEvent(peer, 'answer', {
          rejectionEvents: ['error', 'closed']
        });
      }
    });
  }
  /**
   * @private
   */


  [kDefineEvents]() {
    this.rpc.on('signal', message => {
      const {
        sessionId,
        data = []
      } = message;
      const peer = this[kPeers].get(sessionId.toString('hex'));
      if (!peer || peer.destroyed) return;
      data.forEach(signal => peer.stream.signal(signal));
    });
  }
  /**
   * @private
   */


  [kAddPeer](peer, data) {
    const sessionId = peer.sessionId.toString('hex');
    this[kPeers].set(sessionId, peer);
    peer.once('close', () => {
      this[kPeers].delete(sessionId);
    });
    peer.once('error', err => {
      this.emit('peer-error', err, peer);
    });
    this[kConnectionsQueue].push({
      peer,
      data
    }, err => {
      if (err || this.closing || this.closed) return process.nextTick(() => peer.destroy(err));
      this.emit('peer-connected', peer);
    }); // peer queue

    this.emit('peer-queue', peer);
  }
  /**
   * @private
   */


  [kCreatePeer](opts) {
    opts = Object.assign({}, opts, {
      onSignal: (peer, batch) => this[kOnSignal](peer, batch),
      simplePeer: Object.assign({}, this.simplePeer, opts.simplePeer),
      timeout: this.requestTimeout
    });
    let peer;

    if (typeof this.simplePeer === 'function') {
      peer = this.simplePeer(Peer, opts);
    }

    peer = new Peer(opts);
    return peer;
  }
  /**
   * @private
   */


  async [kOnSignal](peer, batch) {
    if (peer.destroyed || peer.connected && !peer.subscribeMediaStream) return;

    const payload = () => this._buildMessage({
      remoteId: peer.id,
      topic: peer.topic,
      sessionId: peer.sessionId,
      data: batch,
      localMetadata: peer.localMetadata
    });

    if (!peer.connected) {
      const type = batch[0].type;

      if (type === 'offer') {
        const response = await this.rpc.call('offer', payload());
        await this._onAnswer(response);
        response.data.forEach(signal => peer.stream.signal(signal));
        peer.metadata = response.metadata;
        return;
      }

      if (type === 'answer') {
        await this._onIncomingPeer(peer);
        return peer.emit('answer', payload());
      }
    }

    await this.rpc.emit('signal', payload());
  }

}

module.exports = SocketSignalClient;

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")},require('_process'))
},{"../../is-buffer/index.js":282,"./peer":516,"_process":380,"crypto":128,"fastq":177,"nanocustomassert":320,"nanomessage-rpc":325,"nanoresource-promise/emitter":520,"p-event":360}],515:[function(require,module,exports){
const nanoerror = require('nanoerror');

function createError(code, message) {
  exports[code] = nanoerror(code, message);
}

createError('ERR_ARGUMENT_INVALID', '%s');
createError('ERR_PEER_NOT_FOUND', 'peer not found: %s');
createError('ERR_CONNECTION_CLOSED');
createError('ERR_SIGNAL_TIMEOUT', 'Timeout trying to establish a connection. SIGNALS: %j');

},{"nanoerror":321}],516:[function(require,module,exports){
(function (Buffer,process){(function (){
const {
  NanoresourcePromise
} = require('nanoresource-promise/emitter');

const SimplePeer = require('simple-peer');

const assert = require('nanocustomassert');

const pEvent = require('p-event');

const eos = require('end-of-stream');

const SignalBatch = require("./signal-batch");

const {
  ERR_CONNECTION_CLOSED,
  ERR_SIGNAL_TIMEOUT
} = require("./errors");

const kMetadata = Symbol('peer.metadata');
const kLocalMetadata = Symbol('peer.localmetadata');
const kOnSignal = Symbol('peer.onsignal');
const kOffer = Symbol('peer.offer');
module.exports = class Peer extends NanoresourcePromise {
  constructor(opts = {}) {
    super();
    const {
      onSignal,
      initiator,
      sessionId,
      id,
      topic,
      metadata,
      localMetadata,
      simplePeer = {},
      timeout
    } = opts;
    assert(onSignal);
    assert(initiator !== undefined, 'initiator is required');
    assert(Buffer.isBuffer(sessionId) && sessionId.length === 32, 'sessionId is required and must be a buffer of 32');
    assert(Buffer.isBuffer(id) && id.length === 32, 'id is required and must be a buffer of 32');
    assert(Buffer.isBuffer(topic) && topic.length === 32, 'topic must be a buffer of 32');
    assert(!metadata || typeof metadata === 'object', 'metadata must be an object');
    assert(!localMetadata || typeof localMetadata === 'object', 'localMetadata must be an object');
    this.initiator = initiator;
    this.sessionId = sessionId;
    this.id = id;
    this.topic = topic;
    this.simplePeerOptions = simplePeer;
    this.timeout = timeout;
    this.subscribeMediaStream = false;
    this.error = null;
    this.signals = [];
    this[kOnSignal] = onSignal;
    this[kOffer] = null;
    this[kMetadata] = metadata;
    this[kLocalMetadata] = localMetadata;
    this.once('error', err => {
      this.error = err;
    });

    this._initializeSimplePeer();
  }

  get connected() {
    return this.stream.connected;
  }

  get destroyed() {
    return this.stream.destroyed;
  }

  get metadata() {
    return this[kMetadata];
  }

  set metadata(metadata) {
    assert(!metadata || typeof metadata === 'object', 'metadata must be an object');
    this[kMetadata] = metadata;
    this.emit('metadata-updated', this[kMetadata]);
    return this[kMetadata];
  }

  get localMetadata() {
    return this[kLocalMetadata];
  }

  set localMetadata(metadata) {
    assert(!metadata || typeof metadata === 'object', 'localMetadata must be an object');
    this[kLocalMetadata] = metadata;
    this.emit('local-metadata-updated', this[kLocalMetadata]);
    return this[kLocalMetadata];
  }

  async ready() {
    if (this.connected) return;

    if (this.destroyed) {
      if (this.error) throw this.error;
      throw new ERR_CONNECTION_CLOSED();
    }

    return pEvent(this, 'connect', {
      rejectionEvents: ['error', 'close']
    });
  }

  addStream(mediaStream) {
    return this.ready().then(() => this.stream.addStream(mediaStream));
  }

  removeStream(mediaStream) {
    return this.ready().then(() => this.stream.removeStream(mediaStream));
  }

  destroy(err) {
    this.stream.destroy(err);
  }

  open(offer) {
    if (offer) this[kOffer] = offer;
    return super.open();
  }

  async _open() {
    const timeout = setTimeout(() => {
      this.destroy(new ERR_SIGNAL_TIMEOUT(this.signals));
    }, this.timeout);
    const signalBatch = new SignalBatch();
    const ready = this.ready();

    const onSignal = signal => signalBatch.add(signal);

    const clean = () => this.stream.removeListener('signal', onSignal);

    this.once('close', () => clean());
    signalBatch.onSignal(batch => {
      this.signals = [...this.signals, ...batch];
      return this[kOnSignal](this, batch);
    }).onClose(err => {
      clean();
      if (err) process.nextTick(() => this.destroy(err));
    }).resolution(() => this.destroyed);
    this.stream.on('signal', onSignal);

    if (!this.initiator && this[kOffer]) {
      this[kOffer].forEach(signal => this.stream.signal(signal));
    }

    return ready.finally(() => {
      clearTimeout(timeout);
    });
  }

  _close() {
    if (this.destroyed) return;
    process.nextTick(() => this.stream.destroy());
    return new Promise(resolve => eos(this.stream, () => resolve()));
  }

  _initializeSimplePeer() {
    const {
      streams = [],
      ...opts
    } = this.simplePeerOptions;
    this.stream = new SimplePeer({ ...opts,
      initiator: this.initiator
    });
    streams.forEach(stream => this.addStream(stream).catch(() => {})); // close stream support

    this.stream.close = () => process.nextTick(() => this.stream.destroy());

    const onStream = eventStream => this.emit('stream', eventStream);

    const onSignal = signal => this.emit('signal', signal);

    const onError = err => this.emit('error', err);

    const onConnect = () => this.emit('connect');

    const onClose = () => {
      this.stream.removeListener('stream', onStream);
      this.stream.removeListener('signal', onSignal);
      this.stream.removeListener('error', onError);
      this.stream.removeListener('connect', onConnect);
      this.close().catch(() => {});
      this.emit('close');
    };

    this.stream.on('stream', onStream);
    this.stream.on('signal', onSignal);
    this.stream.once('error', onError);
    this.stream.once('connect', onConnect);
    this.stream.once('close', onClose);
  }

};

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")},require('_process'))
},{"../../is-buffer/index.js":282,"./errors":515,"./signal-batch":519,"_process":380,"end-of-stream":168,"nanocustomassert":320,"nanoresource-promise/emitter":520,"p-event":360,"simple-peer":474}],517:[function(require,module,exports){
const SocketSignalServer = require("./server");

const {
  ERR_PEER_NOT_FOUND
} = require("./errors");

const log = require('debug')('socket-signal:server-map');

class SocketSignalServerMap extends SocketSignalServer {
  constructor(opts = {}) {
    super(opts);
    this._peersByTopic = new Map();
  }

  addPeer(rpc, id, topic) {
    const topicStr = topic.toString('hex');
    const idStr = id.toString('hex');
    const peers = this._peersByTopic.get(topicStr) || new Map();
    peers.set(idStr, {
      rpc,
      id
    });

    this._peersByTopic.set(topicStr, peers);
  }

  deletePeer(id, topic) {
    const idStr = id.toString('hex');

    if (!topic) {
      this._peersByTopic.forEach((peers, topic) => {
        if (peers.delete(idStr)) {
          log('peer-leave', idStr + ' from ' + topic);
        }
      });

      return;
    }

    const topicStr = topic.toString('hex');

    if (this._peersByTopic.has(topicStr) && this._peersByTopic.get(topicStr).delete(idStr)) {
      log('peer-leave', idStr + ' from ' + topicStr);
    }
  }

  getPeers(topic) {
    const topicStr = topic.toString('hex');
    if (!this._peersByTopic.has(topicStr)) return [];
    return Array.from(this._peersByTopic.get(topicStr).values()).map(peer => peer.id);
  }

  findPeer(id, topic) {
    const idStr = id.toString('hex');

    const peers = this._peersByTopic.get(topic.toString('hex'));

    if (!peers || !peers.has(idStr)) {
      throw new ERR_PEER_NOT_FOUND(idStr);
    }

    return peers.get(idStr);
  }

  async _onDisconnect(rpc) {
    let id;

    this._peersByTopic.forEach(peers => {
      for (const [key, peer] of peers) {
        if (peer.rpc === rpc) {
          id = peer.id;
          peers.delete(key);
          break;
        }
      }
    });

    if (id) {
      log('peer-disconnected', id.toString('hex'));
    }
  }

  async _onJoin(rpc, data) {
    this.addPeer(rpc, data.id, data.topic);
    log('peer-join', data.id.toString('hex') + ' in ' + data.topic.toString('hex'));
    return this.getPeers(data.topic);
  }

  async _onLeave(rpc, data) {
    this.deletePeer(data.id, data.topic);
  }

  async _onOffer(rpc, data) {
    const remotePeer = this.findPeer(data.remoteId, data.topic);
    log(`peer-offer ${data.id.toString('hex')} -> ${data.remoteId.toString('hex')}`);
    return remotePeer.rpc.call('offer', data);
  }

  async _onLookup(rpc, data) {
    return this.getPeers(data.topic);
  }

  async _onSignal(rpc, data) {
    const remotePeer = this.findPeer(data.remoteId, data.topic);
    log(`peer-signal ${data.id.toString('hex')} -> ${data.remoteId.toString('hex')}`);
    remotePeer.rpc.emit('signal', data).catch(() => {});
  }

}

module.exports = SocketSignalServerMap;

},{"./errors":515,"./server":518,"debug":131}],518:[function(require,module,exports){
/**
 * @typedef {object} Data
 * @property {Buffer} id
 * @property {Buffer} topic
 * @property {Object} metadata
*/

/**
 * @typedef {object} SignalData
 * @extends Data
 * @property {Buffer} remoteId
 * @property {Buffer} sessionId
 * @property {Array<Object>} data
*/
const crypto = require('crypto');

const nanomessagerpc = require('nanomessage-rpc');

const {
  NanoresourcePromise
} = require('nanoresource-promise/emitter');

const log = require('debug')('socketsignal:server');

const kDefineActions = Symbol('socketsignal.defineactions');
const kDefineEvents = Symbol('socketsignal.defineevents');

class SocketSignalServer extends NanoresourcePromise {
  constructor(opts = {}) {
    super();
    const {
      onConnect,
      onDisconnect,
      onJoin,
      onLeave,
      onLookup,
      onOffer,
      onSignal,
      requestTimeout = 10 * 1000,
      ...rpcOpts
    } = opts;
    if (onConnect) this._onConnect = onConnect;
    if (onDisconnect) this._onDisconnect = onDisconnect;
    if (onJoin) this._onJoin = onJoin;
    if (onLeave) this._onLeave = onLeave;
    if (onLookup) this._onLookup = onLookup;
    if (onOffer) this._onOffer = onOffer;
    if (onSignal) this._onSignal = onSignal;
    this._requestTimeout = requestTimeout;
    this._rpcOpts = rpcOpts;
    this.connections = new Set();
  }
  /**
   * Adds a duplex stream socket
   *
   * @param {DuplexStream} socket
   * @returns {NanomessageRPC}
   */


  async addSocket(socket) {
    await this.open();
    const rpc = nanomessagerpc({
      timeout: this._requestTimeout,
      ...this._rpcOpts,
      ...nanomessagerpc.useSocket(socket)
    });
    this[kDefineActions](rpc);
    this[kDefineEvents](rpc);
    rpc.id = crypto.randomBytes(32);
    rpc.socket = socket;

    const deleteConnection = () => {
      if (this.connections.delete(rpc)) {
        log('connection-deleted', rpc.id.toString('hex'));
        return this._onDisconnect(rpc);
      }
    };

    rpc.ee.on('closed', deleteConnection);
    rpc.ee.on('error', err => this.emit('connection-error', err, rpc));
    await rpc.open();

    try {
      log('connection-added', rpc.id.toString('hex'));
      await this._onConnect(rpc);
      this.connections.add(rpc);
    } catch (err) {
      rpc.closed().then(deleteConnection).catch(deleteConnection).finally(() => {
        this.emit('connection-error', err, rpc);
      });
    }

    return rpc;
  }
  /**
   * Defines a behaviour when the nanoresource is opening.
   *
   * @returns {Promise}
   */


  async _open() {}
  /**
   * Defines a behaviour when the nanoresource is closing.
   *
   * @returns {Promise}
   */


  async _close() {
    await Promise.all(Array.from(this.connections.values()).map(c => c.close()));
  }
  /**
   * Event connect
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   */


  async _onConnect() {}
  /**
   * Event disconnect
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   */


  async _onDisconnect() {}
  /**
   * Action join
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   * @param {Data} data
   * @returns {Promise<Array<Buffer>>}
   */


  async _onJoin() {}
  /**
   * Action leave
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   * @param {Data} data
   * @returns {Promise}
   */


  async _onLeave() {}
  /**
   * Action lookup
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   * @param {Data} data
   * @returns {Promise<Array<Buffer>>}
   */


  async _onLookup() {}
  /**
   * Action offer
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   * @param {SignalData} data
   * @returns {Promise<SignalData>}
   */


  async _onOffer() {}
  /**
   * Event signal
   *
   * @abstract
   * @param {NanomessageRPC} rpc
   * @param {SignalData} data
   */


  async _onSignal() {}
  /**
   * @private
   */


  [kDefineActions](rpc) {
    rpc.actions({
      join: (data = {}) => {
        return this._onJoin(rpc, data);
      },
      leave: (data = {}) => {
        return this._onLeave(rpc, data);
      },
      offer: (data = {}) => {
        return this._onOffer(rpc, data);
      },
      lookup: (data = {}) => {
        return this._onLookup(rpc, data);
      }
    });
  }
  /**
   * @private
   */


  [kDefineEvents](rpc) {
    rpc.on('signal', async (data = {}) => {
      try {
        await this._onSignal(rpc, data);
      } catch (err) {
        log('signal error', err);
      }
    });
  }

}

module.exports = SocketSignalServer;

},{"crypto":128,"debug":131,"nanomessage-rpc":325,"nanoresource-promise/emitter":520}],519:[function(require,module,exports){
const pLimit = require('p-limit');

class SignalBatch {
  constructor() {
    this._limit = pLimit(1);
    this._cache = [];
  }

  onSignal(cb) {
    this._onSignal = (peer, type, batch) => cb && cb(peer, type, batch);

    return this;
  }

  onClose(cb) {
    this._onClose = err => cb && cb(err);

    return this;
  }

  resolution(cb) {
    this._resolution = () => cb && cb();
  }

  add(signal) {
    this._cache.push(signal);

    this._limit(async () => {
      this._limit.clearQueue();

      if (this._cache.length === 0 || this._resolution()) return;
      let prev;
      let ms = 300;

      do {
        prev = this._cache.length;
        await new Promise(resolve => setTimeout(resolve, ms));
        ms = 1;
      } while (prev < this._cache.length && this._cache.length < 4);

      const batch = this._cache;
      this._cache = [];
      return this._onSignal(batch);
    }).catch(err => {
      this._limit.clearQueue();

      this._onClose(err);
    }).finally(() => {
      if (this._resolution()) {
        this._limit.clearQueue();

        this._onClose();
      }
    });
  }

}

module.exports = SignalBatch;

},{"p-limit":523}],520:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{".":521,"dup":333,"events":172}],521:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"./nanoresource-cb":522,"dup":326}],522:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"_process":380,"dup":327}],523:[function(require,module,exports){
'use strict';

const Queue = require('yocto-queue');

const pLimit = concurrency => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    throw new TypeError('Expected `concurrency` to be a number from 1 and up');
  }

  const queue = new Queue();
  let activeCount = 0;

  const next = () => {
    activeCount--;

    if (queue.size > 0) {
      queue.dequeue()();
    }
  };

  const run = async (fn, resolve, ...args) => {
    activeCount++;

    const result = (async () => fn(...args))();

    resolve(result);

    try {
      await result;
    } catch {}

    next();
  };

  const enqueue = (fn, resolve, ...args) => {
    queue.enqueue(run.bind(null, fn, resolve, ...args));

    (async () => {
      // This function needs to wait until the next microtask before comparing
      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
      // when the run function is dequeued and called. The comparison in the if-statement
      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
      await Promise.resolve();

      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };

  const generator = (fn, ...args) => new Promise(resolve => {
    enqueue(fn, resolve, ...args);
  });

  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
};

module.exports = pLimit;

},{"yocto-queue":593}],524:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  crypto_stream_chacha20_ietf,
  crypto_stream_chacha20_ietf_xor_ic
} = require("./crypto_stream_chacha20");

const {
  crypto_verify_16
} = require("./crypto_verify");

const Poly1305 = require("./internal/poly1305");

const assert = require('nanoassert');

const crypto_aead_chacha20poly1305_ietf_KEYBYTES = 32;
const crypto_aead_chacha20poly1305_ietf_NSECBYTES = 0;
const crypto_aead_chacha20poly1305_ietf_NPUBBYTES = 12;
const crypto_aead_chacha20poly1305_ietf_ABYTES = 16;
const crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER;

const _pad0 = new Uint8Array(16);

function crypto_aead_chacha20poly1305_ietf_encrypt(c, m, ad, nsec, npub, k) {
  if (ad === null) return crypto_aead_chacha20poly1305_ietf_encrypt(c, m, new Uint8Array(0), nsec, npub, k);
  assert(c.byteLength === m.byteLength + crypto_aead_chacha20poly1305_ietf_ABYTES, "ciphertext should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' longer than message");
  assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
  assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
  assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, 'message is too large');
  const ret = crypto_aead_chacha20poly1305_ietf_encrypt_detached(c.subarray(0, m.byteLength), c.subarray(m.byteLength), m, ad, nsec, npub, k);
  return m.byteLength + ret;
}

function crypto_aead_chacha20poly1305_ietf_encrypt_detached(c, mac, m, ad, nsec, npub, k) {
  if (ad === null) return crypto_aead_chacha20poly1305_ietf_encrypt_detached(c, mac, m, new Uint8Array(0), nsec, npub, k);
  assert(c.byteLength === m.byteLength, 'ciphertext should be same length than message');
  assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
  assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
  assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, 'message is too large');
  assert(mac.byteLength <= crypto_aead_chacha20poly1305_ietf_ABYTES, "mac should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' long");
  const block0 = new Uint8Array(64);
  var slen = new Uint8Array(8);
  crypto_stream_chacha20_ietf(block0, npub, k);
  const poly = new Poly1305(block0);
  block0.fill(0);
  poly.update(ad, 0, ad.byteLength);
  poly.update(_pad0, 0, 0x10 - ad.byteLength & 0xf);
  crypto_stream_chacha20_ietf_xor_ic(c, m, npub, 1, k);
  poly.update(c, 0, m.byteLength);
  poly.update(_pad0, 0, 0x10 - m.byteLength & 0xf);
  write64LE(slen, 0, ad.byteLength);
  poly.update(slen, 0, slen.byteLength);
  write64LE(slen, 0, m.byteLength);
  poly.update(slen, 0, slen.byteLength);
  poly.finish(mac, 0);
  slen.fill(0);
  return crypto_aead_chacha20poly1305_ietf_ABYTES;
}

function crypto_aead_chacha20poly1305_ietf_decrypt(m, nsec, c, ad, npub, k) {
  if (ad === null) return crypto_aead_chacha20poly1305_ietf_decrypt(m, nsec, c, new Uint8Array(0), npub, k);
  assert(m.byteLength === c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES, "message should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' shorter than ciphertext");
  assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
  assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
  assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, 'message is too large');
  if (c.byteLength < crypto_aead_chacha20poly1305_ietf_ABYTES) throw new Error('could not verify data');
  crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, nsec, c.subarray(0, c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES), c.subarray(c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES), ad, npub, k);
  return c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES;
}

function crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, nsec, c, mac, ad, npub, k) {
  if (ad === null) return crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, nsec, c, mac, new Uint8Array(0), npub, k);
  assert(c.byteLength === m.byteLength, 'message should be same length than ciphertext');
  assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
  assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
  assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, 'message is too large');
  assert(mac.byteLength <= crypto_aead_chacha20poly1305_ietf_ABYTES, "mac should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' long");
  const block0 = new Uint8Array(64);
  const slen = new Uint8Array(8);
  const computed_mac = new Uint8Array(crypto_aead_chacha20poly1305_ietf_ABYTES);
  crypto_stream_chacha20_ietf(block0, npub, k);
  const poly = new Poly1305(block0);
  block0.fill(0);
  poly.update(ad, 0, ad.byteLength);
  poly.update(_pad0, 0, 0x10 - ad.byteLength & 0xf);
  const mlen = c.byteLength;
  poly.update(c, 0, mlen);
  poly.update(_pad0, 0, 0x10 - mlen & 0xf);
  write64LE(slen, 0, ad.byteLength);
  poly.update(slen, 0, slen.byteLength);
  write64LE(slen, 0, mlen);
  poly.update(slen, 0, slen.byteLength);
  poly.finish(computed_mac, 0);
  assert(computed_mac.byteLength === 16);
  const ret = crypto_verify_16(computed_mac, 0, mac, 0);
  computed_mac.fill(0);
  slen.fill(0);

  if (!ret) {
    m.fill(0);
    throw new Error('could not verify data');
  }

  crypto_stream_chacha20_ietf_xor_ic(m, c, npub, 1, k);
}

function write64LE(buf, offset, int) {
  buf.fill(0, 0, 8);
  const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  view.setUint32(offset, int & 0xffffffff, true);
  view.setUint32(offset + 4, int / 2 ** 32 & 0xffffffff, true);
}

module.exports = {
  crypto_aead_chacha20poly1305_ietf_encrypt,
  crypto_aead_chacha20poly1305_ietf_encrypt_detached,
  crypto_aead_chacha20poly1305_ietf_decrypt,
  crypto_aead_chacha20poly1305_ietf_decrypt_detached,
  crypto_aead_chacha20poly1305_ietf_ABYTES,
  crypto_aead_chacha20poly1305_ietf_KEYBYTES,
  crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
  crypto_aead_chacha20poly1305_ietf_NSECBYTES,
  crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX
};

},{"./crypto_stream_chacha20":538,"./crypto_verify":539,"./internal/poly1305":543,"nanoassert":545}],525:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  crypto_verify_32
} = require("./crypto_verify");

const Sha512 = require('sha512-universal');

const assert = require('nanoassert');

const crypto_auth_BYTES = 32;
const crypto_auth_KEYBYTES = 32;

function crypto_auth(out, input, k) {
  assert(out.byteLength === crypto_auth_BYTES, "out should be 'crypto_auth_BYTES' in length");
  assert(k.byteLength === crypto_auth_KEYBYTES, "key should be 'crypto_auth_KEYBYTES' in length");
  const out0 = new Uint8Array(64);
  const hmac = Sha512.HMAC(k);
  hmac.update(input);
  hmac.digest(out0);
  out.set(out0.subarray(0, 32));
}

function crypto_auth_verify(h, input, k) {
  assert(h.byteLength === crypto_auth_BYTES, "h should be 'crypto_auth_BYTES' in length");
  assert(k.byteLength === crypto_auth_KEYBYTES, "key should be 'crypto_auth_KEYBYTES' in length");
  const correct = Sha512.HMAC(k).update(input).digest();
  return crypto_verify_32(h, 0, correct, 0);
}

module.exports = {
  crypto_auth_BYTES,
  crypto_auth_KEYBYTES,
  crypto_auth,
  crypto_auth_verify
};

},{"./crypto_verify":539,"nanoassert":545,"sha512-universal":461}],526:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  crypto_hash_sha512
} = require("./crypto_hash");

const {
  crypto_scalarmult,
  crypto_scalarmult_base
} = require("./crypto_scalarmult");

const {
  randombytes
} = require("./randombytes");

const {
  crypto_generichash_batch
} = require("./crypto_generichash");

const {
  crypto_stream_xsalsa20_MESSAGEBYTES_MAX
} = require("./crypto_stream");

const {
  crypto_secretbox_open_easy,
  crypto_secretbox_easy,
  crypto_secretbox_detached,
  crypto_secretbox_open_detached
} = require("./crypto_secretbox");

const xsalsa20 = require('xsalsa20');

const assert = require('nanoassert');

const crypto_box_PUBLICKEYBYTES = 32;
const crypto_box_SECRETKEYBYTES = 32;
const crypto_box_NONCEBYTES = 24;
const crypto_box_ZEROBYTES = 32;
const crypto_box_BOXZEROBYTES = 16;
const crypto_box_SEALBYTES = 48;
const crypto_box_SEEDBYTES = 32;
const crypto_box_BEFORENMBYTES = 32;
const crypto_box_MACBYTES = 16;
const crypto_box_curve25519xsalsa20poly1305_MACBYTES = 16;
const crypto_box_MESSAGEBYTES_MAX = crypto_stream_xsalsa20_MESSAGEBYTES_MAX - crypto_box_curve25519xsalsa20poly1305_MACBYTES;
module.exports = {
  crypto_box_easy,
  crypto_box_open_easy,
  crypto_box_keypair,
  crypto_box_seed_keypair,
  crypto_box_seal,
  crypto_box_seal_open,
  crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES,
  crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES,
  crypto_box_SEALBYTES,
  crypto_box_SEEDBYTES,
  crypto_box_BEFORENMBYTES,
  crypto_box_MACBYTES
};

function crypto_box_keypair(pk, sk) {
  check(pk, crypto_box_PUBLICKEYBYTES);
  check(sk, crypto_box_SECRETKEYBYTES);
  randombytes(sk, 32);
  return crypto_scalarmult_base(pk, sk);
}

function crypto_box_seed_keypair(pk, sk, seed) {
  assert(pk.byteLength === crypto_box_PUBLICKEYBYTES, "pk should be 'crypto_box_PUBLICKEYBYTES' bytes");
  assert(sk.byteLength === crypto_box_SECRETKEYBYTES, "sk should be 'crypto_box_SECRETKEYBYTES' bytes");
  assert(sk.byteLength === crypto_box_SEEDBYTES, "sk should be 'crypto_box_SEEDBYTES' bytes");
  const hash = new Uint8Array(64);
  crypto_hash_sha512(hash, seed, 32);
  sk.set(hash.subarray(0, 32));
  hash.fill(0);
  return crypto_scalarmult_base(pk, sk);
}

function crypto_box_seal(c, m, pk) {
  check(c, crypto_box_SEALBYTES + m.length);
  check(pk, crypto_box_PUBLICKEYBYTES);
  var epk = c.subarray(0, crypto_box_PUBLICKEYBYTES);
  var esk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(epk, esk);
  var n = new Uint8Array(crypto_box_NONCEBYTES);
  crypto_generichash_batch(n, [epk, pk]);
  var s = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult(s, esk, pk);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  var zero = new Uint8Array(16);
  xsalsa20.core_hsalsa20(k, zero, s, xsalsa20.SIGMA);
  crypto_secretbox_easy(c.subarray(epk.length), m, n, k);
  cleanup(esk);
}

function crypto_box_seal_open(m, c, pk, sk) {
  check(c, crypto_box_SEALBYTES);
  check(m, c.length - crypto_box_SEALBYTES);
  check(pk, crypto_box_PUBLICKEYBYTES);
  check(sk, crypto_box_SECRETKEYBYTES);
  var epk = c.subarray(0, crypto_box_PUBLICKEYBYTES);
  var n = new Uint8Array(crypto_box_NONCEBYTES);
  crypto_generichash_batch(n, [epk, pk]);
  var s = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult(s, sk, epk);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  var zero = new Uint8Array(16);
  xsalsa20.core_hsalsa20(k, zero, s, xsalsa20.SIGMA);
  return crypto_secretbox_open_easy(m, c.subarray(epk.length), n, k);
}

function crypto_box_beforenm(k, pk, sk) {
  const zero = new Uint8Array(16);
  const s = new Uint8Array(32);
  assert(crypto_scalarmult(s, sk, pk) === 0);
  xsalsa20.core_hsalsa20(k, zero, s, xsalsa20.SIGMA);
  return true;
}

function crypto_box_detached_afternm(c, mac, m, n, k) {
  return crypto_secretbox_detached(c, mac, m, n, k);
}

function crypto_box_detached(c, mac, m, n, pk, sk) {
  check(mac, crypto_box_MACBYTES);
  check(n, crypto_box_NONCEBYTES);
  check(pk, crypto_box_PUBLICKEYBYTES);
  check(sk, crypto_box_SECRETKEYBYTES);
  const k = new Uint8Array(crypto_box_BEFORENMBYTES);
  assert(crypto_box_beforenm(k, pk, sk));
  const ret = crypto_box_detached_afternm(c, mac, m, n, k);
  cleanup(k);
  return ret;
}

function crypto_box_easy(c, m, n, pk, sk) {
  assert(c.length >= m.length + crypto_box_MACBYTES, "c should be at least 'm.length + crypto_box_MACBYTES' bytes");
  assert(m.length <= crypto_box_MESSAGEBYTES_MAX, "m should be at most 'crypto_box_MESSAGEBYTES_MAX' bytes");
  return crypto_box_detached(c.subarray(crypto_box_MACBYTES, m.length + crypto_box_MACBYTES), c.subarray(0, crypto_box_MACBYTES), m, n, pk, sk);
}

function crypto_box_open_detached_afternm(m, c, mac, n, k) {
  return crypto_secretbox_open_detached(m, c, mac, n, k);
}

function crypto_box_open_detached(m, c, mac, n, pk, sk) {
  const k = new Uint8Array(crypto_box_BEFORENMBYTES);
  assert(crypto_box_beforenm(k, pk, sk));
  const ret = crypto_box_open_detached_afternm(m, c, mac, n, k);
  cleanup(k);
  return ret;
}

function crypto_box_open_easy(m, c, n, pk, sk) {
  assert(c.length >= m.length + crypto_box_MACBYTES, "c should be at least 'm.length + crypto_box_MACBYTES' bytes");
  return crypto_box_open_detached(m, c.subarray(crypto_box_MACBYTES, m.length + crypto_box_MACBYTES), c.subarray(0, crypto_box_MACBYTES), n, pk, sk);
}

function check(buf, len) {
  if (!buf || len && buf.length < len) throw new Error('Argument must be a buffer' + (len ? ' of length ' + len : ''));
}

function cleanup(arr) {
  for (let i = 0; i < arr.length; i++) arr[i] = 0;
}

},{"./crypto_generichash":527,"./crypto_hash":528,"./crypto_scalarmult":533,"./crypto_secretbox":534,"./crypto_stream":537,"./randombytes":546,"nanoassert":545,"xsalsa20":591}],527:[function(require,module,exports){
var blake2b = require('blake2b');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
module.exports.crypto_generichash_PRIMITIVE = 'blake2b';
module.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN;
module.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX;
module.exports.crypto_generichash_BYTES = blake2b.BYTES;
module.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN;
module.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX;
module.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES;
module.exports.crypto_generichash_WASM_SUPPORTED = blake2b.WASM_SUPPORTED;
module.exports.crypto_generichash_WASM_LOADED = false;

module.exports.crypto_generichash = function (output, input, key) {
  blake2b(output.length, key).update(input).final(output);
};

module.exports.crypto_generichash_ready = blake2b.ready;

module.exports.crypto_generichash_batch = function (output, inputArray, key) {
  var ctx = blake2b(output.length, key);

  for (var i = 0; i < inputArray.length; i++) {
    ctx.update(inputArray[i]);
  }

  ctx.final(output);
};

module.exports.crypto_generichash_instance = function (key, outlen) {
  if (outlen == null) outlen = module.exports.crypto_generichash_BYTES;
  return blake2b(outlen, key);
};

blake2b.ready(function (_) {
  module.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED;
});

},{"blake2b":45}],528:[function(require,module,exports){
/* eslint-disable camelcase */
const sha512 = require('sha512-universal');

const assert = require('nanoassert');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
const crypto_hash_sha512_BYTES = 64;
const crypto_hash_BYTES = crypto_hash_sha512_BYTES;

function crypto_hash_sha512(out, m, n) {
  assert(out.byteLength === crypto_hash_sha512_BYTES, "out must be 'crypto_hash_sha512_BYTES' bytes long");
  sha512().update(m.subarray(0, n)).digest(out);
  return 0;
}

function crypto_hash(out, m, n) {
  return crypto_hash_sha512(out, m, n);
}

module.exports = {
  crypto_hash,
  crypto_hash_sha512,
  crypto_hash_sha512_BYTES,
  crypto_hash_BYTES
};

},{"nanoassert":545,"sha512-universal":461}],529:[function(require,module,exports){
/* eslint-disable camelcase */
const sha256 = require('sha256-universal');

const assert = require('nanoassert');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
const crypto_hash_sha256_BYTES = 32;

function crypto_hash_sha256(out, m, n) {
  assert(out.byteLength === crypto_hash_sha256_BYTES, "out must be 'crypto_hash_sha256_BYTES' bytes long");
  sha256().update(m.subarray(0, n)).digest(out);
  return 0;
}

module.exports = {
  crypto_hash_sha256,
  crypto_hash_sha256_BYTES
};

},{"nanoassert":545,"sha256-universal":456}],530:[function(require,module,exports){
/* eslint-disable camelcase */
const assert = require('nanoassert');

const randombytes_buf = require("./randombytes").randombytes_buf;

const blake2b = require('blake2b');

module.exports.crypto_kdf_PRIMITIVE = 'blake2b';
module.exports.crypto_kdf_BYTES_MIN = 16;
module.exports.crypto_kdf_BYTES_MAX = 64;
module.exports.crypto_kdf_CONTEXTBYTES = 8;
module.exports.crypto_kdf_KEYBYTES = 32;

function STORE64_LE(dest, int) {
  var mul = 1;
  var i = 0;
  dest[0] = int & 0xFF;

  while (++i < 8 && (mul *= 0x100)) {
    dest[i] = int / mul & 0xFF;
  }
}

module.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key(subkey, subkey_id, ctx, key) {
  assert(subkey.length >= module.exports.crypto_kdf_BYTES_MIN, 'subkey must be at least crypto_kdf_BYTES_MIN');
  assert(subkey_id >= 0 && subkey_id <= 0x1fffffffffffff, 'subkey_id must be safe integer');
  assert(ctx.length >= module.exports.crypto_kdf_CONTEXTBYTES, 'context must be at least crypto_kdf_CONTEXTBYTES');
  var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES);
  var salt = new Uint8Array(blake2b.SALTBYTES);
  ctx_padded.set(ctx, 0, module.exports.crypto_kdf_CONTEXTBYTES);
  STORE64_LE(salt, subkey_id);
  var outlen = Math.min(subkey.length, module.exports.crypto_kdf_BYTES_MAX);
  blake2b(outlen, key.subarray(0, module.exports.crypto_kdf_KEYBYTES), salt, ctx_padded, true).final(subkey);
};

module.exports.crypto_kdf_keygen = function crypto_kdf_keygen(out) {
  assert(out.length >= module.exports.crypto_kdf_KEYBYTES, 'out.length must be crypto_kdf_KEYBYTES');
  randombytes_buf(out.subarray(0, module.exports.crypto_kdf_KEYBYTES));
};

},{"./randombytes":546,"blake2b":45,"nanoassert":545}],531:[function(require,module,exports){
/* eslint-disable camelcase */
const {
  crypto_scalarmult_base
} = require("./crypto_scalarmult");

const {
  crypto_generichash
} = require("./crypto_generichash");

const {
  randombytes_buf
} = require("./randombytes");

const assert = require('nanoassert');

const crypto_kx_SEEDBYTES = 32;
const crypto_kx_PUBLICKEYBYTES = 32;
const crypto_kx_SECRETKEYBYTES = 32;

function crypto_kx_keypair(pk, sk) {
  assert(pk.byteLength === crypto_kx_PUBLICKEYBYTES, "pk must be 'crypto_kx_PUBLICKEYBYTES' bytes");
  assert(sk.byteLength === crypto_kx_SECRETKEYBYTES, "sk must be 'crypto_kx_SECRETKEYBYTES' bytes");
  randombytes_buf(sk, crypto_kx_SECRETKEYBYTES);
  return crypto_scalarmult_base(pk, sk);
}

function crypto_kx_seed_keypair(pk, sk, seed) {
  assert(pk.byteLength === crypto_kx_PUBLICKEYBYTES, "pk must be 'crypto_kx_PUBLICKEYBYTES' bytes");
  assert(sk.byteLength === crypto_kx_SECRETKEYBYTES, "sk must be 'crypto_kx_SECRETKEYBYTES' bytes");
  assert(seed.byteLength === crypto_kx_SEEDBYTES, "seed must be 'crypto_kx_SEEDBYTES' bytes");
  crypto_generichash(sk, seed);
  return crypto_scalarmult_base(pk, sk);
}

module.exports = {
  crypto_kx_keypair,
  crypto_kx_seed_keypair,
  crypto_kx_SEEDBYTES,
  crypto_kx_SECRETKEYBYTES,
  crypto_kx_PUBLICKEYBYTES
};

},{"./crypto_generichash":527,"./crypto_scalarmult":533,"./randombytes":546,"nanoassert":545}],532:[function(require,module,exports){
/* eslint-disable camelcase */
const assert = require('nanoassert');

const Poly1305 = require("./internal/poly1305");

const {
  crypto_verify_16
} = require("./crypto_verify");

const crypto_onetimeauth_BYTES = 16;
const crypto_onetimeauth_KEYBYTES = 32;
const crypto_onetimeauth_PRIMITIVE = 'poly1305';
module.exports = {
  crypto_onetimeauth,
  crypto_onetimeauth_verify,
  crypto_onetimeauth_BYTES,
  crypto_onetimeauth_KEYBYTES,
  crypto_onetimeauth_PRIMITIVE
};

function crypto_onetimeauth(mac, msg, key) {
  assert(mac.byteLength === crypto_onetimeauth_BYTES, "mac must be 'crypto_onetimeauth_BYTES' bytes");
  assert(msg.byteLength != null, 'msg must be buffer');
  assert(key.byteLength === crypto_onetimeauth_KEYBYTES, "key must be 'crypto_onetimeauth_KEYBYTES' bytes");
  var s = new Poly1305(key);
  s.update(msg, 0, msg.byteLength);
  s.finish(mac, 0);
}

function crypto_onetimeauth_verify(mac, msg, key) {
  assert(mac.byteLength === crypto_onetimeauth_BYTES, "mac must be 'crypto_onetimeauth_BYTES' bytes");
  assert(msg.byteLength != null, 'msg must be buffer');
  assert(key.byteLength === crypto_onetimeauth_KEYBYTES, "key must be 'crypto_onetimeauth_KEYBYTES' bytes");
  var tmp = new Uint8Array(16);
  crypto_onetimeauth(tmp, msg, key);
  return crypto_verify_16(mac, 0, tmp, 0);
}

},{"./crypto_verify":539,"./internal/poly1305":543,"nanoassert":545}],533:[function(require,module,exports){
/* eslint-disable camelcase, one-var */
const {
  _9,
  _121665,
  gf,
  inv25519,
  pack25519,
  unpack25519,
  sel25519,
  A,
  M,
  Z,
  S
} = require("./internal/ed25519");

const crypto_scalarmult_BYTES = 32;
const crypto_scalarmult_SCALARBYTES = 32;
module.exports = {
  crypto_scalarmult,
  crypto_scalarmult_base,
  crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES
};

function crypto_scalarmult(q, n, p) {
  check(q, crypto_scalarmult_BYTES);
  check(n, crypto_scalarmult_SCALARBYTES);
  check(p, crypto_scalarmult_BYTES);
  var z = new Uint8Array(32);
  var x = new Float64Array(80),
      r,
      i;
  var a = gf(),
      b = gf(),
      c = gf(),
      d = gf(),
      e = gf(),
      f = gf();

  for (i = 0; i < 31; i++) z[i] = n[i];

  z[31] = n[31] & 127 | 64;
  z[0] &= 248;
  unpack25519(x, p);

  for (i = 0; i < 16; i++) {
    b[i] = x[i];
    d[i] = a[i] = c[i] = 0;
  }

  a[0] = d[0] = 1;

  for (i = 254; i >= 0; --i) {
    r = z[i >>> 3] >>> (i & 7) & 1;
    sel25519(a, b, r);
    sel25519(c, d, r);
    A(e, a, c);
    Z(a, a, c);
    A(c, b, d);
    Z(b, b, d);
    S(d, e);
    S(f, a);
    M(a, c, a);
    M(c, b, e);
    A(e, a, c);
    Z(a, a, c);
    S(b, a);
    Z(c, d, f);
    M(a, c, _121665);
    A(a, a, d);
    M(c, c, a);
    M(a, d, f);
    M(d, b, x);
    S(b, e);
    sel25519(a, b, r);
    sel25519(c, d, r);
  }

  for (i = 0; i < 16; i++) {
    x[i + 16] = a[i];
    x[i + 32] = c[i];
    x[i + 48] = b[i];
    x[i + 64] = d[i];
  }

  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32, x32);
  M(x16, x16, x32);
  pack25519(q, x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function check(buf, len) {
  if (!buf || len && buf.length < len) throw new Error('Argument must be a buffer' + (len ? ' of length ' + len : ''));
}

},{"./internal/ed25519":542}],534:[function(require,module,exports){
/* eslint-disable camelcase */
const assert = require('nanoassert');

const {
  crypto_stream,
  crypto_stream_xor
} = require("./crypto_stream");

const {
  crypto_onetimeauth,
  crypto_onetimeauth_verify,
  crypto_onetimeauth_BYTES,
  crypto_onetimeauth_KEYBYTES
} = require("./crypto_onetimeauth");

const crypto_secretbox_KEYBYTES = 32;
const crypto_secretbox_NONCEBYTES = 24;
const crypto_secretbox_ZEROBYTES = 32;
const crypto_secretbox_BOXZEROBYTES = 16;
const crypto_secretbox_MACBYTES = 16;
module.exports = {
  crypto_secretbox,
  crypto_secretbox_open,
  crypto_secretbox_detached,
  crypto_secretbox_open_detached,
  crypto_secretbox_easy,
  crypto_secretbox_open_easy,
  crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES,
  crypto_secretbox_MACBYTES
};

function crypto_secretbox(c, m, n, k) {
  assert(c.byteLength === m.byteLength, "c must be 'm.byteLength' bytes");
  const mlen = m.byteLength;
  assert(mlen >= crypto_secretbox_ZEROBYTES, "mlen must be at least 'crypto_secretbox_ZEROBYTES'");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  crypto_stream_xor(c, m, n, k);
  crypto_onetimeauth(c.subarray(crypto_secretbox_BOXZEROBYTES, crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES), c.subarray(crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES, c.byteLength), c.subarray(0, crypto_onetimeauth_KEYBYTES));
  c.fill(0, 0, crypto_secretbox_BOXZEROBYTES);
}

function crypto_secretbox_open(m, c, n, k) {
  assert(c.byteLength === m.byteLength, "c must be 'm.byteLength' bytes");
  const mlen = m.byteLength;
  assert(mlen >= crypto_secretbox_ZEROBYTES, "mlen must be at least 'crypto_secretbox_ZEROBYTES'");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  const x = new Uint8Array(crypto_onetimeauth_KEYBYTES);
  crypto_stream(x, n, k);
  const validMac = crypto_onetimeauth_verify(c.subarray(crypto_secretbox_BOXZEROBYTES, crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES), c.subarray(crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES, c.byteLength), x);
  if (validMac === false) return false;
  crypto_stream_xor(m, c, n, k);
  m.fill(0, 0, 32);
  return true;
}

function crypto_secretbox_detached(o, mac, msg, n, k) {
  assert(o.byteLength === msg.byteLength, "o must be 'msg.byteLength' bytes");
  assert(mac.byteLength === crypto_secretbox_MACBYTES, "mac must be 'crypto_secretbox_MACBYTES' bytes");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  const tmp = new Uint8Array(msg.byteLength + mac.byteLength);
  crypto_secretbox_easy(tmp, msg, n, k);
  mac.set(tmp.subarray(0, mac.byteLength));
  o.set(tmp.subarray(mac.byteLength));
  return true;
}

function crypto_secretbox_open_detached(msg, o, mac, n, k) {
  assert(o.byteLength === msg.byteLength, "o must be 'msg.byteLength' bytes");
  assert(mac.byteLength === crypto_secretbox_MACBYTES, "mac must be 'crypto_secretbox_MACBYTES' bytes");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  const tmp = new Uint8Array(o.byteLength + mac.byteLength);
  tmp.set(mac);
  tmp.set(o, mac.byteLength);
  return crypto_secretbox_open_easy(msg, tmp, n, k);
}

function crypto_secretbox_easy(o, msg, n, k) {
  assert(o.byteLength === msg.byteLength + crypto_secretbox_MACBYTES, "o must be 'msg.byteLength + crypto_secretbox_MACBYTES' bytes");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  const m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.byteLength);
  const c = new Uint8Array(m.byteLength);
  m.set(msg, crypto_secretbox_ZEROBYTES);
  crypto_secretbox(c, m, n, k);
  o.set(c.subarray(crypto_secretbox_BOXZEROBYTES));
}

function crypto_secretbox_open_easy(msg, box, n, k) {
  assert(box.byteLength === msg.byteLength + crypto_secretbox_MACBYTES, "box must be 'msg.byteLength + crypto_secretbox_MACBYTES' bytes");
  assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
  assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
  const c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.byteLength);
  const m = new Uint8Array(c.byteLength);
  c.set(box, crypto_secretbox_BOXZEROBYTES);
  if (crypto_secretbox_open(m, c, n, k) === false) return false;
  msg.set(m.subarray(crypto_secretbox_ZEROBYTES));
  return true;
}

},{"./crypto_onetimeauth":532,"./crypto_stream":537,"nanoassert":545}],535:[function(require,module,exports){
var siphash = require('siphash24');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
exports.crypto_shorthash_PRIMITIVE = 'siphash24';
exports.crypto_shorthash_BYTES = siphash.BYTES;
exports.crypto_shorthash_KEYBYTES = siphash.KEYBYTES;
exports.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED;
exports.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED;
exports.crypto_shorthash = shorthash;

function shorthash(out, data, key, noAssert) {
  siphash(data, key, out, noAssert);
}

},{"siphash24":508}],536:[function(require,module,exports){
(function (Buffer){(function (){
/* eslint-disable camelcase, one-var */
const {
  crypto_verify_32
} = require("./crypto_verify");

const {
  crypto_hash
} = require("./crypto_hash");

const {
  gf,
  gf0,
  gf1,
  D,
  D2,
  X,
  Y,
  I,
  A,
  Z,
  M,
  S,
  sel25519,
  pack25519,
  inv25519,
  unpack25519
} = require("./internal/ed25519");

const {
  randombytes
} = require("./randombytes");

const {
  crypto_scalarmult_BYTES
} = require("./crypto_scalarmult.js");

const {
  crypto_hash_sha512_BYTES
} = require("./crypto_hash.js");

const assert = require('nanoassert');

const crypto_sign_ed25519_PUBLICKEYBYTES = 32;
const crypto_sign_ed25519_SECRETKEYBYTES = 64;
const crypto_sign_ed25519_SEEDBYTES = 32;
const crypto_sign_ed25519_BYTES = 64;
const crypto_sign_BYTES = crypto_sign_ed25519_BYTES;
const crypto_sign_PUBLICKEYBYTES = crypto_sign_ed25519_PUBLICKEYBYTES;
const crypto_sign_SECRETKEYBYTES = crypto_sign_ed25519_SECRETKEYBYTES;
const crypto_sign_SEEDBYTES = crypto_sign_ed25519_SEEDBYTES;
module.exports = {
  crypto_sign_keypair,
  crypto_sign_seed_keypair,
  crypto_sign,
  crypto_sign_detached,
  crypto_sign_open,
  crypto_sign_verify_detached,
  crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES,
  crypto_sign_ed25519_PUBLICKEYBYTES,
  crypto_sign_ed25519_SECRETKEYBYTES,
  crypto_sign_ed25519_SEEDBYTES,
  crypto_sign_ed25519_BYTES,
  crypto_sign_ed25519_pk_to_curve25519,
  crypto_sign_ed25519_sk_to_curve25519,
  crypto_sign_ed25519_sk_to_pk,
  unpackneg,
  pack
};

function set25519(r, a) {
  for (let i = 0; i < 16; i++) r[i] = a[i] | 0;
}

function pow2523(o, i) {
  var c = gf();
  var a;

  for (a = 0; a < 16; a++) c[a] = i[a];

  for (a = 250; a >= 0; a--) {
    S(c, c);
    if (a !== 1) M(c, c, i);
  }

  for (a = 0; a < 16; a++) o[a] = c[a];
}

function add(p, q) {
  var a = gf(),
      b = gf(),
      c = gf(),
      d = gf(),
      e = gf(),
      f = gf(),
      g = gf(),
      h = gf(),
      t = gf();
  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);
  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;

  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(),
      ty = gf(),
      zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  // don't mutate q
  var h = [gf(q[0]), gf(q[1]), gf(q[2]), gf(q[3])];
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);

  for (i = 255; i >= 0; --i) {
    b = s[i / 8 | 0] >> (i & 7) & 1;
    cswap(p, h, b);
    add(h, p);
    add(p, p);
    cswap(p, h, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  check(pk, crypto_sign_PUBLICKEYBYTES);
  check(sk, crypto_sign_SECRETKEYBYTES);
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;
  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
}

function crypto_sign_seed_keypair(pk, sk, seed) {
  check(seed, crypto_sign_SEEDBYTES);
  sk.set(seed);
  return crypto_sign_keypair(pk, sk, true);
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;

  for (i = 63; i >= 32; --i) {
    carry = 0;

    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = x[j] + 128 >> 8;
      x[j] -= carry * 256;
    }

    x[j] += carry;
    x[i] = 0;
  }

  carry = 0;

  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }

  for (j = 0; j < 32; j++) x[j] -= carry * L[j];

  for (i = 0; i < 32; i++) {
    x[i + 1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64);

  for (let i = 0; i < 64; i++) x[i] = r[i];

  for (let i = 0; i < 64; i++) r[i] = 0;

  modL(r, x);
} // Note: difference from C - smlen returned, not passed as argument.


function crypto_sign(sm, m, sk) {
  check(sm, crypto_sign_BYTES + m.length);
  check(m, 0);
  check(sk, crypto_sign_SECRETKEYBYTES);
  var n = m.length;
  var d = new Uint8Array(64),
      h = new Uint8Array(64),
      r = new Uint8Array(64);
  var i,
      j,
      x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  var smlen = n + 64;

  for (i = 0; i < n; i++) sm[64 + i] = m[i];

  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n + 32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];

  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;

  for (i = 0; i < 32; i++) x[i] = r[i];

  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i + j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function crypto_sign_detached(sig, m, sk) {
  var sm = new Uint8Array(m.length + crypto_sign_BYTES);
  crypto_sign(sm, m, sk);

  for (let i = 0; i < crypto_sign_BYTES; i++) sig[i] = sm[i];
}

function unpackneg(r, p) {
  var t = gf(),
      chk = gf(),
      num = gf(),
      den = gf(),
      den2 = gf(),
      den4 = gf(),
      den6 = gf();
  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);
  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);
  S(chk, r[0]);
  M(chk, chk, den);
  if (!neq25519(chk, num)) M(r[0], r[0], I);
  S(chk, r[0]);
  M(chk, chk, den);
  if (!neq25519(chk, num)) return false;

  if (par25519(r[0]) === p[31] >> 7) {
    Z(r[0], gf(), r[0]);
  }

  M(r[3], r[0], r[1]);
  return true;
}
/* eslint-disable no-unused-vars */


function crypto_sign_open(msg, sm, pk) {
  check(msg, sm.length - crypto_sign_BYTES);
  check(sm, crypto_sign_BYTES);
  check(pk, crypto_sign_PUBLICKEYBYTES);
  var n = sm.length;
  var m = new Uint8Array(sm.length);
  var i, mlen;
  var t = new Uint8Array(32),
      h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];
  mlen = -1;
  if (n < 64) return false;
  if (!unpackneg(q, pk)) return false;

  for (i = 0; i < n; i++) m[i] = sm[i];

  for (i = 0; i < 32; i++) m[i + 32] = pk[i];

  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);
  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);
  n -= 64;

  if (!crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;

    return false; // throw new Error('crypto_sign_open failed')
  }

  for (i = 0; i < n; i++) msg[i] = sm[i + 64];

  mlen = n;
  return true;
}
/* eslint-enable no-unused-vars */


function crypto_sign_verify_detached(sig, m, pk) {
  check(sig, crypto_sign_BYTES);
  var sm = new Uint8Array(m.length + crypto_sign_BYTES);
  var i = 0;

  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];

  for (i = 0; i < m.length; i++) sm[i + crypto_sign_BYTES] = m[i];

  return crypto_sign_open(m, sm, pk);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function neq25519(a, b) {
  var c = new Uint8Array(32),
      d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function ed25519_mul_l(p, q) {
  scalarmult(p, q, L);
}

function ed25519_is_on_main_subgroup(p) {
  var pl = [gf(), gf(), gf(), gf()];
  ed25519_mul_l(pl, p);
  var zero = 0;

  for (let i = 0; i < 16; i++) {
    zero |= pl[0][i] & 0xffff;
  }

  return zero === 0;
}

function crypto_sign_ed25519_pk_to_curve25519(x25519_pk, ed25519_pk) {
  check(x25519_pk, crypto_sign_PUBLICKEYBYTES);
  check(ed25519_pk, crypto_sign_ed25519_PUBLICKEYBYTES);
  var a = [gf(), gf(), gf(), gf()];
  var x = gf([1]);
  var one_minus_y = gf([1]);
  assert(isSmallOrder(ed25519_pk) && unpackneg(a, ed25519_pk) && ed25519_is_on_main_subgroup(a), 'Cannot convert key: bad point');

  for (let i = 0; i < a.length; i++) {
    pack25519(x25519_pk, a[i]);
  }

  Z(one_minus_y, one_minus_y, a[1]);
  A(x, x, a[1]);
  inv25519(one_minus_y, one_minus_y);
  M(x, x, one_minus_y);
  pack25519(x25519_pk, x);
  return 0;
}

function isSmallOrder(s) {
  Uint8Array.from([]);
  var bad_points = [// 0 (order 4)
  Uint8Array.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), // 1 (order 1)
  Uint8Array.from([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), // 2707385501144840649318225287225658788936804267575313519463743609750303402022(order 8)
  Uint8Array.from([0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0, 0x45, 0xc3, 0xf4, 0x89, 0xf2, 0xef, 0x98, 0xf0, 0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6, 0x33, 0x39, 0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05]), // 55188659117513257062467267217118295137698188065244968500265048394206261417927 (order 8)
  Uint8Array.from([0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f, 0xba, 0x3c, 0x0b, 0x76, 0x0d, 0x10, 0x67, 0x0f, 0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39, 0xcc, 0xc6, 0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a]), // p-1 (order 2)
  Uint8Array.from([0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]), //  p (=0 order 4)
  Uint8Array.from([0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]), // p + 1 (=1 order 1)
  Uint8Array.from([0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f])];
  var c = new Uint8Array(7);
  var j;
  check(bad_points, 7);

  for (let i = 0; i < bad_points.length; i++) {
    for (j = 0; j < 31; j++) {
      c[i] |= s[j] ^ bad_points[i][j];
    }
  }

  for (let i = 0; i < bad_points.length; i++) {
    c[i] |= s[j] & 0x7f ^ bad_points[i][j];
  }

  var k = 0;

  for (let i = 0; i < bad_points.length; i++) {
    k |= c[i] - 1;
  }

  return (k >> 8 & 1) === 0;
}

function crypto_sign_ed25519_sk_to_pk(pk, sk) {
  check(pk, crypto_sign_ed25519_PUBLICKEYBYTES);
  pk.set(sk.subarray(crypto_sign_ed25519_SEEDBYTES));
  return pk;
}

function crypto_sign_ed25519_sk_to_curve25519(curveSk, edSk) {
  assert(curveSk && curveSk.byteLength === crypto_scalarmult_BYTES, "curveSk must be 'crypto_sign_SECRETKEYBYTES' long");
  assert(edSk && edSk.byteLength === crypto_sign_ed25519_SECRETKEYBYTES, "edSk must be 'crypto_sign_ed25519_SECRETKEYBYTES' long");
  var h = Buffer.alloc(crypto_hash_sha512_BYTES);
  crypto_hash(h, edSk, 32);
  h[0] &= 248;
  h[31] &= 127;
  h[31] |= 64;
  curveSk.set(h.subarray(0, crypto_scalarmult_BYTES));
  h.fill(0);
  return curveSk;
}

function check(buf, len, arg = 'Argument') {
  if (!buf || len && buf.length < len) throw new Error(arg + ' must be a buffer' + (len ? ' of length ' + len : ''));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./crypto_hash":528,"./crypto_hash.js":528,"./crypto_scalarmult.js":533,"./crypto_verify":539,"./internal/ed25519":542,"./randombytes":546,"buffer":97,"nanoassert":545}],537:[function(require,module,exports){
/* eslint-disable camelcase */
const xsalsa20 = require('xsalsa20');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
exports.crypto_stream_KEYBYTES = 32;
exports.crypto_stream_NONCEBYTES = 24;
exports.crypto_stream_PRIMITIVE = 'xsalsa20';
exports.crypto_stream_xsalsa20_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER;

exports.crypto_stream = function (c, nonce, key) {
  c.fill(0);
  exports.crypto_stream_xor(c, c, nonce, key);
};

exports.crypto_stream_xor = function (c, m, nonce, key) {
  const xor = xsalsa20(nonce, key);
  xor.update(m, c);
  xor.final();
};

exports.crypto_stream_xor_instance = function (nonce, key) {
  return new XOR(nonce, key);
};

function XOR(nonce, key) {
  this._instance = xsalsa20(nonce, key);
}

XOR.prototype.update = function (out, inp) {
  this._instance.update(inp, out);
};

XOR.prototype.final = function () {
  this._instance.finalize();

  this._instance = null;
};

},{"xsalsa20":591}],538:[function(require,module,exports){
const assert = require('nanoassert');

const Chacha20 = require('chacha20-universal');

if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');
exports.crypto_stream_chacha20_KEYBYTES = 32;
exports.crypto_stream_chacha20_NONCEBYTES = 8;
exports.crypto_stream_chacha20_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER;
exports.crypto_stream_chacha20_ietf_KEYBYTES = 32;
exports.crypto_stream_chacha20_ietf_NONCEBYTES = 12;
exports.crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX = 2 ** 32;

exports.crypto_stream_chacha20 = function (c, n, k) {
  c.fill(0);
  exports.crypto_stream_chacha20_xor(c, c, n, k);
};

exports.crypto_stream_chacha20_xor = function (c, m, n, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_NONCEBYTES, 'n should be crypto_stream_chacha20_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_KEYBYTES, 'k should be crypto_stream_chacha20_KEYBYTES');
  const xor = new Chacha20(n, k);
  xor.update(c, m);
  xor.final();
};

exports.crypto_stream_chacha20_xor_ic = function (c, m, n, ic, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_NONCEBYTES, 'n should be crypto_stream_chacha20_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_KEYBYTES, 'k should be crypto_stream_chacha20_KEYBYTES');
  const xor = new Chacha20(n, k, ic);
  xor.update(c, m);
  xor.final();
};

exports.crypto_stream_chacha20_xor_instance = function (n, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_NONCEBYTES, 'n should be crypto_stream_chacha20_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_KEYBYTES, 'k should be crypto_stream_chacha20_KEYBYTES');
  return new Chacha20(n, k);
};

exports.crypto_stream_chacha20_ietf = function (c, n, k) {
  c.fill(0);
  exports.crypto_stream_chacha20_ietf_xor(c, c, n, k);
};

exports.crypto_stream_chacha20_ietf_xor = function (c, m, n, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_ietf_NONCEBYTES, 'n should be crypto_stream_chacha20_ietf_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_ietf_KEYBYTES, 'k should be crypto_stream_chacha20_ietf_KEYBYTES');
  const xor = new Chacha20(n, k);
  xor.update(c, m);
  xor.final();
};

exports.crypto_stream_chacha20_ietf_xor_ic = function (c, m, n, ic, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_ietf_NONCEBYTES, 'n should be crypto_stream_chacha20_ietf_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_ietf_KEYBYTES, 'k should be crypto_stream_chacha20_ietf_KEYBYTES');
  const xor = new Chacha20(n, k, ic);
  xor.update(c, m);
  xor.final();
};

exports.crypto_stream_chacha20_ietf_xor_instance = function (n, k) {
  assert(n.byteLength === exports.crypto_stream_chacha20_ietf_NONCEBYTES, 'n should be crypto_stream_chacha20_ietf_NONCEBYTES');
  assert(k.byteLength === exports.crypto_stream_chacha20_ietf_KEYBYTES, 'k should be crypto_stream_chacha20_ietf_KEYBYTES');
  return new Chacha20(n, k);
};

},{"chacha20-universal":114,"nanoassert":545}],539:[function(require,module,exports){
/* eslint-disable camelcase */
module.exports = {
  crypto_verify_16,
  crypto_verify_32,
  crypto_verify_64
};

function vn(x, xi, y, yi, n) {
  var d = 0;

  for (let i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];

  return (1 & d - 1 >>> 8) - 1;
} // Make non enumerable as this is an internal function


Object.defineProperty(module.exports, 'vn', {
  value: vn
});

function crypto_verify_16(x, xi, y, yi) {
  return vn(x, xi, y, yi, 16) === 0;
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x, xi, y, yi, 32) === 0;
}

function crypto_verify_64(x, xi, y, yi) {
  return vn(x, xi, y, yi, 64) === 0;
}

},{}],540:[function(require,module,exports){
/* eslint-disable camelcase */
const assert = require('nanoassert');

const {
  vn
} = require("./crypto_verify");

function sodium_increment(n) {
  const nlen = n.byteLength;
  var c = 1;

  for (var i = 0; i < nlen; i++) {
    c += n[i];
    n[i] = c;
    c >>= 8;
  }
}

function sodium_memcmp(a, b) {
  assert(a.byteLength === b.byteLength, 'buffers must be the same size');
  return vn(a, 0, b, 0, a.byteLength) === 0;
}

function sodium_is_zero(arr) {
  var d = 0;

  for (let i = 0; i < arr.length; i++) d |= arr[i];

  return d === 0;
}

module.exports = {
  sodium_increment,
  sodium_memcmp,
  sodium_is_zero
};

},{"./crypto_verify":539,"nanoassert":545}],541:[function(require,module,exports){
'use strict'; // Based on https://github.com/dchest/tweetnacl-js/blob/6dcbcaf5f5cbfd313f2dcfe763db35c828c8ff5b/nacl-fast.js.
// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

forward(require("./randombytes"));
forward(require("./memory"));
forward(require("./helpers"));
forward(require("./crypto_verify"));
forward(require("./crypto_auth"));
forward(require("./crypto_box"));
forward(require("./crypto_generichash"));
forward(require("./crypto_hash"));
forward(require("./crypto_hash_sha256"));
forward(require("./crypto_kdf"));
forward(require("./crypto_kx"));
forward(require("./crypto_aead"));
forward(require("./crypto_onetimeauth"));
forward(require("./crypto_scalarmult"));
forward(require("./crypto_secretbox"));
forward(require("./crypto_shorthash"));
forward(require("./crypto_sign"));
forward(require("./crypto_stream"));
forward(require("./crypto_stream_chacha20"));

function forward(submodule) {
  Object.keys(submodule).forEach(function (prop) {
    module.exports[prop] = submodule[prop];
  });
}

},{"./crypto_aead":524,"./crypto_auth":525,"./crypto_box":526,"./crypto_generichash":527,"./crypto_hash":528,"./crypto_hash_sha256":529,"./crypto_kdf":530,"./crypto_kx":531,"./crypto_onetimeauth":532,"./crypto_scalarmult":533,"./crypto_secretbox":534,"./crypto_shorthash":535,"./crypto_sign":536,"./crypto_stream":537,"./crypto_stream_chacha20":538,"./crypto_verify":539,"./helpers":540,"./memory":544,"./randombytes":546}],542:[function(require,module,exports){
if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');

var gf = function (init) {
  var i,
      r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

var _0 = new Uint8Array(16);

var _9 = new Uint8Array(32);

_9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v,
      c,
      t0 = 0,
      t1 = 0,
      t2 = 0,
      t3 = 0,
      t4 = 0,
      t5 = 0,
      t6 = 0,
      t7 = 0,
      t8 = 0,
      t9 = 0,
      t10 = 0,
      t11 = 0,
      t12 = 0,
      t13 = 0,
      t14 = 0,
      t15 = 0,
      t16 = 0,
      t17 = 0,
      t18 = 0,
      t19 = 0,
      t20 = 0,
      t21 = 0,
      t22 = 0,
      t23 = 0,
      t24 = 0,
      t25 = 0,
      t26 = 0,
      t27 = 0,
      t28 = 0,
      t29 = 0,
      t30 = 0,
      b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11],
      b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30; // t15 left as is
  // first car

  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1); // second car

  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function sel25519(p, q, b) {
  var t,
      c = ~(b - 1);

  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(),
      t = gf();

  for (i = 0; i < 16; i++) t[i] = n[i];

  car25519(t);
  car25519(t);
  car25519(t);

  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;

    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
      m[i - 1] &= 0xffff;
    }

    m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
    b = m[15] >> 16 & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1 - b);
  }

  for (i = 0; i < 16; i++) {
    o[2 * i] = t[i] & 0xff;
    o[2 * i + 1] = t[i] >> 8;
  }
}

function unpack25519(o, n) {
  var i;

  for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);

  o[15] &= 0x7fff;
}

function inv25519(o, i) {
  var c = gf();
  var a;

  for (a = 0; a < 16; a++) c[a] = i[a];

  for (a = 253; a >= 0; a--) {
    S(c, c);
    if (a !== 2 && a !== 4) M(c, c, i);
  }

  for (a = 0; a < 16; a++) o[a] = c[a];
}

function car25519(o) {
  var i,
      v,
      c = 1;

  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }

  o[0] += c - 1 + 37 * (c - 1);
}

module.exports = {
  gf,
  A,
  Z,
  M,
  S,
  sel25519,
  pack25519,
  unpack25519,
  inv25519,
  gf0,
  gf1,
  _9,
  _121665,
  D,
  D2,
  X,
  Y,
  I
};

},{}],543:[function(require,module,exports){
/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/
if (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.');

var poly1305 = function (key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;
  var t0, t1, t2, t3, t4, t5, t6, t7;
  t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
  this.r[0] = t0 & 0x1fff;
  t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
  this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
  t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
  this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
  t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
  this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
  t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
  this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
  this.r[5] = t4 >>> 1 & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
  this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
  this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
  this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
  this.r[9] = t7 >>> 5 & 0x007f;
  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function (m, mpos, bytes) {
  var hibit = this.fin ? 0 : 1 << 11;
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];
  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
    h0 += t0 & 0x1fff;
    t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
    h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
    t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
    h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
    t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
    h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
    t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
    h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
    h5 += t4 >>> 1 & 0x1fff;
    t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
    h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
    t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
    h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
    t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
    h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
    h9 += t7 >>> 5 | hibit;
    c = 0;
    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 0x1fff;
    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 0x1fff;
    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 0x1fff;
    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 0x1fff;
    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = d4 >>> 13;
    d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 0x1fff;
    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = d5 >>> 13;
    d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 0x1fff;
    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = d6 >>> 13;
    d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 0x1fff;
    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = d7 >>> 13;
    d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 0x1fff;
    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = d8 >>> 13;
    d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 0x1fff;
    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = d9 >>> 13;
    d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += d9 >>> 13;
    d9 &= 0x1fff;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 0x1fff;
    c = c >>> 13;
    d1 += c;
    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;
    mpos += 16;
    bytes -= 16;
  }

  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function (mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;

    for (; i < 16; i++) this.buffer[i] = 0;

    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;

  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }

  this.h[0] += c * 5;
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;
  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;

  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }

  g[9] -= 1 << 13;
  mask = (c ^ 1) - 1;

  for (i = 0; i < 10; i++) g[i] &= mask;

  mask = ~mask;

  for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];

  this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
  this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
  this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
  this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
  this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
  this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
  this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
  this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;

  for (i = 1; i < 8; i++) {
    f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
  mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
  mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
  mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
  mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
  mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
  mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
  mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
  mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
  mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
  mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
  mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
  mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
  mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
  mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
  mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
};

poly1305.prototype.update = function (m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = 16 - this.leftover;
    if (want > bytes) want = bytes;

    for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];

    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16) return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - bytes % 16;
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++) this.buffer[this.leftover + i] = m[mpos + i];

    this.leftover += bytes;
  }
};

module.exports = poly1305;

},{}],544:[function(require,module,exports){
(function (global){(function (){
/* eslint-disable camelcase */
function sodium_malloc(n) {
  return new Uint8Array(n);
}

function sodium_free(n) {
  sodium_memzero(n);
  loadSink().port1.postMessage(n.buffer, [n.buffer]);
}

function sodium_memzero(arr) {
  arr.fill(0);
}

var sink;

function loadSink() {
  if (sink) return sink;
  var MessageChannel = global.MessageChannel;
  if (MessageChannel == null) ({
    MessageChannel
  } = require('worker' + '_threads'));
  sink = new MessageChannel();
  return sink;
}

module.exports = {
  sodium_malloc,
  sodium_free,
  sodium_memzero
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],545:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],546:[function(require,module,exports){
(function (global){(function (){
var assert = require('nanoassert');

var randombytes = function () {
  var QUOTA = 65536; // limit for QuotaExceededException

  var crypto = global.crypto || global.msCrypto;

  function browserBytes(out, n) {
    for (let i = 0; i < n; i += QUOTA) {
      crypto.getRandomValues(new Uint8Array(out.buffer, i + out.byteOffset, Math.min(n - i, QUOTA)));
    }
  }

  function nodeBytes(out, n) {
    new Uint8Array(out.buffer, out.byteOffset, n).set(crypto.randomBytes(n));
  }

  function noImpl() {
    throw new Error('No secure random number generator available');
  }

  if (crypto && crypto.getRandomValues) return browserBytes;

  if (require != null) {
    // Node.js. Bust Browserify
    crypto = require('cry' + 'pto');
    if (crypto && crypto.randomBytes) return nodeBytes;
  }

  return noImpl;
}(); // Make non enumerable as this is an internal function


Object.defineProperty(module.exports, 'randombytes', {
  value: randombytes
});

module.exports.randombytes_buf = function (out) {
  assert(out, 'out must be given');
  randombytes(out, out.byteLength);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"nanoassert":545}],547:[function(require,module,exports){
(function (Buffer){(function (){
var pager = require('memory-pager');

module.exports = Bitfield;

function Bitfield(opts) {
  if (!(this instanceof Bitfield)) return new Bitfield(opts);
  if (!opts) opts = {};
  if (Buffer.isBuffer(opts)) opts = {
    buffer: opts
  };
  this.pageOffset = opts.pageOffset || 0;
  this.pageSize = opts.pageSize || 1024;
  this.pages = opts.pages || pager(this.pageSize);
  this.byteLength = this.pages.length * this.pageSize;
  this.length = 8 * this.byteLength;
  if (!powerOfTwo(this.pageSize)) throw new Error('The page size should be a power of two');
  this._trackUpdates = !!opts.trackUpdates;
  this._pageMask = this.pageSize - 1;

  if (opts.buffer) {
    for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
      this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
    }

    this.byteLength = opts.buffer.length;
    this.length = 8 * this.byteLength;
  }
}

Bitfield.prototype.get = function (i) {
  var o = i & 7;
  var j = (i - o) / 8;
  return !!(this.getByte(j) & 128 >> o);
};

Bitfield.prototype.getByte = function (i) {
  var o = i & this._pageMask;
  var j = (i - o) / this.pageSize;
  var page = this.pages.get(j, true);
  return page ? page.buffer[o + this.pageOffset] : 0;
};

Bitfield.prototype.set = function (i, v) {
  var o = i & 7;
  var j = (i - o) / 8;
  var b = this.getByte(j);
  return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
};

Bitfield.prototype.toBuffer = function () {
  var all = alloc(this.pages.length * this.pageSize);

  for (var i = 0; i < this.pages.length; i++) {
    var next = this.pages.get(i, true);
    var allOffset = i * this.pageSize;
    if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
  }

  return all;
};

Bitfield.prototype.setByte = function (i, b) {
  var o = i & this._pageMask;
  var j = (i - o) / this.pageSize;
  var page = this.pages.get(j, false);
  o += this.pageOffset;
  if (page.buffer[o] === b) return false;
  page.buffer[o] = b;

  if (i >= this.byteLength) {
    this.byteLength = i + 1;
    this.length = this.byteLength * 8;
  }

  if (this._trackUpdates) this.pages.updated(page);
  return true;
};

function alloc(n) {
  if (Buffer.alloc) return Buffer.alloc(n);
  var b = new Buffer(n);
  b.fill(0);
  return b;
}

function powerOfTwo(x) {
  return !(x & x - 1);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97,"memory-pager":308}],548:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = require('events').EventEmitter;

var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js'); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

},{"events":172,"inherits":279,"readable-stream/lib/_stream_duplex.js":550,"readable-stream/lib/_stream_passthrough.js":551,"readable-stream/lib/_stream_readable.js":552,"readable-stream/lib/_stream_transform.js":553,"readable-stream/lib/_stream_writable.js":554,"readable-stream/lib/internal/streams/end-of-stream.js":558,"readable-stream/lib/internal/streams/pipeline.js":560}],549:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],550:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_stream_readable":552,"./_stream_writable":554,"_process":380,"dup":77,"inherits":279}],551:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_stream_transform":553,"dup":78,"inherits":279}],552:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../util/util.js":579,"../errors":549,"./_stream_duplex":550,"./internal/streams/async_iterator":555,"./internal/streams/buffer_list":556,"./internal/streams/destroy":557,"./internal/streams/from":559,"./internal/streams/state":561,"./internal/streams/stream":562,"_process":380,"buffer":97,"dup":79,"events":172,"inherits":279,"string_decoder/":566}],553:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../errors":549,"./_stream_duplex":550,"dup":80,"inherits":279}],554:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../errors":549,"./_stream_duplex":550,"./internal/streams/destroy":557,"./internal/streams/state":561,"./internal/streams/stream":562,"_process":380,"buffer":97,"dup":81,"inherits":279,"util-deprecate":576}],555:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./end-of-stream":558,"_process":380,"dup":82}],556:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../../util/util.js":579,"buffer":97,"dup":83}],557:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"_process":380,"dup":84}],558:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../errors":549,"dup":85}],559:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86}],560:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../errors":549,"./end-of-stream":558,"dup":87}],561:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../errors":549,"dup":88}],562:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"dup":89,"events":172}],563:[function(require,module,exports){
var once = require('once');

module.exports = function (stream, cb) {
  if (!cb) return stream;
  var list = [];
  cb = once(cb);
  stream.on('data', function (data) {
    list.push(data);
  });
  stream.on('end', function () {
    cb(null, list);
  });
  stream.on('close', function () {
    cb(new Error('Premature close'));
  });
  stream.on('error', cb);
  return stream;
};

},{"once":358}],564:[function(require,module,exports){
module.exports = shift;

function shift(stream) {
  var rs = stream._readableState;
  if (!rs) return null;
  return rs.objectMode || typeof stream._duplexState === 'number' ? stream.read() : stream.read(getStateLength(rs));
}

function getStateLength(state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length;
    }

    return state.buffer[0].length;
  }

  return state.length;
}

},{}],565:[function(require,module,exports){
(function (process){(function (){
const {
  EventEmitter
} = require('events');

const STREAM_DESTROYED = new Error('Stream was destroyed');
const PREMATURE_CLOSE = new Error('Premature close');

const FIFO = require('fast-fifo');
/* eslint-disable no-multi-spaces */


const MAX = (1 << 25) - 1; // Shared state

const OPENING = 0b001;
const DESTROYING = 0b010;
const DESTROYED = 0b100;
const NOT_OPENING = MAX ^ OPENING; // Read state

const READ_ACTIVE = 0b0000000000001 << 3;
const READ_PRIMARY = 0b0000000000010 << 3;
const READ_SYNC = 0b0000000000100 << 3;
const READ_QUEUED = 0b0000000001000 << 3;
const READ_RESUMED = 0b0000000010000 << 3;
const READ_PIPE_DRAINED = 0b0000000100000 << 3;
const READ_ENDING = 0b0000001000000 << 3;
const READ_EMIT_DATA = 0b0000010000000 << 3;
const READ_EMIT_READABLE = 0b0000100000000 << 3;
const READ_EMITTED_READABLE = 0b0001000000000 << 3;
const READ_DONE = 0b0010000000000 << 3;
const READ_NEXT_TICK = 0b0100000000001 << 3; // also active

const READ_NEEDS_PUSH = 0b1000000000000 << 3;
const READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
const READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
const READ_NOT_SYNC = MAX ^ READ_SYNC;
const READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
const READ_PAUSED = MAX ^ READ_RESUMED;
const READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
const READ_NOT_ENDING = MAX ^ READ_ENDING;
const READ_PIPE_NOT_DRAINED = MAX ^ (READ_RESUMED | READ_PIPE_DRAINED);
const READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK; // Write state

const WRITE_ACTIVE = 0b000000001 << 16;
const WRITE_PRIMARY = 0b000000010 << 16;
const WRITE_SYNC = 0b000000100 << 16;
const WRITE_QUEUED = 0b000001000 << 16;
const WRITE_UNDRAINED = 0b000010000 << 16;
const WRITE_DONE = 0b000100000 << 16;
const WRITE_EMIT_DRAIN = 0b001000000 << 16;
const WRITE_NEXT_TICK = 0b010000001 << 16; // also active

const WRITE_FINISHING = 0b100000000 << 16;
const WRITE_NOT_ACTIVE = MAX ^ WRITE_ACTIVE;
const WRITE_NOT_SYNC = MAX ^ WRITE_SYNC;
const WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
const WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
const WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
const WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK; // Combined shared state

const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
const NOT_ACTIVE = MAX ^ ACTIVE;
const DONE = READ_DONE | WRITE_DONE;
const DESTROY_STATUS = DESTROYING | DESTROYED;
const OPEN_STATUS = DESTROY_STATUS | OPENING;
const AUTO_DESTROY = DESTROY_STATUS | DONE;
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
const TICKING = (WRITE_NEXT_TICK | READ_NEXT_TICK) & NOT_ACTIVE;
const ACTIVE_OR_TICKING = ACTIVE | TICKING;
const IS_OPENING = OPEN_STATUS | TICKING; // Combined read state

const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
const READ_ACTIVE_AND_SYNC = READ_ACTIVE | READ_SYNC;
const READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH = READ_ACTIVE | READ_SYNC | READ_NEEDS_PUSH;
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE; // Combined write state

const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
const WRITE_ACTIVE_AND_SYNC = WRITE_ACTIVE | WRITE_SYNC;
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED;
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');

class WritableState {
  constructor(stream, {
    highWaterMark = 16384,
    map = null,
    mapWritable,
    byteLength,
    byteLengthWritable
  } = {}) {
    this.stream = stream;
    this.queue = new FIFO();
    this.highWaterMark = highWaterMark;
    this.buffered = 0;
    this.error = null;
    this.pipeline = null;
    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
    this.map = mapWritable || map;
    this.afterWrite = afterWrite.bind(this);
  }

  get ended() {
    return (this.stream._duplexState & WRITE_DONE) !== 0;
  }

  push(data) {
    if (this.map !== null) data = this.map(data);
    this.buffered += this.byteLength(data);
    this.queue.push(data);

    if (this.buffered < this.highWaterMark) {
      this.stream._duplexState |= WRITE_QUEUED;
      return true;
    }

    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
    return false;
  }

  shift() {
    const data = this.queue.shift();
    const stream = this.stream;
    this.buffered -= this.byteLength(data);
    if (this.buffered === 0) stream._duplexState &= WRITE_NOT_QUEUED;
    return data;
  }

  end(data) {
    if (typeof data === 'function') this.stream.once('finish', data);else if (data !== undefined && data !== null) this.push(data);
    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
  }

  autoBatch(data, cb) {
    const buffer = [];
    const stream = this.stream;
    buffer.push(data);

    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
      buffer.push(stream._writableState.shift());
    }

    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);

    stream._writev(buffer, cb);
  }

  update() {
    const stream = this.stream;

    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
      const data = this.shift();
      stream._duplexState |= WRITE_ACTIVE_AND_SYNC;

      stream._write(data, this.afterWrite);

      stream._duplexState &= WRITE_NOT_SYNC;
    }

    if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
  }

  updateNonPrimary() {
    const stream = this.stream;

    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;

      stream._final(afterFinal.bind(this));

      return;
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE;

        stream._destroy(afterDestroy.bind(this));
      }

      return;
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;

      stream._open(afterOpen.bind(this));
    }
  }

  updateNextTick() {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
    this.stream._duplexState |= WRITE_NEXT_TICK;
    process.nextTick(updateWriteNT, this);
  }

}

class ReadableState {
  constructor(stream, {
    highWaterMark = 16384,
    map = null,
    mapReadable,
    byteLength,
    byteLengthReadable
  } = {}) {
    this.stream = stream;
    this.queue = new FIFO();
    this.highWaterMark = highWaterMark;
    this.buffered = 0;
    this.error = null;
    this.pipeline = null;
    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
    this.map = mapReadable || map;
    this.pipeTo = null;
    this.afterRead = afterRead.bind(this);
  }

  get ended() {
    return (this.stream._duplexState & READ_DONE) !== 0;
  }

  pipe(pipeTo, cb) {
    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.pipeTo = pipeTo;
    this.pipeline = new Pipeline(this.stream, pipeTo, cb || null);
    if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes

    if (isStreamx(pipeTo)) {
      pipeTo._writableState.pipeline = this.pipeline;
      if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes

      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself
    } else {
      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg

      pipeTo.on('error', onerror);
      pipeTo.on('close', onclose);
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));
    }

    pipeTo.on('drain', afterDrain.bind(this));
    this.stream.emit('piping', pipeTo);
    pipeTo.emit('pipe', this.stream);
  }

  push(data) {
    const stream = this.stream;

    if (data === null) {
      this.highWaterMark = 0;
      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
      return false;
    }

    if (this.map !== null) data = this.map(data);
    this.buffered += this.byteLength(data);
    this.queue.push(data);
    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
    return this.buffered < this.highWaterMark;
  }

  shift() {
    const data = this.queue.shift();
    this.buffered -= this.byteLength(data);
    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
    return data;
  }

  unshift(data) {
    let tail;
    const pending = [];

    while ((tail = this.queue.shift()) !== undefined) {
      pending.push(tail);
    }

    this.push(data);

    for (let i = 0; i < pending.length; i++) {
      this.queue.push(pending[i]);
    }
  }

  read() {
    const stream = this.stream;

    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
      const data = this.shift();
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
      return data;
    }

    return null;
  }

  drain() {
    const stream = this.stream;

    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
      const data = this.shift();
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
    }
  }

  update() {
    const stream = this.stream;
    this.drain();

    while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {
      stream._duplexState |= READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH;

      stream._read(this.afterRead);

      stream._duplexState &= READ_NOT_SYNC;
      if ((stream._duplexState & READ_ACTIVE) === 0) this.drain();
    }

    if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
      stream._duplexState |= READ_EMITTED_READABLE;
      stream.emit('readable');
    }

    if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
  }

  updateNonPrimary() {
    const stream = this.stream;

    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
      stream.emit('end');
      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
      if (this.pipeTo !== null) this.pipeTo.end();
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE;

        stream._destroy(afterDestroy.bind(this));
      }

      return;
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;

      stream._open(afterOpen.bind(this));
    }
  }

  updateNextTick() {
    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
    this.stream._duplexState |= READ_NEXT_TICK;
    process.nextTick(updateReadNT, this);
  }

}

class TransformState {
  constructor(stream) {
    this.data = null;
    this.afterTransform = afterTransform.bind(stream);
    this.afterFinal = null;
  }

}

class Pipeline {
  constructor(src, dst, cb) {
    this.from = src;
    this.to = dst;
    this.afterPipe = cb;
    this.error = null;
    this.pipeToFinished = false;
  }

  finished() {
    this.pipeToFinished = true;
  }

  done(stream, err) {
    if (err) this.error = err;

    if (stream === this.to) {
      this.to = null;

      if (this.from !== null) {
        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
          this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
        }

        return;
      }
    }

    if (stream === this.from) {
      this.from = null;

      if (this.to !== null) {
        if ((stream._duplexState & READ_DONE) === 0) {
          this.to.destroy(this.error || new Error('Readable stream closed before ending'));
        }

        return;
      }
    }

    if (this.afterPipe !== null) this.afterPipe(this.error);
    this.to = this.from = this.afterPipe = null;
  }

}

function afterDrain() {
  this.stream._duplexState |= READ_PIPE_DRAINED;
  if ((this.stream._duplexState & READ_ACTIVE_AND_SYNC) === 0) this.updateNextTick();
}

function afterFinal(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);

  if ((stream._duplexState & DESTROY_STATUS) === 0) {
    stream._duplexState |= WRITE_DONE;
    stream.emit('finish');
  }

  if ((stream._duplexState & AUTO_DESTROY) === DONE) {
    stream._duplexState |= DESTROYING;
  }

  stream._duplexState &= WRITE_NOT_ACTIVE;
  this.update();
}

function afterDestroy(err) {
  const stream = this.stream;
  if (!err && this.error !== STREAM_DESTROYED) err = this.error;
  if (err) stream.emit('error', err);
  stream._duplexState |= DESTROYED;
  stream.emit('close');
  const rs = stream._readableState;
  const ws = stream._writableState;
  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
  if (ws !== null && ws.pipeline !== null) ws.pipeline.done(stream, err);
}

function afterWrite(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);
  stream._duplexState &= WRITE_NOT_ACTIVE;

  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
    stream._duplexState &= WRITE_DRAINED;

    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
      stream.emit('drain');
    }
  }

  if ((stream._duplexState & WRITE_SYNC) === 0) this.update();
}

function afterRead(err) {
  if (err) this.stream.destroy(err);
  this.stream._duplexState &= READ_NOT_ACTIVE;
  if ((this.stream._duplexState & READ_SYNC) === 0) this.update();
}

function updateReadNT(rs) {
  rs.stream._duplexState &= READ_NOT_NEXT_TICK;
  rs.update();
}

function updateWriteNT(ws) {
  ws.stream._duplexState &= WRITE_NOT_NEXT_TICK;
  ws.update();
}

function afterOpen(err) {
  const stream = this.stream;
  if (err) stream.destroy(err);

  if ((stream._duplexState & DESTROYING) === 0) {
    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
    stream.emit('open');
  }

  stream._duplexState &= NOT_ACTIVE;

  if (stream._writableState !== null) {
    stream._writableState.update();
  }

  if (stream._readableState !== null) {
    stream._readableState.update();
  }
}

function afterTransform(err, data) {
  if (data !== undefined && data !== null) this.push(data);

  this._writableState.afterWrite(err);
}

class Stream extends EventEmitter {
  constructor(opts) {
    super();
    this._duplexState = 0;
    this._readableState = null;
    this._writableState = null;

    if (opts) {
      if (opts.open) this._open = opts.open;
      if (opts.destroy) this._destroy = opts.destroy;
      if (opts.predestroy) this._predestroy = opts.predestroy;

      if (opts.signal) {
        opts.signal.addEventListener('abort', abort.bind(this));
      }
    }
  }

  _open(cb) {
    cb(null);
  }

  _destroy(cb) {
    cb(null);
  }

  _predestroy() {// does nothing
  }

  get readable() {
    return this._readableState !== null ? true : undefined;
  }

  get writable() {
    return this._writableState !== null ? true : undefined;
  }

  get destroyed() {
    return (this._duplexState & DESTROYED) !== 0;
  }

  get destroying() {
    return (this._duplexState & DESTROY_STATUS) !== 0;
  }

  destroy(err) {
    if ((this._duplexState & DESTROY_STATUS) === 0) {
      if (!err) err = STREAM_DESTROYED;
      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;

      if (this._readableState !== null) {
        this._readableState.error = err;

        this._readableState.updateNextTick();
      }

      if (this._writableState !== null) {
        this._writableState.error = err;

        this._writableState.updateNextTick();
      }

      this._predestroy();
    }
  }

  on(name, fn) {
    if (this._readableState !== null) {
      if (name === 'data') {
        this._duplexState |= READ_EMIT_DATA | READ_RESUMED;

        this._readableState.updateNextTick();
      }

      if (name === 'readable') {
        this._duplexState |= READ_EMIT_READABLE;

        this._readableState.updateNextTick();
      }
    }

    if (this._writableState !== null) {
      if (name === 'drain') {
        this._duplexState |= WRITE_EMIT_DRAIN;

        this._writableState.updateNextTick();
      }
    }

    return super.on(name, fn);
  }

}

class Readable extends Stream {
  constructor(opts) {
    super(opts);
    this._duplexState |= OPENING | WRITE_DONE;
    this._readableState = new ReadableState(this, opts);

    if (opts) {
      if (opts.read) this._read = opts.read;
    }
  }

  _read(cb) {
    cb(null);
  }

  pipe(dest, cb) {
    this._readableState.pipe(dest, cb);

    this._readableState.updateNextTick();

    return dest;
  }

  read() {
    this._readableState.updateNextTick();

    return this._readableState.read();
  }

  push(data) {
    this._readableState.updateNextTick();

    return this._readableState.push(data);
  }

  unshift(data) {
    this._readableState.updateNextTick();

    return this._readableState.unshift(data);
  }

  resume() {
    this._duplexState |= READ_RESUMED;

    this._readableState.updateNextTick();

    return this;
  }

  pause() {
    this._duplexState &= READ_PAUSED;
    return this;
  }

  static _fromAsyncIterator(ite, opts) {
    let destroy;
    const rs = new Readable({ ...opts,

      read(cb) {
        ite.next().then(push).then(cb.bind(null, null)).catch(cb);
      },

      predestroy() {
        destroy = ite.return();
      },

      destroy(cb) {
        destroy.then(cb.bind(null, null)).catch(cb);
      }

    });
    return rs;

    function push(data) {
      if (data.done) rs.push(null);else rs.push(data.value);
    }
  }

  static from(data, opts) {
    if (isReadStreamx(data)) return data;
    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
    if (!Array.isArray(data)) data = data === undefined ? [] : [data];
    let i = 0;
    return new Readable({ ...opts,

      read(cb) {
        this.push(i === data.length ? null : data[i++]);
        cb(null);
      }

    });
  }

  static isBackpressured(rs) {
    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
  }

  static isPaused(rs) {
    return (rs._duplexState & READ_RESUMED) === 0;
  }

  [asyncIterator]() {
    const stream = this;
    let error = null;
    let promiseResolve = null;
    let promiseReject = null;
    this.on('error', err => {
      error = err;
    });
    this.on('readable', onreadable);
    this.on('close', onclose);
    return {
      [asyncIterator]() {
        return this;
      },

      next() {
        return new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
          const data = stream.read();
          if (data !== null) ondata(data);else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
        });
      },

      return() {
        return destroy(null);
      },

      throw(err) {
        return destroy(err);
      }

    };

    function onreadable() {
      if (promiseResolve !== null) ondata(stream.read());
    }

    function onclose() {
      if (promiseResolve !== null) ondata(null);
    }

    function ondata(data) {
      if (promiseReject === null) return;
      if (error) promiseReject(error);else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);else promiseResolve({
        value: data,
        done: data === null
      });
      promiseReject = promiseResolve = null;
    }

    function destroy(err) {
      stream.destroy(err);
      return new Promise((resolve, reject) => {
        if (stream._duplexState & DESTROYED) return resolve({
          value: undefined,
          done: true
        });
        stream.once('close', function () {
          if (err) reject(err);else resolve({
            value: undefined,
            done: true
          });
        });
      });
    }
  }

}

class Writable extends Stream {
  constructor(opts) {
    super(opts);
    this._duplexState |= OPENING | READ_DONE;
    this._writableState = new WritableState(this, opts);

    if (opts) {
      if (opts.writev) this._writev = opts.writev;
      if (opts.write) this._write = opts.write;
      if (opts.final) this._final = opts.final;
    }
  }

  _writev(batch, cb) {
    cb(null);
  }

  _write(data, cb) {
    this._writableState.autoBatch(data, cb);
  }

  _final(cb) {
    cb(null);
  }

  static isBackpressured(ws) {
    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
  }

  write(data) {
    this._writableState.updateNextTick();

    return this._writableState.push(data);
  }

  end(data) {
    this._writableState.updateNextTick();

    this._writableState.end(data);

    return this;
  }

}

class Duplex extends Readable {
  // and Writable
  constructor(opts) {
    super(opts);
    this._duplexState = OPENING;
    this._writableState = new WritableState(this, opts);

    if (opts) {
      if (opts.writev) this._writev = opts.writev;
      if (opts.write) this._write = opts.write;
      if (opts.final) this._final = opts.final;
    }
  }

  _writev(batch, cb) {
    cb(null);
  }

  _write(data, cb) {
    this._writableState.autoBatch(data, cb);
  }

  _final(cb) {
    cb(null);
  }

  write(data) {
    this._writableState.updateNextTick();

    return this._writableState.push(data);
  }

  end(data) {
    this._writableState.updateNextTick();

    this._writableState.end(data);

    return this;
  }

}

class Transform extends Duplex {
  constructor(opts) {
    super(opts);
    this._transformState = new TransformState(this);

    if (opts) {
      if (opts.transform) this._transform = opts.transform;
      if (opts.flush) this._flush = opts.flush;
    }
  }

  _write(data, cb) {
    if (this._readableState.buffered >= this._readableState.highWaterMark) {
      this._transformState.data = data;
    } else {
      this._transform(data, this._transformState.afterTransform);
    }
  }

  _read(cb) {
    if (this._transformState.data !== null) {
      const data = this._transformState.data;
      this._transformState.data = null;
      cb(null);

      this._transform(data, this._transformState.afterTransform);
    } else {
      cb(null);
    }
  }

  _transform(data, cb) {
    cb(null, data);
  }

  _flush(cb) {
    cb(null);
  }

  _final(cb) {
    this._transformState.afterFinal = cb;

    this._flush(transformAfterFlush.bind(this));
  }

}

class PassThrough extends Transform {}

function transformAfterFlush(err, data) {
  const cb = this._transformState.afterFinal;
  if (err) return cb(err);
  if (data !== null && data !== undefined) this.push(data);
  this.push(null);
  cb(null);
}

function pipelinePromise(...streams) {
  return new Promise((resolve, reject) => {
    return pipeline(...streams, err => {
      if (err) return reject(err);
      resolve();
    });
  });
}

function pipeline(stream, ...streams) {
  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
  const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;
  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');
  let src = all[0];
  let dest = null;
  let error = null;

  for (let i = 1; i < all.length; i++) {
    dest = all[i];

    if (isStreamx(src)) {
      src.pipe(dest, onerror);
    } else {
      errorHandle(src, true, i > 1, onerror);
      src.pipe(dest);
    }

    src = dest;
  }

  if (done) {
    let fin = false;
    dest.on('finish', () => {
      fin = true;
    });
    dest.on('error', err => {
      error = error || err;
    });
    dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));
  }

  return dest;

  function errorHandle(s, rd, wr, onerror) {
    s.on('error', onerror);
    s.on('close', onclose);

    function onclose() {
      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);
      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);
    }
  }

  function onerror(err) {
    if (!err || error) return;
    error = err;

    for (const s of all) {
      s.destroy(err);
    }
  }
}

function isStream(stream) {
  return !!stream._readableState || !!stream._writableState;
}

function isStreamx(stream) {
  return typeof stream._duplexState === 'number' && isStream(stream);
}

function isReadStreamx(stream) {
  return isStreamx(stream) && stream.readable;
}

function isTypedArray(data) {
  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';
}

function defaultByteLength(data) {
  return isTypedArray(data) ? data.byteLength : 1024;
}

function noop() {}

function abort() {
  this.destroy(new Error('Stream aborted.'));
}

module.exports = {
  pipeline,
  pipelinePromise,
  isStream,
  isStreamx,
  Stream,
  Writable,
  Readable,
  Duplex,
  Transform,
  // Export PassThrough for compatibility with Node.js core's stream module
  PassThrough
};

}).call(this)}).call(this,require('_process'))
},{"_process":380,"events":172,"fast-fifo":176}],566:[function(require,module,exports){
arguments[4][439][0].apply(exports,arguments)
},{"dup":439,"safe-buffer":446}],567:[function(require,module,exports){
(function (process){(function (){
module.exports = class ThunkyMap {
  constructor(load) {
    this.loading = new Map();
    this.cache = new Map();
    this.load = load;
  }

  get(key, cb) {
    const v = this.cache.get(key);
    if (v !== undefined) return process.nextTick(cb, null, v);

    if (this.loading.has(key)) {
      this.loading.get(key).push(cb);
      return;
    }

    const queue = [cb];
    this.loading.set(key, queue);

    this._load(key, queue);
  }

  has(key) {
    return this.cache.has(key) || this.loading.has(key);
  }

  delete(key) {
    this.loading.delete(key);
    this.cache.delete(key);
  }

  _load(key, queue) {
    this.load(key, (err, val) => {
      const stored = this.loading.get(key);
      if (stored === queue) this.loading.delete(key);else if (!err) err = new Error('Deleted');
      if (!err) this.cache.set(key, val);

      for (const cb of queue) cb(err, val);
    });
  }

};

}).call(this)}).call(this,require('_process'))
},{"_process":380}],568:[function(require,module,exports){
(function (process){(function (){
'use strict';

var nextTick = nextTickArgs;
process.nextTick(upgrade, 42); // pass 42 and see if upgrade is called with it

module.exports = thunky;

function thunky(fn) {
  var state = run;
  return thunk;

  function thunk(callback) {
    state(callback || noop);
  }

  function run(callback) {
    var stack = [callback];
    state = wait;
    fn(done);

    function wait(callback) {
      stack.push(callback);
    }

    function done(err) {
      var args = arguments;
      state = isError(err) ? run : finished;

      while (stack.length) finished(stack.shift());

      function finished(callback) {
        nextTick(apply, callback, args);
      }
    }
  }
}

function isError(err) {
  // inlined from util so this works in the browser
  return Object.prototype.toString.call(err) === '[object Error]';
}

function noop() {}

function apply(callback, args) {
  callback.apply(null, args);
}

function upgrade(val) {
  if (val === 42) nextTick = process.nextTick;
}

function nextTickArgs(fn, a, b) {
  process.nextTick(function () {
    fn(a, b);
  });
}

}).call(this)}).call(this,require('_process'))
},{"_process":380}],569:[function(require,module,exports){
module.exports = TimeOrderedSet;

function TimeOrderedSet() {
  if (!(this instanceof TimeOrderedSet)) return new TimeOrderedSet();
  this.oldest = null;
  this.latest = null;
  this.length = 0;
}

TimeOrderedSet.prototype.has = function (node) {
  return !!(node.next || node.prev) || node === this.oldest;
};

TimeOrderedSet.prototype.add = function (node) {
  if (this.has(node)) this.remove(node);

  if (!this.latest && !this.oldest) {
    this.latest = this.oldest = node;
    node.prev = node.next = null;
  } else {
    this.latest.next = node;
    node.prev = this.latest;
    node.next = null;
    this.latest = node;
  }

  this.length++;
  return node;
};

TimeOrderedSet.prototype.remove = function (node) {
  if (!this.has(node)) return node;

  if (this.oldest !== node && this.latest !== node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else {
    if (this.oldest === node) {
      this.oldest = node.next;
      if (this.oldest) this.oldest.prev = null;
    }

    if (this.latest === node) {
      this.latest = node.prev;
      if (this.latest) this.latest.next = null;
    }
  }

  node.next = node.prev = null;
  this.length--;
  return node;
};

TimeOrderedSet.prototype.toArray = function (pick) {
  if (!pick) pick = Infinity;
  var list = [];
  var node = this.oldest;

  while (node && pick--) {
    list.push(node);
    node = node.next;
  }

  return list;
};

},{}],570:[function(require,module,exports){
module.exports = Timeout;

function Timeout(ms, fn, ctx) {
  if (!(this instanceof Timeout)) return new Timeout(ms, fn, ctx);
  this.ms = ms;
  this.ontimeout = fn;
  this.context = ctx || null;
  this.called = false;
  this._timeout = setTimeout(call, ms, this);
}

Timeout.prototype.refresh = function () {
  if (this.called || this.ontimeout === null) return;
  clearTimeout(this._timeout);
  this._timeout = setTimeout(call, this.ms, this);
};

Timeout.prototype.destroy = function () {
  this.ontimeout = null;
  clearTimeout(this._timeout);
};

function call(self) {
  self.called = true;
  self.ontimeout.call(self.context);
}

},{}],571:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;

var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  timeout.close();
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // That's not how node.js implements it but the exposed api is the same.


exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
  immediateIds[id] = true;
  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      } // Prevent ids from leaking


      exports.clearImmediate(id);
    }
  });
  return id;
};
exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
  delete immediateIds[id];
};

}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":380,"timers":571}],572:[function(require,module,exports){
var bufferAlloc = require('buffer-alloc');

var UINT_32_MAX = Math.pow(2, 32);

exports.encodingLength = function () {
  return 8;
};

exports.encode = function (num, buf, offset) {
  if (!buf) buf = bufferAlloc(8);
  if (!offset) offset = 0;
  var top = Math.floor(num / UINT_32_MAX);
  var rem = num - top * UINT_32_MAX;
  buf.writeUInt32BE(top, offset);
  buf.writeUInt32BE(rem, offset + 4);
  return buf;
};

exports.decode = function (buf, offset) {
  if (!offset) offset = 0;
  var top = buf.readUInt32BE(offset);
  var rem = buf.readUInt32BE(offset + 4);
  return top * UINT_32_MAX + rem;
};

exports.encode.bytes = 8;
exports.decode.bytes = 8;

},{"buffer-alloc":93}],573:[function(require,module,exports){
/*!
 * unixify <https://github.com/jonschlinkert/unixify>
 *
 * Copyright (c) 2014, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
'use strict';

var normalizePath = require('normalize-path');

module.exports = function unixify(filepath, stripTrailing) {
  filepath = normalizePath(filepath, stripTrailing);
  return filepath.replace(/^([a-zA-Z]+:|\.\/)/, '');
};

},{"normalize-path":356}],574:[function(require,module,exports){
module.exports = remove;

function remove(arr, i) {
  if (i >= arr.length || i < 0) return;
  var last = arr.pop();

  if (i < arr.length) {
    var tmp = arr[i];
    arr[i] = last;
    return tmp;
  }

  return last;
}

},{}],575:[function(require,module,exports){
exports.add = add;
exports.has = has;
exports.remove = remove;
exports.swap = swap;

function add(list, item) {
  if (has(list, item)) return item;
  item._index = list.length;
  list.push(item);
  return item;
}

function has(list, item) {
  return item._index < list.length && list[item._index] === item;
}

function remove(list, item) {
  if (!has(list, item)) return null;
  var last = list.pop();

  if (last !== item) {
    list[item._index] = last;
    last._index = item._index;
  }

  return item;
}

function swap(list, a, b) {
  if (!has(list, a) || !has(list, b)) return;
  var tmp = a._index;
  a._index = b._index;
  list[a._index] = a;
  b._index = tmp;
  list[b._index] = b;
}

},{}],576:[function(require,module,exports){
(function (global){(function (){
/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],577:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],578:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
'use strict';

var isArgumentsObject = require('is-arguments');

var isGeneratorFunction = require('is-generator-function');

var whichTypedArray = require('which-typed-array');

var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }

  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray; // Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js

function isPromise(input) {
  return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}

exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return isTypedArray(value) || isDataView(value);
}

exports.isArrayBufferView = isArrayBufferView;

function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}

exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}

exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}

exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}

exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}

exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}

exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}

exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}

exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}

exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}

exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}

exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}

isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working ? isMapToString(value) : value instanceof Map;
}

exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}

isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());

function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working ? isSetToString(value) : value instanceof Set;
}

exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}

isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());

function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}

exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}

isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());

function isWeakSet(value) {
  return isWeakSetToString(value);
}

exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}

isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());

function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}

exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}

isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}

exports.isDataView = isDataView;

function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}

isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== 'undefined' && isSharedArrayBufferToString(new SharedArrayBuffer());

function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
}

exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}

exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}

exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}

exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}

exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}

exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}

exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}

exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}

exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}

exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}

exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}

exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}

exports.isAnyArrayBuffer = isAnyArrayBuffer;
['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function () {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":281,"is-generator-function":283,"is-typed-array":285,"which-typed-array":587}],579:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}

exports.debuglog = function (set) {
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


exports.types = require("./support/types");

function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require("./support/isBuffer");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function (rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))
},{"./support/isBuffer":577,"./support/types":578,"_process":380,"inherits":279}],580:[function(require,module,exports){
arguments[4][383][0].apply(exports,arguments)
},{"dup":383}],581:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],582:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./decode.js":580,"./encode.js":581,"./length.js":583,"dup":40}],583:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],584:[function(require,module,exports){
arguments[4][438][0].apply(exports,arguments)
},{"buffer":97,"dup":438}],585:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var Transform = require('readable-stream').Transform;

var duplexify = require('duplexify');

var WS = require('ws');

var Buffer = require('safe-buffer').Buffer;

module.exports = WebSocketStream;

function buildProxy(options, socketWrite, socketEnd) {
  var proxy = new Transform({
    objectMode: options.objectMode
  });
  proxy._write = socketWrite;
  proxy._flush = socketEnd;
  return proxy;
}

function WebSocketStream(target, protocols, options) {
  var stream, socket;
  var isBrowser = process.title === 'browser';
  var isNative = !!global.WebSocket;
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;

  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols;
    protocols = null;

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {};

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined);
  }

  var proxy = buildProxy(options, socketWrite, socketEnd);

  if (!options.objectMode) {
    proxy._writev = writev;
  } // browser only: sets the maximum socket buffer size before throttling


  var bufferSize = options.browserBufferSize || 1024 * 512; // browser only: how long to wait when throttling

  var bufferTimeout = options.browserBufferTimeout || 1000; // use existing WebSocket object that was passed in

  if (typeof target === 'object') {
    socket = target; // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative && isBrowser) {
      socket = new WS(target, protocols);
    } else {
      socket = new WS(target, protocols, options);
    }

    socket.binaryType = 'arraybuffer';
  } // according to https://github.com/baygeldin/ws-streamify/issues/1
  // Nodejs WebSocketServer cause memory leak
  // Handlers like onerror, onclose, onmessage and onopen are accessible via setter/getter
  // And setter first of all fires removeAllListeners, that doesnt make inner array of clients on WebSocketServer cleared ever


  var eventListenerSupport = 'undefined' === typeof socket.addEventListener; // was already open when passed in

  if (socket.readyState === socket.OPEN) {
    stream = proxy;
  } else {
    stream = stream = duplexify(undefined, undefined, options);

    if (!options.objectMode) {
      stream._writev = writev;
    }

    if (eventListenerSupport) {
      socket.addEventListener('open', onopen);
    } else {
      socket.onopen = onopen;
    }
  }

  stream.socket = socket;

  if (eventListenerSupport) {
    socket.addEventListener('close', onclose);
    socket.addEventListener('error', onerror);
    socket.addEventListener('message', onmessage);
  } else {
    socket.onclose = onclose;
    socket.onerror = onerror;
    socket.onmessage = onmessage;
  }

  proxy.on('close', destroy);
  var coerceToBuffer = !options.objectMode;

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== socket.OPEN) {
      next();
      return;
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8');
    }

    socket.send(chunk, next);
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount > bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
      return;
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8');
    }

    try {
      socket.send(chunk);
    } catch (err) {
      return next(err);
    }

    next();
  }

  function socketEnd(done) {
    socket.close();
    done();
  }

  function onopen() {
    stream.setReadable(proxy);
    stream.setWritable(proxy);
    stream.emit('connect');
  }

  function onclose() {
    stream.end();
    stream.destroy();
  }

  function onerror(err) {
    stream.destroy(err);
  }

  function onmessage(event) {
    var data = event.data;
    if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');
    proxy.push(data);
  }

  function destroy() {
    socket.close();
  } // this is to be enabled only if objectMode is false


  function writev(chunks, cb) {
    var buffers = new Array(chunks.length);

    for (var i = 0; i < chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8');
      } else {
        buffers[i] = chunks[i].chunk;
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb);
  }

  return stream;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":380,"duplexify":147,"readable-stream":440,"safe-buffer":584,"ws":586}],586:[function(require,module,exports){
var ws = null;

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket;
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket;
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket;
}

module.exports = ws;

},{}],587:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');

var availableTypedArrays = require('available-typed-arrays');

var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var hasSymbols = require('has-symbols')();

var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {};

var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');

var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    if (typeof global[typedArray] === 'function') {
      var arr = new global[typedArray]();

      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
      }

      var proto = getPrototypeOf(arr);
      var descriptor = gOPD(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }

      toStrTags[typedArray] = descriptor.get;
    }
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);

        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }

  if (!hasToStringTag) {
    return $slice($toString(value), 8, -1);
  }

  return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":35,"call-bind/callBound":111,"es-abstract/helpers/getOwnPropertyDescriptor":170,"foreach":181,"has-symbols":186,"is-typed-array":285}],588:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;

function wrappy(fn, cb) {
  if (fn && cb) return wrappy(fn)(cb);
  if (typeof fn !== 'function') throw new TypeError('need wrapper function');
  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });
  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];

    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }

    return ret;
  }
}

},{}],589:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = dist;

function dist(a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length');
  var result = Buffer.allocUnsafe(a.length);

  for (var i = 0; i < a.length; i++) result[i] = a[i] ^ b[i];

  return result;
}

dist.compare = function compare(a, b) {
  if (a.length !== b.length) throw new Error('Inputs should have the same length');

  for (var i = 0; i < a.length; i++) {
    if (a[i] === b[i]) continue;
    return a[i] < b[i] ? -1 : 1;
  }

  return 0;
};

dist.gt = function gt(a, b) {
  return dist.compare(a, b) === 1;
};

dist.lt = function lt(a, b) {
  return dist.compare(a, b) === -1;
};

dist.eq = function eq(a, b) {
  return dist.compare(a, b) === 0;
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":97}],590:[function(require,module,exports){
const xsalsa20 = require('xsalsa20');

module.exports = class XORJS {
  constructor(nonce, key) {
    this.instance = xsalsa20(nonce, key);
  }

  update(out, message) {
    this.instance.update(message, out);
  }

  final() {
    this.instance.finalize();
  }

};

},{"xsalsa20":591}],591:[function(require,module,exports){
var xsalsa20 = require("./xsalsa20")();

var SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
var head = 144;
var top = head;
var free = [];
module.exports = XSalsa20;
XSalsa20.NONCEBYTES = 24;
XSalsa20.KEYBYTES = 32;
XSalsa20.core_hsalsa20 = core_hsalsa20;
XSalsa20.SIGMA = SIGMA;

function XSalsa20(nonce, key) {
  if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key);
  if (!nonce || nonce.length < 24) throw new Error('nonce must be at least 24 bytes');
  if (!key || key.length < 32) throw new Error('key must be at least 32 bytes');
  this._xor = xsalsa20 && xsalsa20.exports ? new WASM(nonce, key) : new Fallback(nonce, key);
}

XSalsa20.prototype.update = function (input, output) {
  if (!input) throw new Error('input must be Uint8Array or Buffer');
  if (!output) output = new Uint8Array(input.length);
  if (input.length) this._xor.update(input, output);
  return output;
};

XSalsa20.prototype.final = XSalsa20.prototype.finalize = function () {
  this._xor.finalize();

  this._xor = null;
};

function WASM(nonce, key) {
  if (!free.length) {
    free.push(head);
    head += 64;
  }

  this._pointer = free.pop();
  this._nonce = this._pointer + 8;
  this._key = this._nonce + 24;
  this._overflow = 0;
  xsalsa20.memory.fill(0, this._pointer, this._pointer + 8);
  xsalsa20.memory.set(nonce, this._nonce);
  xsalsa20.memory.set(key, this._key);
}

WASM.prototype.update = function (input, output) {
  var len = this._overflow + input.length;
  var start = head + this._overflow;
  top = head + len;
  if (top >= xsalsa20.memory.length) xsalsa20.realloc(top);
  xsalsa20.memory.set(input, start);
  xsalsa20.exports.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key);
  output.set(xsalsa20.memory.subarray(start, head + len));
  this._overflow = len & 63;
};

WASM.prototype.finalize = function () {
  xsalsa20.memory.fill(0, this._pointer, this._key + 32);

  if (top > head) {
    xsalsa20.memory.fill(0, head, top);
    top = 0;
  }

  free.push(this._pointer);
};

function Fallback(nonce, key) {
  this._s = new Uint8Array(32);
  this._z = new Uint8Array(16);
  this._overflow = 0;
  core_hsalsa20(this._s, nonce, key, SIGMA);

  for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16];
}

Fallback.prototype.update = function (input, output) {
  var x = new Uint8Array(64);
  var u = 0;
  var i = this._overflow;
  var b = input.length + this._overflow;
  var z = this._z;
  var mpos = -this._overflow;
  var cpos = -this._overflow;

  while (b >= 64) {
    core_salsa20(x, z, this._s, SIGMA);

    for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i];

    u = 1;

    for (i = 8; i < 16; i++) {
      u += z[i] & 0xff | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }

    b -= 64;
    cpos += 64;
    mpos += 64;
    i = 0;
  }

  if (b > 0) {
    core_salsa20(x, z, this._s, SIGMA);

    for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i];
  }

  this._overflow = b & 63;
};

Fallback.prototype.finalize = function () {
  this._s.fill(0);

  this._z.fill(0);
}; // below methods are ported from tweet nacl


function core_salsa20(o, p, k, c) {
  var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
      j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
      j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
      j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
      j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
      j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
      j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
      j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
      j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
      j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
      j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
  var x0 = j0,
      x1 = j1,
      x2 = j2,
      x3 = j3,
      x4 = j4,
      x5 = j5,
      x6 = j6,
      x7 = j7,
      x8 = j8,
      x9 = j9,
      x10 = j10,
      x11 = j11,
      x12 = j12,
      x13 = j13,
      x14 = j14,
      x15 = j15,
      u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u << 7 | u >>> 25;
    u = x4 + x0 | 0;
    x8 ^= u << 9 | u >>> 23;
    u = x8 + x4 | 0;
    x12 ^= u << 13 | u >>> 19;
    u = x12 + x8 | 0;
    x0 ^= u << 18 | u >>> 14;
    u = x5 + x1 | 0;
    x9 ^= u << 7 | u >>> 25;
    u = x9 + x5 | 0;
    x13 ^= u << 9 | u >>> 23;
    u = x13 + x9 | 0;
    x1 ^= u << 13 | u >>> 19;
    u = x1 + x13 | 0;
    x5 ^= u << 18 | u >>> 14;
    u = x10 + x6 | 0;
    x14 ^= u << 7 | u >>> 25;
    u = x14 + x10 | 0;
    x2 ^= u << 9 | u >>> 23;
    u = x2 + x14 | 0;
    x6 ^= u << 13 | u >>> 19;
    u = x6 + x2 | 0;
    x10 ^= u << 18 | u >>> 14;
    u = x15 + x11 | 0;
    x3 ^= u << 7 | u >>> 25;
    u = x3 + x15 | 0;
    x7 ^= u << 9 | u >>> 23;
    u = x7 + x3 | 0;
    x11 ^= u << 13 | u >>> 19;
    u = x11 + x7 | 0;
    x15 ^= u << 18 | u >>> 14;
    u = x0 + x3 | 0;
    x1 ^= u << 7 | u >>> 25;
    u = x1 + x0 | 0;
    x2 ^= u << 9 | u >>> 23;
    u = x2 + x1 | 0;
    x3 ^= u << 13 | u >>> 19;
    u = x3 + x2 | 0;
    x0 ^= u << 18 | u >>> 14;
    u = x5 + x4 | 0;
    x6 ^= u << 7 | u >>> 25;
    u = x6 + x5 | 0;
    x7 ^= u << 9 | u >>> 23;
    u = x7 + x6 | 0;
    x4 ^= u << 13 | u >>> 19;
    u = x4 + x7 | 0;
    x5 ^= u << 18 | u >>> 14;
    u = x10 + x9 | 0;
    x11 ^= u << 7 | u >>> 25;
    u = x11 + x10 | 0;
    x8 ^= u << 9 | u >>> 23;
    u = x8 + x11 | 0;
    x9 ^= u << 13 | u >>> 19;
    u = x9 + x8 | 0;
    x10 ^= u << 18 | u >>> 14;
    u = x15 + x14 | 0;
    x12 ^= u << 7 | u >>> 25;
    u = x12 + x15 | 0;
    x13 ^= u << 9 | u >>> 23;
    u = x13 + x12 | 0;
    x14 ^= u << 13 | u >>> 19;
    u = x14 + x13 | 0;
    x15 ^= u << 18 | u >>> 14;
  }

  x0 = x0 + j0 | 0;
  x1 = x1 + j1 | 0;
  x2 = x2 + j2 | 0;
  x3 = x3 + j3 | 0;
  x4 = x4 + j4 | 0;
  x5 = x5 + j5 | 0;
  x6 = x6 + j6 | 0;
  x7 = x7 + j7 | 0;
  x8 = x8 + j8 | 0;
  x9 = x9 + j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;
  o[0] = x0 >>> 0 & 0xff;
  o[1] = x0 >>> 8 & 0xff;
  o[2] = x0 >>> 16 & 0xff;
  o[3] = x0 >>> 24 & 0xff;
  o[4] = x1 >>> 0 & 0xff;
  o[5] = x1 >>> 8 & 0xff;
  o[6] = x1 >>> 16 & 0xff;
  o[7] = x1 >>> 24 & 0xff;
  o[8] = x2 >>> 0 & 0xff;
  o[9] = x2 >>> 8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;
  o[12] = x3 >>> 0 & 0xff;
  o[13] = x3 >>> 8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;
  o[16] = x4 >>> 0 & 0xff;
  o[17] = x4 >>> 8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;
  o[20] = x5 >>> 0 & 0xff;
  o[21] = x5 >>> 8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;
  o[24] = x6 >>> 0 & 0xff;
  o[25] = x6 >>> 8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;
  o[28] = x7 >>> 0 & 0xff;
  o[29] = x7 >>> 8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;
  o[32] = x8 >>> 0 & 0xff;
  o[33] = x8 >>> 8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;
  o[36] = x9 >>> 0 & 0xff;
  o[37] = x9 >>> 8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;
  o[40] = x10 >>> 0 & 0xff;
  o[41] = x10 >>> 8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;
  o[44] = x11 >>> 0 & 0xff;
  o[45] = x11 >>> 8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;
  o[48] = x12 >>> 0 & 0xff;
  o[49] = x12 >>> 8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;
  o[52] = x13 >>> 0 & 0xff;
  o[53] = x13 >>> 8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;
  o[56] = x14 >>> 0 & 0xff;
  o[57] = x14 >>> 8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;
  o[60] = x15 >>> 0 & 0xff;
  o[61] = x15 >>> 8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o, p, k, c) {
  var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
      j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
      j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
      j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
      j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
      j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
      j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
      j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
      j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
      j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
      j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
  var x0 = j0,
      x1 = j1,
      x2 = j2,
      x3 = j3,
      x4 = j4,
      x5 = j5,
      x6 = j6,
      x7 = j7,
      x8 = j8,
      x9 = j9,
      x10 = j10,
      x11 = j11,
      x12 = j12,
      x13 = j13,
      x14 = j14,
      x15 = j15,
      u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u << 7 | u >>> 25;
    u = x4 + x0 | 0;
    x8 ^= u << 9 | u >>> 23;
    u = x8 + x4 | 0;
    x12 ^= u << 13 | u >>> 19;
    u = x12 + x8 | 0;
    x0 ^= u << 18 | u >>> 14;
    u = x5 + x1 | 0;
    x9 ^= u << 7 | u >>> 25;
    u = x9 + x5 | 0;
    x13 ^= u << 9 | u >>> 23;
    u = x13 + x9 | 0;
    x1 ^= u << 13 | u >>> 19;
    u = x1 + x13 | 0;
    x5 ^= u << 18 | u >>> 14;
    u = x10 + x6 | 0;
    x14 ^= u << 7 | u >>> 25;
    u = x14 + x10 | 0;
    x2 ^= u << 9 | u >>> 23;
    u = x2 + x14 | 0;
    x6 ^= u << 13 | u >>> 19;
    u = x6 + x2 | 0;
    x10 ^= u << 18 | u >>> 14;
    u = x15 + x11 | 0;
    x3 ^= u << 7 | u >>> 25;
    u = x3 + x15 | 0;
    x7 ^= u << 9 | u >>> 23;
    u = x7 + x3 | 0;
    x11 ^= u << 13 | u >>> 19;
    u = x11 + x7 | 0;
    x15 ^= u << 18 | u >>> 14;
    u = x0 + x3 | 0;
    x1 ^= u << 7 | u >>> 25;
    u = x1 + x0 | 0;
    x2 ^= u << 9 | u >>> 23;
    u = x2 + x1 | 0;
    x3 ^= u << 13 | u >>> 19;
    u = x3 + x2 | 0;
    x0 ^= u << 18 | u >>> 14;
    u = x5 + x4 | 0;
    x6 ^= u << 7 | u >>> 25;
    u = x6 + x5 | 0;
    x7 ^= u << 9 | u >>> 23;
    u = x7 + x6 | 0;
    x4 ^= u << 13 | u >>> 19;
    u = x4 + x7 | 0;
    x5 ^= u << 18 | u >>> 14;
    u = x10 + x9 | 0;
    x11 ^= u << 7 | u >>> 25;
    u = x11 + x10 | 0;
    x8 ^= u << 9 | u >>> 23;
    u = x8 + x11 | 0;
    x9 ^= u << 13 | u >>> 19;
    u = x9 + x8 | 0;
    x10 ^= u << 18 | u >>> 14;
    u = x15 + x14 | 0;
    x12 ^= u << 7 | u >>> 25;
    u = x12 + x15 | 0;
    x13 ^= u << 9 | u >>> 23;
    u = x13 + x12 | 0;
    x14 ^= u << 13 | u >>> 19;
    u = x14 + x13 | 0;
    x15 ^= u << 18 | u >>> 14;
  }

  o[0] = x0 >>> 0 & 0xff;
  o[1] = x0 >>> 8 & 0xff;
  o[2] = x0 >>> 16 & 0xff;
  o[3] = x0 >>> 24 & 0xff;
  o[4] = x5 >>> 0 & 0xff;
  o[5] = x5 >>> 8 & 0xff;
  o[6] = x5 >>> 16 & 0xff;
  o[7] = x5 >>> 24 & 0xff;
  o[8] = x10 >>> 0 & 0xff;
  o[9] = x10 >>> 8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;
  o[12] = x15 >>> 0 & 0xff;
  o[13] = x15 >>> 8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;
  o[16] = x6 >>> 0 & 0xff;
  o[17] = x6 >>> 8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;
  o[20] = x7 >>> 0 & 0xff;
  o[21] = x7 >>> 8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;
  o[24] = x8 >>> 0 & 0xff;
  o[25] = x8 >>> 8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;
  o[28] = x9 >>> 0 & 0xff;
  o[29] = x9 >>> 8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

},{"./xsalsa20":592}],592:[function(require,module,exports){
module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null)).catch(cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new (require('buf' + 'fer').Buffer)(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

},{}],593:[function(require,module,exports){
class Node {
  /// value;
  /// next;
  constructor(value) {
    this.value = value; // TODO: Remove this when targeting Node.js 12.

    this.next = undefined;
  }

}

class Queue {
  // TODO: Use private class fields when targeting Node.js 12.
  // #_head;
  // #_tail;
  // #_size;
  constructor() {
    this.clear();
  }

  enqueue(value) {
    const node = new Node(value);

    if (this._head) {
      this._tail.next = node;
      this._tail = node;
    } else {
      this._head = node;
      this._tail = node;
    }

    this._size++;
  }

  dequeue() {
    const current = this._head;

    if (!current) {
      return;
    }

    this._head = this._head.next;
    this._size--;
    return current.value;
  }

  clear() {
    this._head = undefined;
    this._tail = undefined;
    this._size = 0;
  }

  get size() {
    return this._size;
  }

  *[Symbol.iterator]() {
    let current = this._head;

    while (current) {
      yield current.value;
      current = current.next;
    }
  }

}

module.exports = Queue;

},{}],594:[function(require,module,exports){
const path = require('path'); // This is a dirty hack for browserify to work. ðŸ˜…


if (!path.posix) path.posix = path;

const DatEncoding = require('dat-encoding');

const datDNS = require("./dns-web.js");

const hyperdrive = require('hyperdrive');

const makeHypercorePromise = require('@geut/hypercore-promise');

const makeHyperdrivePromise = require('@geut/hyperdrive-promise');

const DEFAULT_DRIVE_OPTS = {
  sparse: true,
  persist: true
};
const DEFAULT_CORE_OPTS = {
  sparse: true,
  persist: true
};
const DEFAULT_DNS_OPTS = {};
const DEFAULT_APPLICATION_NAME = 'dat-sdk';
const CLOSE_FN = Symbol('close');
const HANDLE_COUNT = Symbol('closeCount');
module.exports = SDK;
module.exports.DEFAULT_APPLICATION_NAME = DEFAULT_APPLICATION_NAME; // TODO: Set up Promise API based on Beaker https://github.com/beakerbrowser/beaker/blob/blue-hyperdrive10/app/bg/web-apis/fg/hyperdrive.js

async function SDK(opts = {}) {
  if (!opts.backend) throw new Error('No backend was passed in');

  if (!opts.applicationName) {
    opts.applicationName = DEFAULT_APPLICATION_NAME;
  }

  if (opts.persist === undefined) {
    opts.persist = true;
  }

  const {
    backend,
    driveOpts,
    coreOpts,
    dnsOpts
  } = opts;
  const dns = datDNS(Object.assign({}, DEFAULT_DNS_OPTS, dnsOpts));
  const handlers = await backend(opts);
  const {
    storage,
    corestore,
    swarm,
    deriveSecret,
    keyPair
  } = handlers;
  await corestore.ready();
  const drives = new Map();
  const cores = new Map();
  return {
    Hyperdrive,
    Hypercore,
    resolveName,
    getIdentity,
    deriveSecret,
    registerExtension,
    close,

    get keyPair() {
      return keyPair;
    },

    _storage: storage,
    _corestore: corestore,
    _swarm: swarm,
    _dns: dns
  };

  function getIdentity() {
    console.warn('getIdentity is being deprecated and will be removed in version 3.x.x, please use sdk.keyPair instead');
    return keyPair;
  }

  function close(cb) {
    const process = _close();

    if (!cb) {
      return process;
    }

    process.then(() => cb(), cb);
  }

  async function _close() {
    await Promise.all([].concat(Array.from(drives.values()).map(drive => drive.close())).concat(Array.from(cores.values()).map(core => core.close())));

    if (handlers.close) {
      await new Promise((resolve, reject) => handlers.close(error => {
        error ? reject(error) : resolve();
      }));
    }
  }

  function resolveName(url, cb) {
    return dns.resolveName(url, cb);
  }

  function registerExtension(name, handlers) {
    return swarm.registerExtension(name, handlers);
  }

  function Hyperdrive(nameOrKey, opts) {
    if (!nameOrKey) throw new Error('Must give a name or key in the constructor');
    opts = Object.assign({}, DEFAULT_DRIVE_OPTS, driveOpts, opts);
    const {
      key,
      name,
      id
    } = resolveNameOrKey(nameOrKey);

    if (drives.has(id)) {
      const existing = drives.get(id);
      existing[HANDLE_COUNT]++;
      return existing;
    }

    if (name) opts.namespace = name;
    const drive = hyperdrive(corestore, key, opts);
    const wrappedDrive = makeHyperdrivePromise(drive);
    drive[HANDLE_COUNT] = 0;
    drive[CLOSE_FN] = drive.close;

    drive.close = function (fd, cb) {
      if (fd && cb) return this[CLOSE_FN](fd, cb);
      const hasHandles = wrappedDrive[HANDLE_COUNT]--;
      if (hasHandles > 0) setTimeout(fd, 0);else setTimeout(() => this[CLOSE_FN](fd, cb), 0);
    };

    drives.set(id, wrappedDrive);

    if (!key) {
      drive.ready(() => {
        const key = drive.key;
        const stringKey = key.toString('hex');
        drives.set(stringKey, wrappedDrive);
      });
    }

    drive.ready(() => {
      const {
        discoveryKey = drive.discoveryKey,
        lookup = true,
        announce = true
      } = opts; // Don't advertise if we're not looking up or announcing

      if (!lookup && !announce) return;
      swarm.configure(discoveryKey, {
        lookup,
        announce
      });
    });
    drive.once('close', () => {
      const key = drive.key;
      const stringKey = key.toString('hex');
      drives.delete(stringKey);
      drives.delete(id);
      const {
        discoveryKey = drive.discoveryKey
      } = opts;
      swarm.configure(discoveryKey, {
        announce: false,
        lookup: false
      });
    });
    return wrappedDrive;
  }

  function Hypercore(nameOrKey, opts) {
    if (!nameOrKey) throw new Error('Must give a name or key in the constructor');
    opts = Object.assign({}, DEFAULT_CORE_OPTS, coreOpts, opts);
    const {
      key,
      name,
      id
    } = resolveNameOrKey(nameOrKey);

    if (cores.has(id)) {
      const existing = cores.get(id);
      existing[HANDLE_COUNT]++;
      return existing;
    }

    let core;

    if (key) {
      // If a dat key was provided, get it from the corestore
      core = corestore.get({ ...opts,
        key
      });
    } else {
      // If no dat key was provided, but a name was given, use it as a namespace
      core = corestore.namespace(name).default(opts);
    } // Wrap with promises


    const wrappedCore = makeHypercorePromise(core);
    core[HANDLE_COUNT] = 0;

    core.close = function (cb) {
      if (!cb) cb = function noop() {};
      const hasHandles = wrappedCore[HANDLE_COUNT]--;

      if (hasHandles === 0) {
        setTimeout(() => {
          let promise = core._close(cb);

          if (promise && promise.then) promise.then(cb, cb);
        }, 0);
      } else if (cb) setTimeout(cb, 0);
    };

    cores.set(id, wrappedCore);

    if (!key) {
      core.ready(() => {
        const key = core.key;
        const stringKey = key.toString('hex');
        cores.set(stringKey, wrappedCore);
      });
    }

    core.ready(() => {
      const {
        discoveryKey = core.discoveryKey,
        lookup = true,
        announce = true
      } = opts; // Don't advertise if we're not looking up or announcing

      if (!lookup && !announce) return;
      swarm.configure(discoveryKey, {
        announce,
        lookup
      });
    });
    core.once('close', () => {
      const {
        discoveryKey = core.discoveryKey
      } = opts;
      const key = core.key;
      const stringKey = key.toString('hex');
      swarm.configure(discoveryKey, {
        announce: false,
        lookup: false
      });
      cores.delete(stringKey);
      cores.delete(id);
    });
    return wrappedCore;
  }

  function resolveNameOrKey(nameOrKey) {
    let key, name, id;

    try {
      key = DatEncoding.decode(nameOrKey);
      id = key.toString('hex'); // Normalize keys to be hex strings of the key instead of dat URLs
    } catch (e) {
      // Probably isn't a `dat://` URL, so it must be a name
      name = nameOrKey;
      id = name;
    }

    return {
      key,
      name,
      id
    };
  }
}

},{"./dns-web.js":1,"@geut/hypercore-promise":10,"@geut/hyperdrive-promise":13,"dat-encoding":130,"hyperdrive":251,"path":371}]},{},[2])(2)
});
